{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/rt/tcms.ts","~lib/shared/typeinfo.ts","assembly/common.ts","assembly/bfs.ts","assembly/pagerank.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/staticarray.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","assembly/spmv.ts","~lib/math.ts","~lib/number.ts","~lib/array.ts","assembly/fft.ts","assembly/lud.ts","~lib/arraybuffer.ts","~lib/typedarray.ts","~lib/rt.ts","~lib/util/sort.ts","~lib/function.ts"],"names":[],"mappings":"gbCqRE,AAAI,AALO,AAFK,KAEO,KAKZ,MAET,AAAK,AAAM,EAAQ,MAInB,AAAK,AAAO,EAAS,AADhB,EAAM,AAAW,MACI,IAAa,KACvC,EAAM,MAMR,AAAW,OACX,AAAI,AAFO,SAED,QACV,AAAI,IAAM,QAGV,AAAI,EArIJ,AACE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,UAQ9D,AACE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,IAC5D,KA8HA,AAAI,AAAC,KAEa,AA7JlB,EAA2B,EAAM,SA6JN,EAAO,MAAhC,AApJF,EACA,KAsJE,AAAI,AAAC,KAAO,OAAc,EAAO,gBAxGrC,AAAgB,OAOhB,AAAI,AAHY,qBAGA,KAEd,AAAI,AADU,AAAC,EAAY,GAAc,GAAkB,EAAY,MACzD,SAIZ,EAHA,AAAY,EAAM,IAClB,EAA2B,AAA0B,EAAzB,EAAY,SAE5B,AAtHhB,AAAyB,EAA2B,GAAkB,KAAe,cA4HrF,AAAI,EAAY,KAKd,AAAI,AADU,AAAC,AAFA,AApIjB,AAAmB,EAA2B,aAsIlB,GAAc,GAAkB,EAAY,MACxD,SAGZ,EAFA,AAAY,EAAM,IAClB,EAA0B,AAAyB,EAAxB,EAAW,SAC9B,OAKZ,EAAe,EAAY,MAS3B,AAAa,EAA2B,GAAiB,KAIzD,AAAI,AATO,EAAY,KASZ,MAET,AAAK,AAAM,EAAQ,MAInB,AAAK,AAAO,EAAS,AADhB,EAAM,AAAW,MACI,IAAa,KACvC,EAAM,MA1FR,AACE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,SA+F9D,OACA,OACA,AAAI,IAAM,QAzFV,AACE,EAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,IAC5D,KA2FF,OAAe,EAAK,OAhHpB,AACE,EAA2B,EAAM,MACjC,AAXF,AACE,KAyHiC,EAAK,aAmHxC,AAAQ,AAAC,AAAC,KAAoC,GAAY,KAwB1D,AAAI,AADO,AAtBX,EAAO,KAIP,AAAI,AAFO,AAzMT,UAgNA,AAAI,AAAwB,EAAxB,EAAQ,MAaG,EAXb,AAAW,OADX,EAAS,cAaF,OAOX,EAAc,AAAmB,EAAW,GAA9B,AAFC,EAAO,KAEG,OACzB,OACA,OAIA,AADA,AAAO,AAA2C,EAAzB,EAAQ,WAEjC,AAnOE,EACA,MAoOF,AAAY,EAAM,UAkDlB,AAAI,AAAc,AAFA,IAEd,KAA6B,AAAY,EAAc,KAAe,WAE1E,SACA,WACwB,EAAK,KAC3B,eACK,AAAc,MAAG,EAAK,KACzB,AAAkB,EAAJ,SAAN,UAD0B,AAAE,WAFF,AAAE,WAY5B,IAAM,IAAU,EAAiB,KAE7C,AAAO,SA5BP,AAAI,EAAQ,SAA+B,eAPpC,EAAQ,KACX,GACA,AAAC,AAAC,KAAmC,GAAY,UAzIrD,AAAI,EAAO,MAET,AAAK,AAAM,EAAQ,MASnB,AAAK,AAAO,EAJM,EAAO,SAIb,AAHR,EAAQ,EAAM,EAAW,AAAW,MAAU,SAGtB,AADvB,EAAM,AAHO,MAIe,IAAa,KAC9C,EAAM,MAOR,AAAK,WAF0B,EAAM,QA7KrC,AACE,EAA2B,AAAC,AAAkB,AA0LZ,GA1LL,EAAM,IAAyB,QAiL5D,AAAK,AADO,KAAc,EAAO,EAAK,WAIpC,AAAK,AAAW,QAGS,AAAS,AA1MpC,EAA2B,EAAM,0BA2NnC,AAAI,AADY,AAAC,AAJD,OAIa,GAAc,KAC1B,KACf,EAAe,EAAQ,EAAY,OAGnC,AADA,AAAY,AAA8D,EAA5C,EAA2B,MAC1C,AAAC,EAAY,GAAkB,MAC9C,AAAY,EAAM,KAIlB,EAAe,EAAY,MAC3B,AAtRuB,EAA2B,KAAkB,KAAe,IAsRnF,cAA0B,eA0H5B,AAAI,AAAC,AADO,AAAY,EAAM,AADZ,AAAY,aAOX,EA3DnB,AAAkB,AAAO,AAAC,AARtB,AA+De,EA/DR,SAET,EAAQ,AAAC,EAAM,EAAW,AAAW,KAAU,QAKzC,EAAkB,AAAM,AAAC,AADf,IACqC,GAAM,GAAkB,AAlQ7E,SAmQ+B,KAAU,KAAa,KAEpD,AAAY,AADM,EAAa,UACJ,KAC7B,AAAI,AAAY,IAAe,QAGvB,EAAM,EAAsB,GAAI,EAAqB,KAkDrD,AAA8B,EAAM,eAI9C,AAAY,EAAM,IAClB,AAAa,EAAM,EAAc,IAEjC,OC/ZA,AAAI,EAAQ,SAAgC,eACP,AAAkB,EAAlB,KDmerC,AAAI,AAAC,KAAM,GCheX,AAHA,AAAU,ADoe6B,EAAM,WChe7C,OAIA,AAAW,AADA,SAEX,EAAoB,EAA0B,MAC9C,OACA,EAzCuB,EAA0B,KAAqB,OA0CtE,OAMO,EAAyB,YDkehC,AAAI,EAAM,SACV,AAAI,AAAC,KAAM,GA7BX,AAAY,AA8BmB,EA9BK,KAElC,AAAY,AAAE,EAAM,MAApB,KACE,OATJ,EAAe,KAAe,MAC9B,AAmCU,EAnCQ,UC3ZlB,AAAI,AAAa,EAAb,AAjFS,MAAqB,MAqFhC,AAAI,AADO,AA9Fe,MAAqB,OAiG7C,EADA,AAAW,WAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,GAAoB,EAAwB,AAAK,OACjD,QACA,EArGqB,AAA0B,KAAqB,GAA/C,OAsGrB,SAhBF,AAAI,AAAa,EAAb,AAjFS,MAAqB,MAqFhC,AAAI,AADO,AA9Fe,MAAqB,OAiG7C,EADA,AAAW,WAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,GAAoB,EAAwB,AAAK,OACjD,QACA,EArGqB,AAA0B,KAAqB,GAA/C,OAsGrB,SAhBF,AAAI,AAAa,EAAb,AAjFS,MAAqB,MAqFhC,AAAI,AADO,AA9Fe,MAAqB,OAiG7C,EADA,AAAW,WAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,GAAoB,EAAwB,AAAK,OACjD,QACA,EArGqB,AAA0B,KAAqB,GAA/C,OAsGrB,eAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,UAWF,AAAkB,IAGlB,AAAY,AAAK,KAEjB,AAAW,AA3HiB,AA0HnB,OA1HwC,KA4HjD,EAAO,EAAQ,KACb,EA9GqB,AAAqC,EAApC,KAAqB,OA+G3C,wBAAgB,EAA0B,kDAtCvC,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,sBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,sBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,aeyWE,AAAU,AADA,OACO,AAAO,KAAgB,MACxC,EAAO,AAAM,EAAN,KAEL,AAAI,AADM,AAAY,SACb,Af/XV,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,Ue6WI,EAAO,SAGX,AfnYG,AemYK,AAAkB,SfhY5B,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,qBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,sBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,mBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,sBAnBG,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,esB/HA,AtB4GG,AsB5GK,StB+GV,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,YQ6EE,AAAU,EAAM,AAAmB,EAA0B,SAC7D,EAAO,EAAM,KAEX,AAAI,AADM,AAAY,SACb,ARnGV,IAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,UQiFI,EAAO,YO+RX,AfnYG,AemYK,AAAkB,SfhY5B,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,UAoBA,AAAO,AA/HmB,KAAqB,SAoIjD,AAAO,AApIqB,AAmIjB,OAnIsC,KAqIjD,EAAO,EAAQ,KACb,AAAc,AAtIY,KAAqB,KAuI/C,AAAI,EAA0B,OAM5B,AAAO,EAA0B,MAEnC,AAAO,QAET,OACA,OAGA,AAAY,IACZ,AAAU,IACV,AAAQ,SA/DR,AAAI,AAAC,OAGL,AAAI,AAAa,EAAb,AAjFS,AA+EH,AAAmB,EAAM,QA/ED,MAqFhC,AAAI,AADO,AA9Fe,KAAqB,OAiG7C,EADA,AAAW,UAEX,EA7FmB,EAA0B,KAAqB,QAkGpE,AAAW,AADF,SAET,EAAoB,EAAwB,AAAK,OACjD,OACA,EArGqB,EAA0B,KAAqB,OAsGpE,cU9IA,ECsLA,AAAI,ADtLW,KCwLf,AAAU,EAAM,KAChB,AAAU,AAFC,EAAO,GAAI,KAEN,KAChB,AAAI,EAAK,KACT,AAAU,EAAM,KAChB,AAAU,EAAM,KAChB,AAAU,EAAM,KAChB,AAAU,EAAM,KAChB,AAAI,EAAK,KACT,AAAU,EAAM,KAChB,AAAU,EAAM,KAChB,AAAI,EAAK,KAYT,AAAW,AARX,EAAQ,AADO,EAAC,GAAO,QASN,KACjB,AAAW,AAFJ,EAAO,AALd,AADA,EAAK,GACA,MAKa,KAED,KACjB,AAAI,EAAK,KACT,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAI,EAAK,KACT,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KAIjB,EAAQ,AADJ,AAAM,EAAO,GAAb,QAEJ,EAAK,KAIL,EAAO,EAAK,KACV,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,AAAW,EAAM,KACjB,EAAK,KACL,EAAQ,eHzKV,AAAI,EAAc,QAA0D,eAG5E,AAAY,AADF,AAAiC,AAD7B,EAAiB,KACqB,MACb,WIvEzC,AAAW,AAAqB,QAChB,AAAI,EAAJ,KACd,AJkGS,EAA2B,EAAgB,IAAe,YInG5C,AAAE,WAG3B,cNunBA,AAAI,AADS,AAAM,AADV,AAAiB,AOoHP,OPnHM,GAAK,OACjB,IAAS,KAQpB,EAPyC,SAArC,EAAS,IAAS,UACtB,AAAI,EAAU,MACyB,SAAjC,EAAM,aACkB,AAAM,EAAN,UAAxB,EAAU,OACP,AAAY,SAAG,SAAU,EAAM,QAG/B,MAkBX,AAFS,AAXS,EAAV,UAWK,YAEP,YASN,AAAY,AAAU,AALZ,AAAS,AALV,AAAiB,KAKF,IAAW,IAKU,GAAvB,SAA+D,AAJ3E,EAAO,MAOjB,AAAS,AAVD,EAAI,EAAK,WAAY,EAAK,aAUrB,KAGb,AAAU,AARkB,AAAU,MAQrB,GAAI,EAAM,AAAK,EAAI,UAAT,YAAe,EAAK,GAAM,AAAK,EAAI,UAAT,cACrD,AAAI,OA1FJ,AAAI,AAAE,EAAK,UAIF,AAAY,AADX,AAAiB,AADzB,EAAS,cAEkB,EAAQ,IAA5B,aAoBT,AAbA,AAAI,AAAI,AADA,AADA,AAAiB,AAFzB,EAAS,gBAGO,EAAQ,OACX,YAWX,AAAI,AAFC,AAAC,AAFG,AAFC,AAAS,SAAK,KAET,KAEJ,AADN,EAAM,GAAK,GAAI,AAFX,EAAQ,GAAI,EAAQ,MAGZ,KAER,YAAS,AAAiB,EAAQ,qBAElC,cAsEX,AAAO,AAHK,AAAiB,KAGd,EAAQ,iBA8sBvB,AAAI,AADK,AOndU,KPodV,WAAK,YAgBL,AAXL,AAFO,AADA,AADA,EAAI,YACA,KACC,KAEN,AAAK,EAAI,UAAT,UAAc,EAAK,WACzB,EAAM,AAAK,EAAI,UAAT,UAAc,EAAK,WACzB,EAAM,AAAK,EAAI,UAAT,UAAc,EAAK,WAAK,EAAK,gBAS1B,AADX,AADS,EAAI,AADJ,EAAI,AADT,AAFM,EAAI,AADJ,EAAI,aACI,KAER,GAAM,gBAEE,GACZ,AAAK,AAJD,EAAI,GAIR,UAAY,EAAM,MACR,QAGlB,AAAI,AADM,AAAI,EAAM,MACV,GAAU,OAaT,EAXkB,SAAQ,EAAI,IAAnC,AAAC,EAAM,OACkC,EAAzC,EAAM,eAC6C,AAAC,EAAI,KAAM,GAA9D,EAAkB,AAAC,EAAM,KAAW,KAAnC,EAAM,SAGX,AADsB,EAAI,WACpB,kBAMQ,aACY,GAAwB,KAeP,KAAvB,MAEtB,AAAQ,AAAC,AAXmB,AAJjB,EAAM,EAAO,YAeX,AAFS,MAEH,AADG,MACI,AAbL,AAAiB,EAAjB,YAmBrB,AAAS,AADA,AAHA,AAlBE,EAAY,MAqBT,UAAQ,AAjBD,QAkBR,KASb,AAAO,AARE,EAAI,GAAK,GAAI,EAAK,WAQf,AALH,EAAI,KAKI,WAAK,EAAI,GAAM,AAAK,EAAI,UAAT,UAAc,EAAM,AAAK,EAAI,UAAT,cAAgB,SEp3ClE,AAAI,EAAc,SAA0D,eAG5E,AAAY,AADF,AAAiC,AAD7B,EAAiB,KACqB,MACb,YGtFzC,EAAO,AAAM,EAAM,KAAZ,KACK,SAAiB,mBAC3B,WAIF,AAAI,AAAC,EAAO,MACV,EAAO,EAAK,KACV,AAAW,EAAW,AAAU,QAChC,AAAW,EAAW,AAAU,QAChC,AAAW,EAAW,AAAU,QAChC,AAAW,EAAW,AAAU,QAChC,EAAO,KAAI,EAAQ,KAAI,EAAK,SAE9B,AAAI,EAAI,KAGN,EAFA,AAAW,EAAU,AAAU,QAC/B,AAAW,EAAU,AAAU,QACpB,EAAO,KAAlB,EAAQ,OAEV,AAAI,EAAI,KAEN,EADA,AAAW,EAAM,AAAU,QAChB,EAAO,KAAlB,EAAQ,OAEV,AAAI,EAAI,KAEN,EADA,AAAW,EAAM,AAAU,QAChB,EAAO,KAAlB,EAAQ,OAEV,AAAI,EAAI,KACN,aAOJ,AAAI,EAAK,KACP,QAAQ,EAAY,aAGhB,AAAI,AAAU,iBAEJ,OAAiB,yCAE3B,EAAK,KACL,EAAO,EAAK,KAEV,AAAW,EAAM,AAAU,AADvB,AAAU,OACkB,GAAf,EAAK,OAEtB,AAAW,EAAU,EAAK,GAAK,AAD3B,AAAU,OACsB,OAEpC,AAAW,EAAU,EAAK,GAAK,AAD3B,AAAU,OACsB,OAEpC,AAAW,EAAW,AAAU,AAD5B,AAAU,OACuB,GAAf,EAAK,OAC3B,EAAO,KAAI,EAAQ,KAAI,EAAK,YAK9B,AAAI,AAAU,6CAGd,EAAK,KACL,EAAO,EAAK,KAEV,AAAW,EAAM,AAAU,AADvB,AAAU,OACkB,GAAf,EAAK,OAEtB,AAAW,EAAU,EAAK,GAAK,AAD3B,AAAU,OACsB,OAEpC,AAAW,EAAU,EAAK,GAAK,AAD3B,AAAU,OACsB,OAEpC,AAAW,EAAW,AAAU,AAD5B,AAAU,OACuB,GAAf,EAAK,OAC3B,EAAO,KAAI,EAAQ,KAAI,EAAK,YAK9B,AAAI,AAAU,OACJ,SAAiB,mBAC3B,EAAK,KACL,EAAO,EAAK,KAEV,AAAW,EAAM,AAAS,AADtB,AAAU,OACiB,GAAd,EAAK,OAEtB,AAAW,EAAU,EAAK,GAAI,AAD1B,AAAU,OACqB,OAEnC,AAAW,EAAU,EAAK,GAAI,AAD1B,AAAU,OACqB,OAEnC,AAAW,EAAW,AAAS,AAD3B,AAAU,OACsB,GAAd,EAAK,OAC3B,EAAO,KAAI,EAAQ,KAAI,EAAK,WAQpC,AAAI,EAAI,eAEI,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,0CAG7B,AAAI,EAAI,eAEI,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,aACjB,OAAiB,0CAG7B,AAAI,EAAI,eAEI,OAAiB,aACjB,OAAiB,0CAG7B,AAAI,EAAI,4CAIR,AAAI,EAAI,KACN,iBDhHA,EAAkB,ICuHpB,AAAI,ADvHM,EAAK,KCwHW,AACpB,EAAM,GAAO,GAAK,EAAE,EAAK,OAC3B,AAAO,EAAM,EAAK,OAItB,AAAI,EAAO,KACiB,AACpB,AAAC,EAAM,GAAO,EAAO,MACvB,EAAO,EAAO,KACZ,AAAI,AAAC,KACL,AAAE,OACQ,SAAiB,uBAE7B,EAAO,EAAK,KACV,AAAW,EAAM,AAAU,QAC3B,EAAQ,KACR,EAAQ,KACR,EAAQ,UAId,MACY,SAAiB,mBAC3B,AAAE,YAGsB,AACpB,AAAC,EAAM,GAAO,EAAO,MACvB,EAAO,AAAC,EAAO,GAAK,KAClB,AAAI,AAAC,KACL,AAAU,AAAO,AAAE,OAAT,GAAY,AAAS,EAAM,aAEvC,EAAO,EAAK,KAEV,AAAW,AAAO,AADlB,EAAK,KACM,GAAU,AAAU,EAAM,cAI3C,MACE,AAAU,AAAO,AAAE,OAAT,GAAY,AAAS,EAAM,kBZsWzC,AAAY,AADG,AAAc,EAAM,MACO,GAAgB,EAA2B,GAAgB,KAAe,KACpH,AAAI,EAA4B,OAUhC,EAAe,KAAe,MAC9B,AAAY,EAAM,agB5WoB,AADpB,AADH,AAEF,OADc,OApLvB,EAAU,AADI,OACmB,MACnC,AAAI,EAAU,SAAkD,cAG1C,AAFR,AAAkB,SAED,AADb,EAAW,OfmG/B,AAAa,AAAmB,EAAS,OACzC,AAAI,EAAS,OAEX,AAAY,AADC,AAAM,EAAM,SACL,EAAQ,AAAI,EAAM,kBAGxC,AAAI,EAAQ,SAAgC,eAErB,EAAS,KAAiB,AAAkB,EAAlB,KD0cjD,AAAI,AAAC,KAAM,GACH,EAAM,WAnBd,AAAY,AAAkB,EAAM,KAElC,AAAY,AAAE,EAAM,MAApB,KACE,OAiBA,AAA4B,EAAM,EAAqB,SACrB,IArBtC,AAAY,AAAkB,EAAM,KAElC,AAAY,AAAE,EAAM,MAApB,KACE,SAnDJ,AAAI,AALc,AAAY,MAKX,AAHH,AADA,OACY,QAc5B,AAAI,AADY,AA7ahB,AAAyB,EAA2B,GAAkB,KAAe,WA8arE,KAEd,AAAI,AAAa,EAAb,AADY,EAAY,GAAkB,EAAY,SAExD,AAAY,EAAM,IAGlB,EAAe,AAA0B,EAAzB,EAAY,WAQhC,AAAiB,EAAM,EAAO,SAxB5B,AAAa,EAAM,EAAO,MCvY5B,AADa,AAAmB,AADnB,OAC4B,UAIzC,AAxE4B,KAAqB,QAK1B,EAA0B,AAoEjD,UApEsE,ce3CpE,AAAY,AADE,EACQ,GAAgB,EAAc,KACpD,AAAI,EAAY,KACd,AAAa,EAAO,KACpB,AAAa,EAAO,MAGtB,AAAW,EAAO,MA4KhB,AAAa,KAAkB,EAAiB,IAAe,KAKjE,eP9GA,AAAY,AADF,AAAiC,KAAS,MACb,OAAvC,AAAY,AADF,AAAiC,IAAS,MACb,MAAvC,AAAY,AADF,AAAiC,IAAS,MACb,MAAvC,AAAY,AADF,AAAiC,IAAS,MACb,ML1DzC,AAAc,AAAqB,QK0DjC,AAAY,AADF,AAAiC,KAAS,MACb,SLtDzB,EAAI,yCYwBlB,AAAY,AADC,AAA8B,EAAY,MACb,IAC1C,OACA,OACA,OACA,OZ3BA,AKkFS,EAA2B,EAAgB,ILlF9B,KADQ,AAAE,WAI7B,AAAQ,MAAG,EAAI,ODpBpB,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MCgBpC,AAAmB,AAAS,EAAkB,iBAC9C,AAAe,AKoEA,EAA2B,EAAgB,SLlErD,AAAQ,MAAG,AAAI,EAAJ,MDxBlB,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,UALtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,cCoBnB,AAAS,EAAiB,0BAG/B,EAAY,IK8DT,EAA2B,GAAgB,iBL7DX,oBAAnC,EAA0B,IALN,AAAE,WAJJ,AAAE,WAalC,AAAiB,IACZ,MAAW,EAAI,OACC,AYaZ,AP0CQ,EAA2B,EAAgB,sBLtDrB,YK+D5B,AAA2B,EL/DzB,QACX,AK8DS,AAA2B,EAA3B,GAA0D,KL7DnE,AK6DS,AAA2B,EAA3B,GAA0D,KL5DnE,AK4DS,AAA2B,EAA3B,GAA0D,KL3DnE,AAAc,EAAd,KAN8B,AAAE,WASlC,AKwDW,EAA0D,KLvDrE,AKuDW,EAA0D,KLrDrE,AAAoB,AAAqB,MAEzC,AAAQ,IACH,MAAW,EAAI,OAClB,AAAY,AYFL,AP0CQ,EAA2B,EAAgB,cLvC1D,AAAY,AKuCG,OLtCV,AAAQ,MAAG,EAAI,KAClB,AK8CO,EAA2B,EAAgB,IAAe,AL9CrC,AY6Bf,KAAkB,EAAgB,cZ5B/C,EAAK,KAFkB,AAAE,WAHG,AAAE,WAS7B,AAAQ,MAAG,EAAI,OAClB,AKwCS,EAA2B,EAAgB,IAAe,KLzCrC,AAAE,WAGlC,AKsCW,EAA0D,+DL9BrE,AAAoB,AADN,SAEd,AAAmB,OACnB,AAA2B,OAC3B,AAAsB,OACtB,AAAc,OACd,AAAoB,OAKpB,AAAW,IACX,EACE,AAAO,IAEF,MAAa,EAAM,OACtB,AAAI,AKMS,AAA2B,EAA3B,QLLX,AKcK,AAA2B,EAA3B,GAA0D,KLb/D,AAAa,AKIF,EAA2B,EAAgB,SLDtD,AAAY,AAAkB,AADhB,AADD,AKGF,EAA2B,EAAgB,cLD1C,UACQ,EAAI,KAEtB,AAAI,AAAC,AKFI,EAA2B,ALCzB,AKDF,EAA2B,EAAgB,gBLGlD,AKMC,EAA2B,EAAgB,IAAe,ALNpC,EAAO,MAC9B,AKKC,AAA2B,EAA3B,GAA0D,MLTlC,AAAE,YAPC,AAAE,WAiBjC,AAAU,MAAG,EAAM,OACtB,AAAI,AKXS,AAA2B,EAA3B,QLcX,EAFA,AKHK,AAA2B,EAA3B,GAA0D,KLI/D,AKJK,AAA2B,EAA3B,GAA0D,KLM/D,AKNK,AAA2B,EAA3B,GAA0D,KLKxD,MAJyB,AAAE,WAQtC,AAAE,OACK,KACT,EAEA,AAAO,EAAK,QK7CV,AAAI,EAAc,SAA0D,eAG5E,AAAY,AADF,AAAiC,AAD7B,EAAiB,KACqB,MACb,gBKkDzC,AAAS,AAAU,AAHN,AAAc,AAAM,AAFpB,AAAC,AADE,EAAI,YACO,GAAM,MAEU,IAAM,GAApC,WAIb,AAAS,AAAU,OACnB,AAAS,AAAU,OAGnB,AAAI,AATS,EAAS,UAcpB,EAFA,AAAK,AAAe,EAAM,GAArB,EAAM,AAFE,GAAK,SAGlB,AAAK,AAAe,EAAM,GAArB,EAAM,MACN,AAAe,EAAM,GAArB,AAHc,KAGR,QAOb,AAAkB,AAAC,EAAI,UAAsB,4FAQ7B,AADN,AAAc,EAAe,GAA5B,EAAM,wBAxEjB,AAAY,AAAI,AAqF0C,AAAM,AAHtD,AADA,AAHA,AAJA,AAAY,AAAI,EAAM,IAAtB,AAAM,EAAN,AAHK,EAAL,OAOO,GAAI,EAAO,MAGN,KACL,GAGyC,QA5DrD,AAvBA,EAAM,GAAQ,AAmF4B,AAAM,EAAN,AARrC,EAAO,MA3ES,GAAK,OAuBtB,SAST,AAAK,AAAK,AANV,EAAM,KAMD,OAAU,AAFV,AAAI,EAAJ,OAAU,AAFV,AAAK,EAAL,SAEe,MAED,UAEnB,AAAY,AAAI,EAAJ,OAAQ,AAHf,EAAK,IAGgB,EAAK,MAxB/B,AAAa,AAAY,AAAI,AAyB7B,AAAmB,AANd,EAAI,OAMD,EAAK,MAzBqB,AAFxB,AAAM,AAAoB,GAApB,UAA8B,AAAoB,AAPlE,EAAO,IAOuC,gBAE3B,AAJT,AAFD,IAEO,OAKhB,AAAa,AAAU,AAAY,EAAN,AAJR,EAAM,GAAjB,EAAM,MAIH,YA4Eb,EAAc,AAJA,UAtEd,EAsEwE,IAEjC,AADxB,EAAI,GAAO,mBAI1B,EAAc,KAPJ,AAAC,EAAY,GAAM,cAo/C3B,AAAW,AADF,AAAM,AADP,AAAiB,KACL,MACH,KAGjB,AAAI,AAFJ,EAAM,SAEI,SACR,AAAI,EAAK,SACP,AAAa,IACb,AAAa,aAGf,AAAa,kGACb,AAAa,+IAIf,AAAI,EAAM,SAER,AAAa,AADJ,EAAI,OAEb,AAAa,QA3+CS,AACpB,AAHG,AAAM,EAAK,IAAM,SAGf,SACP,AAAQ,IACR,AAAK,IAWH,AAAI,EAAI,YASR,AAAI,IARJ,AAAI,EAAM,SAEH,AAAC,EAAI,AADL,EAAI,aACO,WAGhB,AAAK,AADL,EAAK,YACI,YACJ,AAAC,EAAI,GAAM,YAjBlB,AAAI,EAAI,YACR,AAAI,EAAM,SAEH,AAAC,EAAI,AADL,EAAI,aACO,WAGhB,AAAK,AADL,EAAK,YACI,YACJ,AAAC,EAAI,GAAM,cAcpB,AAAa,IACb,AAAa,IACN,KAIX,AAAI,EAAK,SA2BP,EAjBA,AAAI,AAFK,AAHA,EAAM,KAGD,AAAC,AADA,AAAiB,AADvB,AAHA,EAAI,AADJ,AAAQ,EAAI,aACJ,aAGJ,AAFJ,EAAI,gBAG0B,IAClB,GAAM,KAEnB,KAiBK,EAbX,AAAK,EAAI,UAAW,AAAC,EAAI,AADpB,EAAI,AADJ,EAAI,gBAEqB,MAI9B,AAAI,AADA,EAAK,AAAC,AADC,AAAiB,AADvB,EAAI,MAC0B,IACnB,GAAM,KACd,KAIN,AAAK,EAAI,UAAW,AAAC,EAAI,AADpB,EAAI,AADJ,EAAI,gBAEqB,MACzB,EAAI,gBAKb,AAAa,AAFH,EAAI,GAAM,KAGb,MAGT,AAAc,EAAC,AADP,AAAmB,OACT,EAAG,MAiBrB,AAAQ,AAHA,AAq6CW,IAr6CP,KAGA,KAo6CA,AAn6CZ,AAGS,EAAK,AAAC,EAAK,AAAM,AA65Cf,IA75CS,UAAU,EAAI,AAL1B,AAAK,EAAK,AAAK,EAAI,UAAT,WAAV,UAAyB,EAAI,AAD7B,EAAI,MAC8B,AAAK,EAAI,UAAT,eAKH,GAAK,EAAI,gBAg6C3B,AA54Cd,AADH,SAAM,AADD,AAAM,EAAN,eAEG,AAAC,AAAC,SAAM,GAAK,GAAO,EAAI,AAH5B,EAAK,AAAK,EAAK,AAAK,EAAI,UAAT,WAAV,WAA0B,AAD/B,EACmC,GAAK,AAAK,EAAK,AAAK,EAAI,UAAT,WAAV,aAGR,EAAI,QA64C1C,AAAI,AANI,EAMA,KAEN,EADA,AAAO,IACD,AAAC,OAET,AAAI,EAAI,KAEN,EADA,AAAM,AAAC,KACD,AAAC,OAET,AAAa,IACb,AAAa,YGnrDf,AAAU,AAAqB,AADrB,AR4ED,AAAmB,EAA0B,MAA2B,SQ1EjF,AAAU,AAAqB,QAE/B,AAAI,EAAM,KACR,AR+FS,EAA0D,AATpD,QQrFf,AR8FS,EAA0D,AATpD,WQhFjB,AAAW,AAAqB,AADpB,EAAI,SAEhB,AAAW,AAAqB,MAChC,AAAW,AAAqB,MAChC,AAAW,AAAqB,QAEhB,AAAI,EAAJ,KACd,ARmFS,EAA2B,EAAgB,MAAe,AATpD,EAA2B,AQ1EjB,EAAJ,KR0EqC,YQzE1D,ARkFS,EAA2B,GAA+B,AATpD,EAA2B,SQxE1C,ARiFS,AAA2B,EAA3B,GAA0D,AATpD,EAA2B,AQxErB,EAAQ,GRwE6B,YQvE1D,ARgFS,AAA2B,EAA3B,GAA0D,AATpD,EAA2B,SQ3EnB,AAAE,WAO3B,AAAU,AAAU,EAAI,MACxB,AAAU,AAAU,EAAI,MACxB,AAAW,OACX,AAAW,OACX,AAAW,OACX,AAAW,SAEK,EAAI,KAnCpB,AAAkB,AAoCW,AAAiB,GAAjB,UAAsB,MAnClC,IAA2B,wBAoChC,AR2DK,AASN,EAA2B,EAAgB,aQlEpD,ARkES,EAA0D,AQlEhD,EAAI,MAAM,AADnB,AR0DK,EAA2B,UQzDT,UACjC,ARiES,EAA0D,AQjEhD,EAAI,MAAM,EAAI,UALV,AAAE,WAQtB,AAAQ,MAAG,EAAI,KAGlB,AAAW,ARkDI,EAA2B,EAAgB,WQjD1D,AAAW,ARiDI,AAA2B,EAA3B,QQhDf,ARyDS,AAA2B,EAA3B,GAA0D,AQzDjD,AAJP,ARoDI,AAA2B,EAA3B,QQhDQ,AAHZ,ARmDI,AAA2B,EAA3B,YQ/Cf,ARwDS,AAA2B,EAA3B,GAA0D,AQxDjD,EAAK,MAEvB,ARsDS,EAA2B,AQtDvB,EAAI,GRsDmC,MAAe,AQtD3C,EAAK,MAC7B,ARqDS,AAA2B,EAA3B,GAA0D,AQrD3C,EAAK,MATN,AAAE,0CAiB3B,AAAU,ARqBD,AAAmB,EAA0B,MAA2B,OQnBjE,EAAI,KAElB,AAAY,AADD,ARiCI,EAA2B,EAAgB,cQ/B1D,AAAY,OAEP,AAAQ,MAAG,EAAI,KAGlB,AAAY,AAFD,AR4BE,EAA2B,EAAgB,cQxBxD,AAAQ,ARwBK,EAA2B,EAAgB,SQvBxD,AAAQ,ARuBK,EAA2B,EAAgB,SQrBxD,AR8BO,EAA2B,EAAgB,IAAe,AATpD,AQ3BD,OR2B4B,EAAgB,UQpBxD,AR6BO,EAA2B,EAAgB,IAAe,AATpD,EAA2B,EAAgB,UQlBxD,AR2BO,EAA2B,EAAgB,IAAe,KQ1BjE,AR0BO,EAA2B,EAAgB,IAAe,KQtC5C,AAAE,WALJ,AAAE,mBAsDzB,AAAU,AAA4B,SACtB,EAAI,UAbpB,AAAU,AAAqB,OAC/B,AAAU,AAAqB,SAEf,EAAI,MdrGpB,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MciGpC,ARHS,EAA2B,EAAgB,IAAe,AQGjD,Ad3FpB,AWqa0B,SG1UiB,adtG3C,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MckGpC,ARJS,EAA2B,EAAgB,IAAe,AQIjD,Ad5FpB,AWqa0B,SGzUiB,aAFpB,AAAE,+BRFd,AQaE,ERbyB,EAAgB,IQOtD,KAKuB,AAAE,WAWzB,AAAW,QA1CX,AAAU,AAA4B,AAD1B,ARJH,AAAmB,EAA0B,MAA2B,WQOjE,EAAI,KACP,AROI,EAA2B,AASN,EAAgB,WQfpD,AReS,AAA2B,EAA3B,GQfS,AAAU,KAAM,UAFX,AAAE,WAI3B,AAAU,IAEL,AAAQ,MAAG,EAAI,KACP,ARCI,AASN,EAA2B,EAAgB,WQTpD,ARSS,EQTS,AAAU,KAAM,UAFX,AAAE,WAI3B,AAAU,IAgCV,EAEO,EAAK,WH4zCV,AAAyB,AL/2CzB,AAAO,AAAmB,EAA0B,QAA2B,OS3FjF,AAAU,AAAqB,AT2FtB,KAAwE,OS1FjF,AAAU,AAAqB,AT0FtB,KAAwE,SSxFjE,AAAI,EAAJ,MACT,AAAQ,MAAG,AAAI,EAAJ,MACd,AAAI,AAAI,EAAJ,KT8GG,EAA2B,AS7GlB,GAAI,GAAO,KT6GuB,MNnGtD,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MefhC,AT6GK,EAA0D,AK6U3C,QIzbf,AAAI,AAAK,EAAL,KACT,AT2GK,EAA2B,AS3GlB,GAAI,GAAO,KT2GuB,IAAe,aSzG/D,ATyGK,EAA2B,ASzGlB,GAAI,GAAO,KTyGuB,IAAe,cS/GzC,AAAE,WADJ,AAAE,WAYvB,AAAQ,MAAG,AAAI,EAAJ,MACT,AAAQ,MAAG,AAAI,EAAJ,MACd,AAAI,EAAI,KACN,ATiGK,EAA2B,ASjGlB,GAAI,GAAO,KTiGuB,IAAe,aAA1D,EAA2B,AS/FlB,GAAI,GAAO,KT+FuB,MNnGtD,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MeDhC,AT+FK,EAA0D,AK6U3C,QIhbE,AAAE,WADJ,AAAE,WAUvB,AAAQ,MAAG,AAAI,EAAJ,MACT,AAAQ,MAAG,AAAI,EAAJ,MACd,AAAe,WACV,AAAQ,MAAG,AAAI,EAAJ,MACd,EAAO,AT6EI,EAA2B,AS7ElB,GAAI,GAAO,OT6EuB,OS7ET,AT6ElC,EAA2B,AS7EoB,GAAI,OT6ER,WS9E9B,WAG1B,AToFO,EAA2B,ASpFf,GAAI,GAAO,KToFoB,IAAe,KSzFzC,AAAE,WADJ,AAAE,mBAqC5B,AAAa,AADE,AAAqB,UAGpC,AAAW,MAzBK,EAAI,MACb,AAAQ,MAAG,EAAI,MAClB,AAAiB,ATiEJ,EAA2B,ASjEL,EAAX,EAAI,ITiE4B,SShEnD,AAAI,MAAG,AAAI,EAAJ,KACV,AAAW,EAAO,AT+DP,EAA2B,AS/DF,EAAX,EAAI,IT+DyB,OS/Db,AT+D9B,EAA2B,AS/DqB,EAAX,EAAI,IT+DE,WShErC,AAAE,WAIrB,ATqEO,EAA2B,ASrEL,EAAX,EAAI,ITqE4B,IAAe,KS3EzC,AAAE,WASvB,AAAQ,EAAI,OAAG,EAAI,MACtB,AAAiB,ATwDJ,EAA2B,ASxDL,EAAX,EAAI,ITwD4B,SSvDnD,AAAI,MAAG,AAAI,EAAJ,KACV,AAAW,EAAO,ATsDP,EAA2B,AStDF,EAAX,EAAI,ITsDyB,OStDb,ATsD9B,EAA2B,AStDqB,EAAX,EAAI,ITsDE,WSvDrC,AAAE,WAGrB,AT6DO,EAA2B,AS7DL,EAAX,EAAI,IT6D4B,IAAe,AS7D/B,EAAM,AToD3B,EAA2B,ASpDkB,EAAX,EAAI,IToDK,WSzD5B,WAVN,AAAE,WA2B5B,EAEO,EAAK,SJu9CV,AAAI,AAAiB,GAAM,YAIlB,AAAsB,EAAI,AAAmB,IAAI,KAK1D,AAAS,AAAM,AAFN,AAAiB,KAEL,GAAK,MAC1B,AAAS,AAJA,AAAiB,KAIX,KAEf,AAAI,EAA2B,AAAW,KAAtC,EAAY,AAJP,AAAM,EAAM,GAAK,MAIJ,IAAlB,AADM,EAAM,UAGP,AADC,EAAI,KACD,KAGb,AAAI,AAAO,EAAP,AADM,EAAM,QAEP,EAAI,AAAW,EAAP,OAEjB,AAAI,AAAC,KAEH,EAAO,EAAI,AADX,EAAM,AAAiB,EAAM,UAI7B,AADA,EAAM,UACA,aAER,AAAI,AAAC,KAEH,EAAO,EAAI,AADX,EAAM,AAAiB,EAAM,UAI7B,AADA,EAAM,UACA,eAER,EAAO,EAAK,KAKV,AAJA,AAAI,EAAM,KACR,AAAI,EAAM,KACV,EAAM,OAED,KACP,AAAE,aAEJ,AAAI,EAAM,KAOV,EANE,AAAI,EAAM,KACV,EAAM,UAKD,AAFK,AAAiB,EAAM,SASnC,AAAwB,AANxB,AAAI,AAFJ,EAAM,KAEG,KAEP,AADA,EAAM,UACA,EAAM,KAEZ,EAAO,AAAM,EAAL,KAEoB,EAAM,OApBX,AAAI,EAAJ,aLh+CzB,AAAI,EAAc,AAJX,AAAmB,EAA0B,MAA2B,MAItB,eAOzD,AAIe,EAA2B,EAAgB,aApB1D,AAAY,AADF,AAAiC,GAAS,MACb,OJ7EzB,EAAI,MAClB,AIyGS,EAA2B,EAAgB,IJzG9B,AAAqB,QADtB,WAIlB,AAAQ,MAAG,EAAI,MAClB,AIqGS,EAA2B,EAAgB,MAAe,KJpGnE,AAAa,AI2FE,AAA2B,EAA3B,QJ1FV,AAAQ,MAAG,EAAI,MAClB,AAAI,AAAK,EAAL,KFDR,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MEJpB,AAAS,eAA8B,gBACnD,AIiGK,EAA2B,EAAgB,IAAe,KJhG/D,AIgGK,EAA2B,EAAgB,MAAe,AJhGpD,AIuFA,KJvFgB,OAHR,AAAE,WAQzB,AAAI,EAAU,SFRhB,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MEMzB,AAAM,EAAN,AADH,AAAC,ASsae,sBTnatB,AIsFO,EAA2B,EAAgB,IAAe,KJrFjE,AIqFO,EAA2B,EAAgB,IAAe,MJtG9C,qBIyErB,AAAY,AADF,AAAiC,GAAS,MACb,KJGzC,AAAkB,AAAqB,OACvC,AAAkB,AAAqB,OAEvC,AAAc,aAEE,EAAI,MAClB,AIoBS,EAA2B,EAAgB,IJpB/B,AAAqB,QADrB,WAIvB,AAA6B,QAEb,EAAI,MAClB,AIcS,EAA2B,EAAgB,IAAe,YJf9C,AAAE,WAIzB,AAAc,MACE,EAAI,MIVlB,AAAI,EAAc,AAJX,AAAmB,EAA0B,MAA2B,MAItB,eAEnC,AAEd,AAAC,AAHG,AAUG,EAA2B,EAAgB,YAPP,eJQ9C,AAAQ,MAAG,EAAI,MAClB,EAAW,AIFE,EAA2B,EAAgB,UJCnC,AAAE,WAFJ,AAAE,WAOzB,AAAW,IACN,AAAI,MAAG,AAAa,EAAW,YAAxB,EAAK,YArED,EAAI,MAClB,AAAqB,AI6DN,EAA2B,EAAgB,OJ7DX,AI6DhC,EAA2B,EAAgB,aJ5D1D,AAAY,AI4DG,EAA2B,QJ3D1C,AAAa,AI2DE,EAA2B,QJ1DrC,AAAQ,MAAG,EAAI,MAElB,AIiEO,EAA2B,EAAgB,IAAe,AJjE/B,AADxB,AIyDG,EAA2B,EAAgB,UJxDlB,GAAR,SAAV,MAFC,AAAE,WAJJ,AAAE,0BAoBzB,AAAc,AAAqB,SACvB,EAAI,MACd,AAAY,AIwCG,EAA2B,EAAgB,SJvCrD,AAAI,MAAG,EAAI,MACd,AI+CO,EAA2B,EAAgB,QAAe,AJ/CtD,AIsCE,KJtCU,AIsCV,AAA2B,EAA3B,UJvCI,WAFF,WAOd,AAAI,MAAG,EAAI,MAIR,AAA8B,EAA9B,AAAS,AADL,AAAoB,AAAU,AI+BzB,EAA2B,EAAgB,mBJ/BhD,YACe,AAHf,AIiCK,EAA2B,aJ9B1C,AAA0C,ASoXlB,ATpX2B,EAAU,OAC7D,AIsCS,EAA2B,EAAgB,IAAe,KJ3ClD,WAyCyB,AAAE,WAI9C,EAEO,EAAK,QIpCV,AAAI,EAAc,SAA0D,eAG5E,AAAY,AADF,AAAiC,AAD7B,EAAiB,KACqB,MACb,WAHvC,AAAI,EAAc,SAA0D,eAG5E,AAAY,AADF,AAAiC,AAD7B,EAAiB,KACqB,MACb,gBK8jCvC,AAAI,AAAiB,GAAM,YACzB,AAAI,EAAK,uBACT,AAAI,EAAK,uBAOT,AAAI,EAAK,uBACT,AAAI,EAAK,uBACT,AAAI,EAAK,0BPiqBwB,AAAC,AAF3B,AAFF,AAAiB,AO1pBJ,OP4pBL,KAE4B,IAAS,IAAS,MAK7D,AAAI,AAAW,oBACc,SAAvB,AAAC,EAAM,OAEkE,AAAI,EAAJ,UAAzE,AAAmC,EAAM,GAAK,aAEU,SAAxD,AAAoC,AAAE,EAAM,QACzC,EAAI,MAgBb,AAAI,AAAC,EAAO,IAAS,IAAS,MAES,SACjC,AAAC,EAAO,IAAS,OACd,AAA8C,SAAW,SAAzD,AAA8B,EAAO,SA7IpC,AAXF,AADA,AAAa,AAbE,OAaf,YACK,AAJL,AAFA,AATK,AAAU,SASF,YAEP,AADN,AAAM,EAAN,kBAgBQ,AADN,EAAM,AADN,AAAM,EAAN,kBAHF,EAAI,AADJ,AAAK,EAAL,eAcV,AAAW,EAAK,AADP,EAAK,AADL,AAhBc,AAdE,OAcf,UAgBK,AAfL,EAAK,GAAK,IAeC,AALT,EAAO,EAAK,KAKG,AAJf,EAAK,GAAK,IAIW,AADxB,AATC,EAAI,GASE,AAAK,EAAI,UAAT,UAAc,EAAO,AAAK,EAAI,UAAT,UAAc,EAAO,AAAK,EAAI,UAAT,sBAGtC,OA6JG,AAFjB,AAJI,EAAI,AADJ,AAAiB,EAAK,UAKpB,AAHF,AAAiB,AAAiB,GAAM,UAGhC,EAAI,AAFZ,EAAK,GAAM,OArHrB,AAAI,AADK,AAAM,AADN,AAAiB,AA2HR,AAHZ,EAAM,QAvHS,IAAM,MACd,IAAS,KAWpB,EAPS,SAHL,EAAS,IAAS,UAOF,SAAmB,SAA9B,EAAM,KAFX,EAAU,OAKL,MA8BX,AAAQ,AAAU,AALZ,AAAS,AAPT,AAAiB,AADjB,AAZQ,EAAV,UAYM,eAQU,IAAW,IAKU,GAAvB,SAA+D,AAJ1E,EAAoB,MAO3B,AAAK,AAVL,AAFI,EAAI,AAFR,EAAM,YAEO,WAAY,EAAK,WAEzB,KAUI,KAGT,AAAM,AARkB,AAAU,MAQrB,GAAI,EAAM,AAAK,EAAI,UAAT,YAAe,EAAK,GAAM,AAAK,EAAI,UAAT,cACjD,AAAI,OAptCJ,AAAI,AAAE,EAAK,UAIF,AAAY,AADX,AAAiB,AADzB,EAAS,cAEkB,EAAQ,IAA5B,aAoBT,AAbI,AAAI,AADA,AADA,AAAiB,AAFzB,EAAS,gBAGO,EAAQ,OACX,YAWP,AAFC,AAAC,AAFG,AAFC,AAAS,SAAK,KAET,KAEJ,AADN,EAAM,GAAK,GAAI,AAFX,EAAQ,GAAI,EAAQ,MAGZ,KAER,YAAS,AAAiB,EAAQ,qBAElC,cAgsCX,AAAO,AAHC,AAAiB,KAGV,EAAQ,WMnuDrB,AAAW,OAKX,EADA,AADA,AADA,AADU,OACH,EAAO,MACP,EAAQ,MACR,EAAO,SAMd,AAAc,AAAI,AAJL,EAAL,IAIwB,AAAC,AAAY,aAA/B,UAAP,kBAVP,AAAW,AA3CJ,SAgDP,EADA,AADA,AADA,AADU,OACH,EAAO,MACP,EAAQ,MACR,EAAO,SAzCP,AAAe,AJgEP,AIhEiB,KJgEU,AIjE/B,AA4CE,EAAL,KA5CQ,MJiE0C,OIhEnD,AAAS,OAA+B,GAAK,AJgErC,AIhE+C,KJgEpB,EAAgB,eItDxD,AAAe,GAAK,AJsDP,AItDO,KJsDoB,EAAgB,UIrDxD,AAAI,KACF,AAAI,AAAC,AAAS,MAAc,YAC5B,AAAI,AAAC,AAAS,SACd,EAAO,EAAI,GAAI,EAAI,MACjB,AAAI,AAAC,AAAS,MAAc,YAC5B,AAAI,AAAC,AAAS,aAET,AAAS,AAAI,EAAJ,UAAQ,SAAK,GAAtB,EAAK,SAGd,AACE,AAAU,AJ0CC,AAA2B,EAAgB,KAA3C,AI1CD,SAAc,IAAa,AJ0C1B,AI1C0B,KJ0CC,AI1CO,EAAK,GJ0CI,SI1CC,AJ0C5C,AAA2B,EAA3B,AI1C4C,UAAe,AAAS,AAAO,EAAP,UAAW,QAe9F,AAAW,OAKX,EADA,AADA,AADA,AADU,OACH,EAAO,MACP,EAAQ,MACR,EAAO,SAXR,AAAe,AJkCN,AIlCgB,KJkCW,AIpCnC,AAeM,EAAL,KAfI,MJoC8C,OIlCpD,ACwXkB,QDvXH,GAAK,AJiCX,AIjCW,KJiCgB,EAAgB,qBapBvC,AADJ,AAAC,EAAgB,GAAO,GAAK,OtBoe9C,AAAI,AAAC,KAAM,GsBleX,AAAY,AtBmeL,AAAgC,EAAM,IAAS,KsBne/B,IAIlB,AAAQ,EAAS,OAAG,EAAI,KAC3B,AAAQ,IACR,EAAO,AAAC,EAAI,GAAO,AAAU,EAAU,EAAY,GAAK,OAAc,EAAK,IAAU,MAAI,EAAM,SAK/F,AAAI,AAAW,AAFJ,AAAQ,EAAa,AADxB,EAAK,KAC+B,SAE1B,AADP,AAAQ,EAAa,EAAY,mBACrB,KACrB,AACE,EAAU,EAAY,GAAK,MAC3B,AAAU,KAAwC,EAAM,OAE1D,AAAS,EAAa,EAAY,IAAe,KACjD,AAAS,EAAa,EAAY,IAAe,MAbrB,WAiB3B,AAAQ,EAAS,OAAG,EAAK,KAC5B,AAAW,AAAQ,OACnB,AAAS,EAAW,AAAQ,EAAa,EAAY,YACrD,AAAS,EAAwC,KAEjD,AAAQ,IACR,EAAO,AAAsF,EAArF,AAAI,AAAY,AAAC,AAAU,EAAU,EAAY,GAAK,OAAc,GAAW,GAA1E,EAAK,SAA8E,AAAI,QAEpG,EAAO,EAAI,KAIT,AAAI,AAAW,AAHX,AAAQ,OAGM,AAFP,AAAQ,EAAa,EAAY,mBAErB,KACrB,AACE,EAAU,EAAY,GAAK,MAC3B,AAAU,KAAwC,EAAM,OAE1D,AAAS,EAAa,EAAY,IAAe,KACjD,AAAS,EAAW,MAEtB,EAAM,SApBuB,WAwBjC,AAAO,IAEP,AAAW,AAAQ,OACnB,AAAS,EAAW,AAAQ,QAC5B,AAAS,EAAW,QAnIa,AAAI,EAAI,GAAK,AAAI,EAAI,YToKpD,AAAqB,QACrB,AAAqB,QACrB,AAAqB,oHAGvB,AJ3DW,AI2DA,AAbD,OJ9C2D,KK4hCnE,AAAwB,AD/9BC,MC+9BO,ADh+BT,AAAK,gBOrKtB,APuKuB,mDMpK7B,AAAI,EAAc,SAAuD,cAEzE,AAAY,AADC,AAAuC,EAAqB,MAC/B,IAC1C,OACA,OACA,SNiKc,EAAI,QAKd,AAFJ,EADmB,MACA,QAEG,YACR,UACP,AACO,KCqQd,AAAwB,iBDtQb,SAMX,AJ7ES,AAA2B,AI6ElB,EAAI,GJ7E8B,KAA3C,AI6EE,MJ7EwD,AI6EvC,AJtFb,AIsFa,KJtFc,EAAgB,eIyF1D,AAAI,AAAC,AJzFU,AAA2B,EAA3B,AIyFA,SAAyB,QACtC,AAAa,OACb,EAAS,AAAqB,AJ3FjB,AI2F2B,KJ3FA,AI2FO,EAAI,GJ3FK,YI6FxD,AAAe,AJ5GV,AAAmB,EAA0B,MAA2B,KI6GxE,AAAQ,MAAG,EAAI,KAClB,AJtFK,AAA2B,EAAgB,KAA3C,AIsFM,MJtFoD,AATpD,AAA2B,EAA3B,SI8Fe,YAKzB,AAAQ,MAAG,EAAI,QAClB,AO1KQ,AAAiB,EAAjB,MAA+B,KPyKV,WAI/B,AAA2B,KACtB,AAAQ,MAAG,EAAI,KAElB,AAAI,AO3LU,EP6GsB,EAApC,EAAoB,AA6EC,KAAY,UA7EjC,MACJ,AAAc,EAAU,KVvHxB,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MAMtC,AWqa0B,yDDvTN,QOhHF,WP4LZ,AAAE,QAEF,AJpGK,AIoGM,KJpGqB,AIoGS,EAAvB,AJ7GP,AI6GiB,KJ7GU,EAAgB,QASN,IAAe,KIqG/D,AOpLM,AAAiB,EAAjB,MAA+B,MP8KN,AAAE,WAU3B,OAxEM,AAwEE,KAAO,QAxEF,AAwEM,KAAO,EAAI,WJ5BxC,AAAa,AArGN,AAAmB,EAA0B,MAA2B,KAsGvE,EAAQ,KAAI,AAAI,EAAQ,KAAQ,SAAK,AAAI,EAAO,WAChD,EAAQ,KAAI,AAAI,EAAQ,KAAQ,SAAK,AAAI,EAAO,WYnJ1D,AAAa,AAHD,AAAM,EAAmB,MAGjB,AADP,AAVM,AASF,AZsJN,AAAI,EAAM,KAAO,UYtJM,KATT,SAazB,AAAa,EAAO,KACpB,AAAW,EAAO,KAClB,AAAW,EAAO,KZ6JT,AY5JT,KZ6J2B,AAXV,EAA2B,EAAgB,IAWvB,UOkNnC,AAAI,AADS,SACC,KACd,AAAW,OACX,AAAI,EAAU,KAGZ,AAAI,AAAW,AAFJ,AAAQ,OAED,AADP,AAAQ,iBACI,KACrB,AAAS,EAAM,KACf,AAAS,EAAM,SMvXd,AACD,EAAS,MACX,EAYY,EAAI,KAClB,AAAW,AAAQ,EAAa,EAAY,SAC5C,AAAQ,EAAI,OACL,EAAK,KAAZ,AAEM,AAAW,EAAG,AADP,AAAQ,EAAa,EAAY,mBACrB,KACS,SAArB,IAA2B,GAAM,IAAe,UAG7D,AAAS,EAAa,AAAQ,EAAI,GAAM,IAAe,KAT7B,YAVxB,AAAgB,EAAW,MT8F1B,AAAQ,MAAO,EAAI,KACtB,AJnCS,EAA2B,EAAgB,IAAe,AOjBpD,KAAkB,AHoDb,EAAI,GGpDyB,UHmDnB,AAAE,eA0ElC,EAAgB,AJrHC,AIqHS,KJrHkB,AIqHX,KJrH2B,UIsH5D,EAAgB,AAAC,MAAgB,UAAU,KAAY,WACvD,EAAe,ACwqCgB,AAAmB,ADxqCxB,KAAgB,YCwqCY,WAAM,MDtqC5D,EAAO,AAAqB,UACvB,AAAQ,MAAG,EAAI,QACP,KJlHyB,EAAgB,MNnGtD,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MUgNpC,AJlHS,EAA0D,SNxFrE,AWqa0B,4ED1NxB,EAAO,AAAU,AJ5HF,AI4HE,KJ5HyB,EAAgB,OI4H7B,QAChB,KJpHuB,EAAgB,MNnGtD,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MUkNlC,AJpHO,EAA0D,AI6B9D,SAhBP,AAAwB,ACgvBI,ADjvBlB,ACiUgB,IDjUI,AAAY,WAAM,gBACR,AC6jBb,GD7jBnB,sBAgB+B,wBAoFJ,AAAE,uBAuCrC,AAAU,IACV,AAAU,AAAqB,QAC/B,AAAU,AAAqB,QAC/B,AAAY,AAAqB,UACjB,EAAI,OV/PpB,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MACtC,AAAO,AAAC,IAAO,OAAc,EAAQ,MACrC,AAAO,AAAE,IAAO,OAAe,EAAQ,MACvC,AAAO,AAAC,IAAO,MAAc,EAAQ,MACrC,AAAO,AAAC,IAAO,OAAc,EAAS,MU2PpC,AJ7JS,EAA2B,EAAgB,IAAe,AI6B9D,SAhBP,AAAwB,ACgvBI,ADjvBlB,ACiUgB,IDjUI,AAAY,WAAM,gBACR,AC6jBb,GD7jBnB,sBAgB+B,oBA+Hd,WAIzB,AAAW,IACN,AAAQ,MAAG,EAAI,KACV,OAAW,OAAQ,aA3Bb,EAAI,OAClB,AAAiB,AJjJF,EAA2B,EAAgB,WImJ1D,AAAoB,AJnJL,EAA2B,AImJjB,EAAI,GJnJ6B,SIqJrD,AAAQ,AJrJE,AAA2B,EAA3B,UIqJQ,EAAI,KACzB,AAAW,EAAO,AJtJL,EAA2B,EAAgB,SIsJ1B,AJtJjB,EAA2B,AAA3B,EAA2B,MAAgB,WIqJvB,AAAE,WAGrC,AJ/IS,EAA2B,EAAgB,IAAe,KIuI5C,AAAE,WA0BK,AAAE,WAGlC,EAGO,EAAK,WZ7QZ,SACA,cADA,SACA,gCYa8B,AAAS,iBACT,AAAS,iBACT,AAAS,eAiErC,AAAS,WACT,WAGA,AAAU,SAAK,AAAS,cACxB,AJgBS,AIhBE,KJgBwD,AIhBhC,AAAC,SAAK,GAAK,cAC9C,AAAW,KJewD,YIbnE,AJaS,AIbE,KJawD,AIb3C,EAAI,aAC5B,AAAW,KJYwD,aIVnE,AJUS,AIVE,KJUwD,YITnE,AAAW,KJSwD,AIThC,eAE9B,AAAQ,OAAK,EAAK,KC81CvB,AAAyB,AD71CD,AAAS,SAAK,GAAK,AAAS,AAAO,EAAP,UAAY,QAA/C,aACf,AJKO,AILI,KJKuB,AILf,EAAI,GJK2B,IAAe,AK6vBzC,ADlwBgB,EAAK,GAAM,cACnD,AAAK,IACL,AJGO,AAA2B,EAAgB,KAA3C,AIHI,MJGsD,AIHhC,AAAO,EAAP,UAAY,QAC7C,AJEO,AAA2B,EAA3B,AIFI,MJEsD,AIFzC,EAAK,aALL","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\r\n\r\n// @ts-ignore: decorator\r\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\r\n// @ts-ignore: decorator\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n// Extra debugging\r\n\r\n// @ts-ignore: decorator\r\n@inline export const DEBUG = true;\r\n// @ts-ignore: decorator\r\n@inline export const TRACE = false;\r\n\r\n// Memory manager\r\n\r\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                           MM info                             │ -4\r\n// ╞>ptr═══════════════════════════════════════════════════════════╡\r\n// │                              ...                              │\r\n@unmanaged export class BLOCK {\r\n  /** Memory manager info. */\r\n  mmInfo: usize;\r\n}\r\n\r\n/** Overhead of a memory manager block. */\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\r\n\r\n/** Maximum size of a memory manager block's payload. */\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\r\n\r\n// Garbage collector\r\n\r\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                     Memory manager block                      │ -20\r\n// ╞═══════════════════════════════════════════════════════════════╡\r\n// │                            GC info                            │ -16\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                            GC info                            │ -12\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                            RT id                              │ -8\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                            RT size                            │ -4\r\n// ╞>ptr═══════════════════════════════════════════════════════════╡\r\n// │                              ...                              │\r\n@unmanaged export class OBJECT extends BLOCK {\r\n  /** Garbage collector info. */\r\n  gcInfo: u32;\r\n  /** Garbage collector info. */\r\n  gcInfo2: u32;\r\n  /** Runtime class id. */\r\n  rtId: u32;\r\n  /** Runtime object size. */\r\n  rtSize: u32;\r\n}\r\n\r\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\r\n// @ts-ignore: decorator\r\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\r\n\r\n/** Maximum size of a garbage collector object's payload. */\r\n// @ts-ignore: decorator\r\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\r\n\r\n/** Total of memory manager and garbage collector overhead. */\r\n// @ts-ignore: decorator\r\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\r\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\r\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\r\n\r\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\r\n// see: http://www.gii.upv.es/tlsf/\r\n\r\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\r\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴───────╨───────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_BITS: u32 = 4;\r\n// @ts-ignore: decorator\r\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const FL_BITS: u32 = 31 - SB_BITS;\r\n\r\n// [00]: < 256B (SB)  [12]: < 1M\r\n// [01]: < 512B       [13]: < 2M\r\n// [02]: < 1K         [14]: < 4M\r\n// [03]: < 2K         [15]: < 8M\r\n// [04]: < 4K         [16]: < 16M\r\n// [05]: < 8K         [17]: < 32M\r\n// [06]: < 16K        [18]: < 64M\r\n// [07]: < 32K        [19]: < 128M\r\n// [08]: < 64K        [20]: < 256M\r\n// [09]: < 128K       [21]: < 512M\r\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\r\n// [11]: < 512K\r\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\r\n\r\n// Tags stored in otherwise unused alignment bits\r\n\r\n// @ts-ignore: decorator\r\n@inline const FREE: usize = 1 << 0;\r\n// @ts-ignore: decorator\r\n@inline const LEFTFREE: usize = 1 << 1;\r\n// @ts-ignore: decorator\r\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\r\n\r\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\r\n// │                          size                             │L│F│ ◄─┐ info   overhead\r\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                             ...                               │   │ >= 0\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: back ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\r\n// F: FREE, L: LEFTFREE\r\n@unmanaged export class Block extends BLOCK {\r\n\r\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\r\n  next: Block | null;\r\n\r\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\r\n}\r\n\r\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\r\n// `next` and `back` if free.\r\n\r\n// @ts-ignore: decorator\r\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\r\n// @ts-ignore: decorator\r\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\r\n\r\n/** Gets the left block of a block. Only valid if the left block is free. */\r\n// @ts-ignore: decorator\r\n@inline function GETFREELEFT(block: Block): Block {\r\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\r\n}\r\n\r\n/** Gets the right block of a block by advancing to the right by its size. */\r\n// @ts-ignore: decorator\r\n@inline function GETRIGHT(block: Block): Block {\r\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\r\n}\r\n\r\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                           slMap[22]                           │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[367]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                             tail                              │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map\r\n@unmanaged class Root {\r\n  /** First level bitmap. */\r\n  flMap: usize;\r\n}\r\n\r\n// Root constants. Where stuff is stored inside of the root structure.\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_START: usize = sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\r\n// @ts-ignore: decorator\r\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\r\n// @ts-ignore: decorator\r\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\r\n\r\n// @ts-ignore: decorator\r\n@lazy export var ROOT: Root;\r\n\r\n/** Gets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function GETSL(root: Root, fl: usize): u32 {\r\n  return load<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Sets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\r\n  store<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    slMap,\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Gets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\r\n  return load<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Sets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\r\n  store<Block | null>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    head,\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Gets the tail block.. */\r\n// @ts-ignore: decorator\r\n@inline function GETTAIL(root: Root): Block {\r\n  return load<Block>(\r\n    changetype<usize>(root),\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Sets the tail block. */\r\n// @ts-ignore: decorator\r\n@inline function SETTAIL(root: Root, tail: Block): void {\r\n  store<Block>(\r\n    changetype<usize>(root),\r\n    tail,\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Inserts a previously used block back into the free list. */\r\nfunction insertBlock(root: Root, block: Block): void {\r\n  if (DEBUG) assert(block); // cannot be null\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n\r\n  // merge with right block if also free\r\n  if (rightInfo & FREE) {\r\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, right);\r\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\r\n      right = GETRIGHT(block);\r\n      rightInfo = right.mmInfo;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  // merge with left block if also free\r\n  if (blockInfo & LEFTFREE) {\r\n    let left = GETFREELEFT(block);\r\n    let leftInfo = left.mmInfo;\r\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\r\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, left);\r\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\r\n      block = left;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  right.mmInfo = rightInfo | LEFTFREE;\r\n  // reference to right is no longer used now, hence rightInfo is not synced\r\n\r\n  // we now know the size of the block\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\r\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\r\n\r\n  // set 'back' to itself at the end of block\r\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // perform insertion\r\n  var head = GETHEAD(root, fl, sl);\r\n  block.prev = null;\r\n  block.next = head;\r\n  if (head) head.prev = block;\r\n  SETHEAD(root, fl, sl, block);\r\n\r\n  // update first and second level maps\r\n  root.flMap |= (1 << fl);\r\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\r\n}\r\n\r\n/** Removes a free block from internal lists. */\r\nfunction removeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // link previous and next free block\r\n  var prev = block.prev;\r\n  var next = block.next;\r\n  if (prev) prev.next = next;\r\n  if (next) next.prev = prev;\r\n\r\n  // update head if we are removing it\r\n  if (block == GETHEAD(root, fl, sl)) {\r\n    SETHEAD(root, fl, sl, next);\r\n\r\n    // clear second level map if head is empty now\r\n    if (!next) {\r\n      let slMap = GETSL(root, fl);\r\n      SETSL(root, fl, slMap &= ~(1 << sl));\r\n\r\n      // clear first level map if second level is empty now\r\n      if (!slMap) root.flMap &= ~(1 << fl);\r\n    }\r\n  }\r\n  // note: does not alter left/back because it is likely that splitting\r\n  // is performed afterwards, invalidating those changes. so, the caller\r\n  // must perform those updates.\r\n}\r\n\r\n/** Searches for a free block of at least the specified size. */\r\nfunction searchBlock(root: Root, size: usize): Block | null {\r\n  // size was already asserted by caller\r\n\r\n  // mapping_search\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    const invRound = inv - SL_BITS;\r\n    let requestSize = size < halfMaxSize\r\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\r\n      : size;\r\n    fl = inv - clz<usize>(requestSize);\r\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // search second level\r\n  var slMap = GETSL(root, fl) & (~0 << sl);\r\n  var head: Block | null = null;\r\n  if (!slMap) {\r\n    // search next larger first level\r\n    let flMap = root.flMap & (~0 << (fl + 1));\r\n    if (!flMap) {\r\n      head = null;\r\n    } else {\r\n      fl = ctz<usize>(flMap);\r\n      slMap = GETSL(root, fl);\r\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\r\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n    }\r\n  } else {\r\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n  }\r\n  return head;\r\n}\r\n\r\n/** Prepares the specified block before (re-)use, possibly splitting it. */\r\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\r\n  // size was already asserted by caller\r\n\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\r\n\r\n  // split if the block can hold another MINSIZE block incl. overhead\r\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\r\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\r\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\r\n\r\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\r\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\r\n    insertBlock(root, spare); // also sets 'back'\r\n\r\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\r\n  } else {\r\n    block.mmInfo = blockInfo & ~FREE;\r\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\r\n  }\r\n}\r\n\r\n/** Adds more memory to the pool. */\r\nfunction addMemory(root: Root, start: usize, end: usize): bool {\r\n  if (DEBUG) assert(start <= end); // must be valid\r\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\r\n  end &= ~AL_MASK;\r\n\r\n  var tail = GETTAIL(root);\r\n  var tailInfo: usize = 0;\r\n  if (tail) { // more memory\r\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\r\n\r\n    // merge with current tail if adjacent\r\n    const offsetToTail = AL_SIZE;\r\n    if (start - offsetToTail == changetype<usize>(tail)) {\r\n      start -= offsetToTail;\r\n      tailInfo = tail.mmInfo;\r\n    } else {\r\n      // We don't do this, but a user might `memory.grow` manually\r\n      // leading to non-adjacent pages managed by TLSF.\r\n    }\r\n\r\n  } else if (DEBUG) { // first memory\r\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\r\n  }\r\n\r\n  // check if size is large enough for a free block and the tail block\r\n  var size = end - start;\r\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\r\n    return false;\r\n  }\r\n\r\n  // left size is total minus its own and the zero-length tail's header\r\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\r\n  var left = changetype<Block>(start);\r\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\r\n  left.prev = null;\r\n  left.next = null;\r\n\r\n  // tail is a zero-length used block\r\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\r\n  tail.mmInfo = 0 | LEFTFREE;\r\n  SETTAIL(root, tail);\r\n\r\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\r\n\r\n  return true;\r\n}\r\n\r\n/** Grows memory to fit at least another block of the specified size. */\r\nfunction growMemory(root: Root, size: usize): void {\r\n  if (ASC_LOW_MEMORY_LIMIT) {\r\n    unreachable();\r\n    return;\r\n  }\r\n  // Here, both rounding performed in searchBlock ...\r\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\r\n  if (size < halfMaxSize) { // don't round last fl\r\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\r\n    size += (1 << (invRound - clz<usize>(size))) - 1;\r\n  }\r\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\r\n  // to merge with the tail block, that's one time, otherwise it's two times.\r\n  var pagesBefore = memory.size();\r\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\r\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n  if (memory.grow(pagesWanted) < 0) {\r\n    if (memory.grow(pagesNeeded) < 0) unreachable();\r\n  }\r\n  var pagesAfter = memory.size();\r\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n}\r\n\r\n/** Computes the size (excl. header) of a block. */\r\nfunction computeSize(size: usize): usize {\r\n  // Size must be large enough and aligned minus preceeding overhead\r\n  return size <= BLOCK_MINSIZE\r\n    ? BLOCK_MINSIZE\r\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\r\n}\r\n\r\n/** Prepares and checks an allocation size. */\r\nfunction prepareSize(size: usize): usize {\r\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\r\n  return computeSize(size);\r\n}\r\n\r\n/** Initializes the root structure. */\r\nfunction initialize(): void {\r\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\r\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\r\n  var pagesBefore = memory.size();\r\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n  var root = changetype<Root>(rootOffset);\r\n  root.flMap = 0;\r\n  SETTAIL(root, changetype<Block>(0));\r\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n    SETSL(root, fl, 0);\r\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n      SETHEAD(root, fl, sl, null);\r\n    }\r\n  }\r\n  var memStart = rootOffset + ROOT_SIZE;\r\n  if (ASC_LOW_MEMORY_LIMIT) {\r\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\r\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\r\n    else unreachable(); // low memory limit already exceeded\r\n  } else {\r\n    addMemory(root, memStart, memory.size() << 16);\r\n  }\r\n  ROOT = root;\r\n}\r\n\r\n/** Allocates a block of the specified size. */\r\nexport function allocateBlock(root: Root, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var block = searchBlock(root, payloadSize);\r\n  if (!block) {\r\n    growMemory(root, payloadSize);\r\n    block = changetype<Block>(searchBlock(root, payloadSize));\r\n    if (DEBUG) assert(block); // must be found now\r\n  }\r\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\r\n  removeBlock(root, <Block>block);\r\n  prepareBlock(root, <Block>block, payloadSize);\r\n  if (isDefined(ASC_RTRACE)) onalloc(block);\r\n  return <Block>block;\r\n}\r\n\r\n/** Reallocates a block to the specified size. */\r\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var blockInfo = block.mmInfo;\r\n  var blockSize = blockInfo & ~TAGS_MASK;\r\n\r\n  // possibly split and update runtime size if it still fits\r\n  if (payloadSize <= blockSize) {\r\n    prepareBlock(root, block, payloadSize);\r\n    if (isDefined(ASC_RTRACE)) {\r\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\r\n    }\r\n    return block;\r\n  }\r\n\r\n  // merge with right free block if merger is large enough\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n  if (rightInfo & FREE) {\r\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (mergeSize >= payloadSize) {\r\n      removeBlock(root, right);\r\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\r\n      // is immediately split though. does this trigger any assertions / issues?\r\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\r\n      prepareBlock(root, block, payloadSize);\r\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\r\n      return block;\r\n    }\r\n  }\r\n\r\n  // otherwise move the block\r\n  return moveBlock(root, block, size);\r\n}\r\n\r\n/** Moves a block to a new one of the specified size. */\r\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\r\n  var newBlock = allocateBlock(root, newSize);\r\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\r\n  if (changetype<usize>(block) >= __heap_base) {\r\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\r\n    freeBlock(root, block);\r\n  }\r\n  return newBlock;\r\n}\r\n\r\n/** Frees a block. */\r\nexport function freeBlock(root: Root, block: Block): void {\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n  block.mmInfo = block.mmInfo | FREE;\r\n  insertBlock(root, block);\r\n}\r\n\r\n/** Checks that a used block is valid to be freed or reallocated. */\r\nfunction checkUsedBlock(ptr: usize): Block {\r\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\r\n  assert(\r\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\r\n    !(block.mmInfo & FREE)           // must be used\r\n  );\r\n  return block;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __alloc(size: usize): usize {\r\n  if (!ROOT) initialize();\r\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __realloc(ptr: usize, size: usize): usize {\r\n  if (!ROOT) initialize();\r\n  return (ptr < __heap_base\r\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\r\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\r\n  ) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __free(ptr: usize): void {\r\n  if (ptr < __heap_base) return;\r\n  if (!ROOT) initialize();\r\n  freeBlock(ROOT, checkUsedBlock(ptr));\r\n}\r\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, TRACE } from \"./common\";\r\nimport { onvisit, oncollect } from \"./rtrace\";\r\n\r\n// === Two-Color Mark & Sweep garbage collector ===\r\n\r\n// @ts-ignore: decorator\r\n@lazy var white = 0;\r\n// @ts-ignore: decorator\r\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\r\n// @ts-ignore: decorator\r\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\r\n// @ts-ignore: decorator\r\n@lazy var total: usize = 0;\r\n// @ts-ignore: decorator\r\n@lazy var totalMem: usize = 0;\r\n\r\nfunction initLazy(space: Object): Object {\r\n  space.nextWithColor = changetype<usize>(space);\r\n  space.prev = space;\r\n  return space;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline const COLOR_MASK = 3;\r\n\r\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                      Memory manager block                     │\r\n// ╞═══════════════════════════════════════════════════════════╤═══╡\r\n// │                              next                         │ C │ = nextWithColor\r\n// ├───────────────────────────────────────────────────────────┴───┤\r\n// │                              prev                             │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              rtId                             │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              rtSize                           │\r\n// ╞>ptr═══════════════════════════════════════════════════════════╡\r\n// │                               ...                             │\r\n// C: color\r\n\r\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\r\n@unmanaged class Object extends BLOCK {\r\n  /** Pointer to the next object with color flags stored in the alignment bits. */\r\n  nextWithColor: usize; // *u32\r\n  /** Pointer to the previous object. */\r\n  prev: Object; // *u32\r\n  /** Runtime id. */\r\n  rtId: u32;\r\n  /** Runtime size. */\r\n  rtSize: u32;\r\n\r\n  /** Gets the pointer to the next object. */\r\n  get next(): Object {\r\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\r\n  }\r\n\r\n  /** Sets the pointer to the next object. */\r\n  set next(obj: Object) {\r\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\r\n  }\r\n\r\n  /** Gets this object's color. */\r\n  get color(): i32 {\r\n    return i32(this.nextWithColor & COLOR_MASK);\r\n  }\r\n\r\n  /** Sets this object's color. */\r\n  set color(color: i32) {\r\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\r\n  }\r\n\r\n  /** Gets the size of this object in memory. */\r\n  get size(): usize {\r\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\r\n  }\r\n}\r\n\r\n/** Visits external objects. */\r\n// @ts-ignore: decorator\r\n@external(\"env\", \"visit\")\r\ndeclare function __visit_externals(cookie: u32): void;\r\n\r\n// Garbage collector interface\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __new(size: usize, id: i32): usize {\r\n  if (size >= OBJECT_MAXSIZE) throw new Error(\"allocation too large\");\r\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\r\n\r\n  // Initialize header\r\n  obj.rtId = id;\r\n  obj.rtSize = <u32>size;\r\n\r\n  // Add to fromSpace\r\n  var from = fromSpace;\r\n  var prev = from.prev;\r\n  obj.nextWithColor = changetype<usize>(from) | white;\r\n  obj.prev = prev;\r\n  prev.next = obj;\r\n  from.prev = obj;\r\n\r\n  if (TRACE) {\r\n    total += 1;\r\n    totalMem += obj.size;\r\n  }\r\n  return changetype<usize>(obj) + TOTAL_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __renew(oldPtr: usize, size: usize): usize {\r\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\r\n  if (oldPtr < __heap_base) { // move to heap for simplicity\r\n    let newPtr = __new(size, oldObj.rtId);\r\n    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\r\n    return newPtr;\r\n  }\r\n  if (size >= OBJECT_MAXSIZE) throw new Error(\"allocation too large\");\r\n  if (TRACE) totalMem -= oldObj.size;\r\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;\r\n  var newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);\r\n  newObj.rtSize = <u32>size;\r\n\r\n  // Replace with new object\r\n  newObj.next.prev = newObj;\r\n  newObj.prev.next = newObj;\r\n\r\n  if (TRACE) totalMem += newObj.size;\r\n  return newPtr;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\r\n  // nop\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __visit(ptr: usize, cookie: i32): void {\r\n  if (!ptr) return;\r\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\r\n  if (isDefined(ASC_RTRACE)) if (!onvisit(obj)) return;\r\n  if (obj.color == white) {\r\n\r\n    // Unlink from fromSpace\r\n    let next = obj.next;\r\n    if (next) { // otherwise static data\r\n      let prev = obj.prev;\r\n      next.prev = prev;\r\n      prev.next = next;\r\n    }\r\n\r\n    // Link to toSpace\r\n    let to = toSpace;\r\n    let prev = to.prev;\r\n    obj.nextWithColor = changetype<usize>(to) | i32(!white);\r\n    obj.prev = prev;\r\n    prev.next = obj;\r\n    to.prev = obj;\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __collect(): void {\r\n  if (TRACE) trace(\"GC at mem/objs\", 2, totalMem, total);\r\n\r\n  // Add roots to toSpace\r\n  __visit_globals(0);\r\n  __visit_externals(0);\r\n\r\n  // Mark everything reachable, add to toSpace\r\n  var black = i32(!white);\r\n  var to = toSpace;\r\n  var iter = to.next;\r\n  while (iter != to) {\r\n    iter.color = black;\r\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, 0);\r\n    iter = iter.next;\r\n  }\r\n\r\n  // Sweep what's left in fromSpace\r\n  var from = fromSpace;\r\n  iter = from.next;\r\n  while (iter != from) {\r\n    let newNext = iter.next;\r\n    if (changetype<usize>(iter) > __heap_base) {\r\n      if (TRACE) {\r\n        total -= 1;\r\n        totalMem -= iter.size;\r\n      }\r\n      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);\r\n      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);\r\n    }\r\n    iter = newNext;\r\n  }\r\n  from.nextWithColor = changetype<usize>(from);\r\n  from.prev = from;\r\n\r\n  // Flip spaces and colors\r\n  fromSpace = to;\r\n  toSpace = from;\r\n  white = black;\r\n\r\n  if (TRACE) trace(\"GC done at mem/objs\", 2, totalMem, total);\r\n  if (isDefined(ASC_RTRACE)) oncollect(total, totalMem);\r\n}\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\r\n// │                             count                             │\r\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\r\n// │                      Typeinfo#flags [id=0]                    │ id < count\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\r\n// │                      Typeinfo#base  [id=0]                    │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              ...                              │\r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\r\n  /** Base class id or `0` if none. */\r\n  base: u32 = 0;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `StaticArray`. */\r\n  STATICARRAY = 1 << 2,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 3,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 4,\r\n  /** Type is inherently acyclic. */\r\n  // ACYCLIC = 1 << 5,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 6,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 7,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 8,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 9,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 10,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 11,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 12,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 13,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 14,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 15,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 16,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 17,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 18,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 19,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 20,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 21,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 22,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 23\r\n}\r\n","export declare function consoleLog(msg: string): void\r\nexport declare function performanceNow(): f64\r\n\r\nexport namespace console {\r\n  // eslint-disable-next-line no-inner-declarations\r\n  export function log(msg: string): void {\r\n    consoleLog(msg)\r\n  }\r\n}\r\nexport namespace performance {\r\n  // eslint-disable-next-line no-inner-declarations\r\n  export function now(): f64 {\r\n    return performanceNow()\r\n  }\r\n}\r\n\r\nlet seed = 49734321\r\n\r\nexport function commonRandom(): i32 {\r\n  // Robert Jenkins' 32 bit integer hash function.\r\n  seed = (seed + 0x7ed55d16 + (seed << 12)) & 0xffffffff\r\n  seed = (seed ^ 0xc761c23c ^ (seed >>> 19)) & 0xffffffff\r\n  seed = (seed + 0x165667b1 + (seed << 5)) & 0xffffffff\r\n  seed = ((seed + 0xd3a2646c) ^ (seed << 9)) & 0xffffffff\r\n  seed = (seed + 0xfd7046c5 + (seed << 3)) & 0xffffffff\r\n  seed = (seed ^ 0xb55a4f09 ^ (seed >>> 16)) & 0xffffffff\r\n  return seed\r\n}\r\n\r\nexport function commonRandomJS(): f64 {\r\n  const commonRand = commonRandom()\r\n  return Math.abs(commonRand)\r\n}\r\n","import { performance, commonRandom } from './common'\r\n\r\n// classes\r\nclass Node {\r\n  constructor(public starting: i32 = 0, public numOfEdges: i32 = 0) {}\r\n}\r\n\r\nclass Edge {\r\n  constructor(public dest: f64 = 0, public weight: f64 = 0) {}\r\n}\r\n\r\nclass Graph {\r\n  constructor(\r\n    public hGraphNodes: StaticArray<Node>,\r\n    public hGraphMask: StaticArray<boolean>,\r\n    public hUpdatingGraphMask: StaticArray<boolean>,\r\n    public hGraphVisited: StaticArray<boolean>,\r\n    public hCost: StaticArray<i32>,\r\n    public hGraphEdges: StaticArray<i32>\r\n  ) {}\r\n}\r\n\r\nconst MIN_EDGES = 2\r\nconst MAX_INIT_EDGES = 4\r\nconst MIN_WEIGHT = 1\r\nconst MAX_WEIGHT = 1\r\n\r\nexport function initializeGraph(numOfNodes: i32): Graph {\r\n  const hGraphNodes = new StaticArray<Node>(numOfNodes)\r\n  const hGraphMask = new StaticArray<boolean>(numOfNodes)\r\n  const hUpdatingGraphMask = new StaticArray<boolean>(numOfNodes)\r\n  const hGraphVisited = new StaticArray<boolean>(numOfNodes)\r\n  const hCost = new StaticArray<i32>(numOfNodes)\r\n\r\n  const source = 0\r\n  const graph = new StaticArray<Array<Edge>>(numOfNodes)\r\n  for (let i = 0; i < numOfNodes; ++i) {\r\n    unchecked((graph[i] = new Array<Edge>()))\r\n  }\r\n\r\n  for (let i = 0; i < numOfNodes; ++i) {\r\n    const numOfEdges = Math.abs(commonRandom() % (MAX_INIT_EDGES - MIN_EDGES + 1)) + MIN_EDGES\r\n    const ithRow = unchecked(graph[i])\r\n\r\n    for (let j = 0; j < numOfEdges; ++j) {\r\n      const nodeId = Math.abs(commonRandom() % numOfNodes)\r\n      const weight = Math.abs(commonRandom() % (MAX_WEIGHT - MIN_WEIGHT + 1)) + MIN_WEIGHT\r\n\r\n      unchecked(ithRow.push(new Edge(nodeId, weight)))\r\n      unchecked(graph[nodeId as i32].push(new Edge(i, weight)))\r\n    }\r\n  }\r\n\r\n  let totalEdges = 0\r\n  for (let i = 0; i < numOfNodes; ++i) {\r\n    const numOfEdges = unchecked(graph[i].length)\r\n    unchecked((hGraphNodes[i] = new Node(totalEdges, numOfEdges)))\r\n    unchecked((hGraphMask[i] = false))\r\n    unchecked((hUpdatingGraphMask[i] = false))\r\n    unchecked((hGraphVisited[i] = false))\r\n    totalEdges += numOfEdges\r\n  }\r\n\r\n  unchecked((hGraphMask[source] = true))\r\n  unchecked((hGraphVisited[source] = true))\r\n\r\n  const hGraphEdges = new StaticArray<i32>(totalEdges)\r\n\r\n  let k = 0\r\n  for (let i = 0; i < numOfNodes; ++i) {\r\n    const len = unchecked(graph[i].length)\r\n    const row = unchecked(graph[i])\r\n    for (let j = 0; j < len; ++j) {\r\n      unchecked((hGraphEdges[k] = row[j].dest as i32))\r\n      k += 1\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < numOfNodes; ++i) {\r\n    unchecked((hCost[i] = -1))\r\n  }\r\n  unchecked((hCost[source] = 0))\r\n\r\n  return new Graph(hGraphNodes, hGraphMask, hUpdatingGraphMask, hGraphVisited, hCost, hGraphEdges)\r\n}\r\n\r\nexport function bfs(): f64 {\r\n  const numOfNodes = 500000\r\n  const inits = initializeGraph(numOfNodes)\r\n  const hGraphNodes = inits.hGraphNodes\r\n  const hGraphMask = inits.hGraphMask\r\n  const hUpdatingGraphMask = inits.hUpdatingGraphMask\r\n  const hGraphVisited = inits.hGraphVisited\r\n  const hCost = inits.hCost\r\n  const hGraphEdges = inits.hGraphEdges\r\n\r\n  let k = 0\r\n  let stop: boolean\r\n\r\n  const t1 = performance.now()\r\n  do {\r\n    stop = false\r\n\r\n    for (let tid = 0; tid < numOfNodes; ++tid) {\r\n      if (unchecked(hGraphMask[tid])) {\r\n        unchecked((hGraphMask[tid] = false))\r\n        const cost = unchecked(hCost[tid])\r\n        const node = unchecked(hGraphNodes[tid])\r\n        const start = node.starting\r\n        const end = node.numOfEdges + start\r\n        for (let i = start; i < end; ++i) {\r\n          const id = unchecked(hGraphEdges[i])\r\n          if (!unchecked(hGraphVisited[id])) {\r\n            unchecked((hCost[id] = cost + 1))\r\n            unchecked((hUpdatingGraphMask[id] = true))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let tid = 0; tid < numOfNodes; ++tid) {\r\n      if (unchecked(hUpdatingGraphMask[tid])) {\r\n        unchecked((hGraphMask[tid] = true))\r\n        unchecked((hGraphVisited[tid] = true))\r\n        stop = true\r\n        unchecked((hUpdatingGraphMask[tid] = false))\r\n      }\r\n    }\r\n    ++k\r\n  } while (stop)\r\n  __collect()\r\n  const t2 = performance.now()\r\n  return t2 - t1\r\n}\r\n","import { performance, commonRandom } from './common'\r\n\r\nconst dFactor: f32 = 0.85\r\n\r\n// generates an array of random pages and their links\r\nfunction randomPages(\r\n  n: i32,\r\n  nOutlinks: StaticArray<i32>,\r\n  divisor: i32\r\n): StaticArray<StaticArray<i32>> {\r\n  let k: i32\r\n  const pages = new StaticArray<StaticArray<i32>>(n) // matrix cell i,j means link from j->i\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    unchecked((pages[i] = new StaticArray<i32>(n)))\r\n  }\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    unchecked((nOutlinks[i] = 0))\r\n    const page = unchecked(pages[i])\r\n    for (let j = 0; j < n; ++j) {\r\n      if (i != j && Math.abs(commonRandom()) % divisor === 0) {\r\n        unchecked((page[j] = 1))\r\n        unchecked((nOutlinks[i] += 1))\r\n      }\r\n    }\r\n\r\n    // the case with no outlinks is afunctioned\r\n    if (nOutlinks[i] === 0) {\r\n      do {\r\n        k = (Math.abs(commonRandom()) % n) as i32\r\n      } while (k === i)\r\n\r\n      unchecked((page[k] = 1))\r\n      unchecked((nOutlinks[i] = 1))\r\n    }\r\n  }\r\n\r\n  return pages\r\n}\r\n\r\nfunction mapPageRank(\r\n  pages: StaticArray<StaticArray<i32>>,\r\n  pageRanks: StaticArray<f64>,\r\n  maps: StaticArray<StaticArray<f64>>,\r\n  nOutlinks: StaticArray<i32>,\r\n  n: i32\r\n): void {\r\n  for (let i = 0; i < n; ++i) {\r\n    const outboundRank = unchecked(pageRanks[i]) / unchecked(nOutlinks[i])\r\n    const map = unchecked(maps[i])\r\n    const page = unchecked(pages[i])\r\n    for (let j = 0; j < n; ++j) {\r\n      const p = unchecked(page[j])\r\n      unchecked((map[j] = p === 0 ? 0 : p * outboundRank))\r\n    }\r\n  }\r\n}\r\n\r\nfunction reducePageRank(\r\n  pageRanks: StaticArray<f64>,\r\n  maps: StaticArray<StaticArray<f64>>,\r\n  n: i32\r\n): f64 {\r\n  let i: i32, j: i32\r\n  let dif: f64 = 0.0\r\n  let newRank: f64, oldRank: f64\r\n\r\n  const ranks = new StaticArray<f64>(n)\r\n  for (i = 0; i < n; i++) {\r\n    const map = unchecked(maps[i])\r\n    for (j = 0; j < n; j++) {\r\n      unchecked((ranks[j] += map[j]))\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < n; i++) {\r\n    oldRank = unchecked(pageRanks[i])\r\n    newRank = unchecked(ranks[i])\r\n    newRank = (1 - dFactor) / n + dFactor * newRank\r\n    dif = Math.abs(newRank - oldRank) > dif ? Math.abs(newRank - oldRank) : dif\r\n    unchecked((pageRanks[i] = newRank))\r\n  }\r\n\r\n  return dif\r\n}\r\n\r\nexport function pagerank(): f64 {\r\n  const n: i32 = 1000\r\n  const iter: i32 = 10\r\n  const thresh: f64 = 0.00000001\r\n  const divisor: i32 = 100000\r\n  const maps = new StaticArray<StaticArray<f64>>(n)\r\n  const pageRanks = new StaticArray<f64>(n)\r\n  const nOutlinks = new StaticArray<i32>(n)\r\n  let t: i32\r\n  let maxDiff = Infinity\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    unchecked((maps[i] = new StaticArray<f64>(n)))\r\n  }\r\n\r\n  const pages = randomPages(n, nOutlinks, divisor)\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    unchecked((pageRanks[i] = 1.0 / n))\r\n  }\r\n\r\n  let nbLinks = 0\r\n  for (let i = 0; i < n; ++i) {\r\n    const page = pages[i]\r\n    for (let j = 0; j < n; ++j) {\r\n      nbLinks += unchecked(page[j])\r\n    }\r\n  }\r\n\r\n  const t1 = performance.now()\r\n  for (t = 1; t <= iter && maxDiff >= thresh; ++t) {\r\n    mapPageRank(pages, pageRanks, maps, nOutlinks, n)\r\n    maxDiff = reducePageRank(pageRanks, maps, n)\r\n  }\r\n  __collect()\r\n  const t2 = performance.now()\r\n  return t2 - t1\r\n}\r\n","/// <reference path=\"../rt/index.d.ts\" />\r\n\r\nimport { idof } from \"../builtins\";\r\nimport { CharCode } from \"./string\";\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport const MAX_DOUBLE_LENGTH = 28;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const POWERS10 = memory.data<u32>([\r\n  1,\r\n  10,\r\n  100,\r\n  1000,\r\n  10000,\r\n  100000,\r\n  1000000,\r\n  10000000,\r\n  100000000,\r\n  1000000000\r\n]);\r\n\r\n/*\r\n  Lookup table for pairwise char codes in range [0-99]\r\n\r\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\r\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\r\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\r\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\r\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\r\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\r\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\r\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\r\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\r\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\r\n*/\r\n// @ts-ignore: decorator\r\n@lazy @inline const DIGITS = memory.data<u32>([\r\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\r\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\r\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\r\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\r\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\r\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\r\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\r\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\r\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\r\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\r\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\r\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\r\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\r\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\r\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\r\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\r\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\r\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\r\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\r\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\r\n]);\r\n\r\n// Lookup table for pairwise char codes in range [0x00-0xFF]\r\n// @ts-ignore: decorator\r\n@lazy @inline const HEX_DIGITS =\r\n\"000102030405060708090a0b0c0d0e0f\\\r\n101112131415161718191a1b1c1d1e1f\\\r\n202122232425262728292a2b2c2d2e2f\\\r\n303132333435363738393a3b3c3d3e3f\\\r\n404142434445464748494a4b4c4d4e4f\\\r\n505152535455565758595a5b5c5d5e5f\\\r\n606162636465666768696a6b6c6d6e6f\\\r\n707172737475767778797a7b7c7d7e7f\\\r\n808182838485868788898a8b8c8d8e8f\\\r\n909192939495969798999a9b9c9d9e9f\\\r\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\r\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\r\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\r\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\r\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\r\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\r\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\r\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\r\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\r\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\r\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\r\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\r\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\r\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\r\n    907,   933,   960,   986,  1013,  1039,  1066\r\n/* eslint-enable indent */]);\r\n\r\n// 1e-348, 1e-340, ..., 1e340\r\n// @ts-ignore: decorator\r\n@lazy @inline const FRC_POWERS = memory.data<u64>([\r\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\r\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\r\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\r\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\r\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\r\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\r\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\r\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\r\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\r\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\r\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\r\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\r\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\r\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\r\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\r\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\r\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\r\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\r\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\r\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\r\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\r\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isPowerOf2<T extends number>(value: T): bool {\r\n  return popcnt<T>(value) == 1;\r\n}\r\n\r\n// Count number of decimals for u32 values\r\n// In our case input value always non-zero so we can simplify some parts\r\nexport function decimalCount32(value: u32): u32 {\r\n  if (value < 100000) {\r\n    if (value < 100) {\r\n      return 1 + u32(value >= 10);\r\n    } else {\r\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\r\n    }\r\n  } else {\r\n    if (value < 10000000) {\r\n      return 6 + u32(value >= 1000000);\r\n    } else {\r\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\r\n    }\r\n  }\r\n}\r\n\r\n// Count number of decimals for u64 values\r\n// In our case input value always greater than 2^32-1 so we can skip some parts\r\nexport function decimalCount64High(value: u64): u32 {\r\n  if (value < 1000000000000000) {\r\n    if (value < 1000000000000) {\r\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\r\n    } else {\r\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\r\n    }\r\n  } else {\r\n    if (value < 100000000000000000) {\r\n      return 16 + u32(value >= 10000000000000000);\r\n    } else {\r\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\r\n    }\r\n  }\r\n}\r\n\r\nfunction ulog_base(num: u64, base: i32): u32 {\r\n  if (isPowerOf2(base)) {\r\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\r\n  }\r\n  var b64 = u64(base), b = b64, e: u32 = 1;\r\n  while (num >= b) {\r\n    num /= b;\r\n    b *= b;\r\n    e <<= 1;\r\n  }\r\n  while (num >= 1) {\r\n    num /= b64;\r\n    e++;\r\n  }\r\n  return e - 1;\r\n}\r\n\r\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\r\n  while (num >= 10000) {\r\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\r\n    let t = num / 10000;\r\n    let r = num % 10000;\r\n    num = t;\r\n\r\n    let d1 = r / 100;\r\n    let d2 = r % 100;\r\n\r\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\r\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n  }\r\n\r\n  if (num >= 100) {\r\n    let t  = num / 100;\r\n    let d1 = num % 100;\r\n    num = t;\r\n    offset -= 2;\r\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\r\n    store<u32>(buffer + (offset << 1), digits);\r\n  }\r\n\r\n  if (num >= 10) {\r\n    offset -= 2;\r\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\r\n    store<u32>(buffer + (offset << 1), digits);\r\n  } else {\r\n    offset -= 1;\r\n    let digit = CharCode._0 + num;\r\n    store<u16>(buffer + (offset << 1), digit);\r\n  }\r\n}\r\n\r\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\r\n  while (num >= 100000000) {\r\n    let t = num / 100000000;\r\n    let r = <usize>(num - t * 100000000);\r\n    num = t;\r\n\r\n    let b = r / 10000;\r\n    let c = r % 10000;\r\n\r\n    let b1 = b / 100;\r\n    let b2 = b % 100;\r\n    let c1 = c / 100;\r\n    let c2 = c % 100;\r\n\r\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\r\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n\r\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\r\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\r\n\r\n    offset -= 4;\r\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\r\n  }\r\n\r\n  utoa32_dec_lut(buffer, <u32>num, offset);\r\n}\r\n\r\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\r\n  const lut = changetype<usize>(HEX_DIGITS);\r\n  while (offset >= 2) {\r\n    offset -= 2;\r\n    store<u32>(\r\n      buffer + (offset << 1),\r\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\r\n    );\r\n    num >>= 8;\r\n  }\r\n  if (offset & 1) {\r\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\r\n  }\r\n}\r\n\r\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\r\n  do {\r\n    let t = num / 10;\r\n    let r = <u32>(num % 10);\r\n    num = changetype<T>(t);\r\n    offset--;\r\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\r\n  } while (num);\r\n}\r\n\r\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\r\n  do {\r\n    let d = num & 0x0F | CharCode._0;\r\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\r\n    offset--;\r\n    store<u16>(buffer + (offset << 1), d);\r\n    // @ts-ignore: type\r\n    num >>= 4;\r\n  } while (num);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_dec_simple<u32>(buffer, num, offset);\r\n  } else {\r\n    utoa32_dec_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_hex_simple<u32>(buffer, num, offset);\r\n  } else {\r\n    utoa_hex_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_dec_simple<u64>(buffer, num, offset);\r\n  } else {\r\n    utoa64_dec_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\r\n  if (ASC_SHRINK_LEVEL >= 1) {\r\n    utoa_hex_simple<u64>(buffer, num, offset);\r\n  } else {\r\n    utoa_hex_lut(buffer, num, offset);\r\n  }\r\n}\r\n\r\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\r\n  const lut = changetype<usize>(ANY_DIGITS);\r\n  var base = u64(radix);\r\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\r\n    let shift = u64(ctz(radix) & 7);\r\n    let mask = base - 1;\r\n    do {\r\n      offset--;\r\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\r\n      num >>= shift;\r\n    } while (num);\r\n  } else {\r\n    do {\r\n      offset--;\r\n      let q = num / base;\r\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\r\n      num = q;\r\n    } while (num);\r\n  }\r\n}\r\n\r\nexport function utoa32(value: u32, radix: i32): String {\r\n  if (radix < 2 || radix > 36) {\r\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\r\n  }\r\n  if (!value) return \"0\";\r\n  var out: String;\r\n\r\n  if (radix == 10) {\r\n    let decimals = decimalCount32(value);\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\r\n  } else if (radix == 16) {\r\n    let decimals = (31 - clz(value) >> 2) + 1;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\r\n  } else {\r\n    let decimals = ulog_base(value, radix);\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function itoa32(value: i32, radix: i32): String {\r\n  if (radix < 2 || radix > 36) {\r\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\r\n  }\r\n  if (!value) return \"0\";\r\n\r\n  var sign = value >>> 31;\r\n  if (sign) value = -value;\r\n  var out: String;\r\n\r\n  if (radix == 10) {\r\n    let decimals = decimalCount32(value) + sign;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\r\n  } else if (radix == 16) {\r\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\r\n  } else {\r\n    let val32 = u32(value);\r\n    let decimals = ulog_base(val32, radix) + sign;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\r\n  }\r\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\r\n  return out;\r\n}\r\n\r\nexport function utoa64(value: u64, radix: i32): String {\r\n  if (radix < 2 || radix > 36) {\r\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\r\n  }\r\n  if (!value) return \"0\";\r\n  var out: String;\r\n\r\n  if (radix == 10) {\r\n    if (value <= u32.MAX_VALUE) {\r\n      let val32    = <u32>value;\r\n      let decimals = decimalCount32(val32);\r\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\r\n    } else {\r\n      let decimals = decimalCount64High(value);\r\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\r\n    }\r\n  } else if (radix == 16) {\r\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\r\n  } else {\r\n    let decimals = ulog_base(value, radix);\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function itoa64(value: i64, radix: i32): String {\r\n  if (radix < 2 || radix > 36) {\r\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\r\n  }\r\n  if (!value) return \"0\";\r\n\r\n  var sign = u32(value >>> 63);\r\n  if (sign) value = -value;\r\n  var out: String;\r\n\r\n  if (radix == 10) {\r\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n      let val32    = <u32>value;\r\n      let decimals = decimalCount32(val32) + sign;\r\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\r\n    } else {\r\n      let decimals = decimalCount64High(value) + sign;\r\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\r\n    }\r\n  } else if (radix == 16) {\r\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\r\n  } else {\r\n    let decimals = ulog_base(value, radix) + sign;\r\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\r\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\r\n  }\r\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\r\n  return out;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy var _K: i32 = 0;\r\n\r\n// // @ts-ignore: decorator\r\n// @lazy\r\n// var _frc: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var _exp: i32 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var _frc_minus: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var _frc_plus:  u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var _frc_pow: u64 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var _exp_pow: i32 = 0;\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umul64f(u: u64, v: u64): u64 {\r\n  var u0 = u & 0xFFFFFFFF;\r\n  var v0 = v & 0xFFFFFFFF;\r\n\r\n  var u1 = u >> 32;\r\n  var v1 = v >> 32;\r\n\r\n  var l = u0 * v0;\r\n  var t = u1 * v0 + (l >> 32);\r\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\r\n\r\n  w += 0x7FFFFFFF; // rounding\r\n\r\n  t >>= 32;\r\n  w >>= 32;\r\n\r\n  return u1 * v1 + t + w;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umul64e(e1: i32, e2: i32): i32 {\r\n  return e1 + e2 + 64; // where 64 is significand size\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction normalizedBoundaries(f: u64, e: i32): void {\r\n  var frc = (f << 1) + 1;\r\n  var exp = e - 1;\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var m = 1 + i32(f == 0x0010000000000000);\r\n\r\n  _frc_plus  = frc;\r\n  _frc_minus = ((f << m) - 1) << e - m - exp;\r\n  _exp = exp;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\r\n  var lastp = buffer + ((len - 1) << 1);\r\n  var digit = load<u16>(lastp);\r\n  while (\r\n    rest < wp_w &&\r\n    delta - rest >= ten_kappa && (\r\n      rest + ten_kappa < wp_w ||\r\n      wp_w - rest > rest + ten_kappa - wp_w\r\n    )\r\n  ) {\r\n    --digit;\r\n    rest += ten_kappa;\r\n  }\r\n  store<u16>(lastp, digit);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction getCachedPower(minExp: i32): void {\r\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\r\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\r\n  var k = <i32>dk;\r\n  k += i32(k != dk); // conversion with ceil\r\n\r\n  var index = (k >> 3) + 1;\r\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\r\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\r\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\r\n\r\n  // frexp routine\r\n  var uv  = reinterpret<u64>(value);\r\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\r\n  var sid = uv & 0x000FFFFFFFFFFFFF;\r\n  var frc = (u64(exp != 0) << 52) + sid;\r\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\r\n\r\n  normalizedBoundaries(frc, exp);\r\n  getCachedPower(_exp);\r\n\r\n  // normalize\r\n  var off = <i32>clz<u64>(frc);\r\n  frc <<= off;\r\n  exp  -= off;\r\n\r\n  var frc_pow = _frc_pow;\r\n  var exp_pow = _exp_pow;\r\n\r\n  var w_frc = umul64f(frc, frc_pow);\r\n  var w_exp = umul64e(exp, exp_pow);\r\n\r\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\r\n  var wp_exp = umul64e(_exp, exp_pow);\r\n\r\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\r\n  var delta  = wp_frc - wm_frc;\r\n\r\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\r\n}\r\n\r\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\r\n  var one_exp = -mp_exp;\r\n  var one_frc = (<u64>1) << one_exp;\r\n  var mask    = one_frc - 1;\r\n\r\n  var wp_w_frc = mp_frc - w_frc;\r\n\r\n  var p1 = u32(mp_frc >> one_exp);\r\n  var p2 = mp_frc & mask;\r\n\r\n  var kappa = <i32>decimalCount32(p1);\r\n  var len = sign;\r\n\r\n  while (kappa > 0) {\r\n    let d: u32;\r\n    switch (kappa) {\r\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\r\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\r\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\r\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\r\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\r\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\r\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\r\n      case  3: { d = p1 /        100; p1 %=        100; break; }\r\n      case  2: { d = p1 /         10; p1 %=         10; break; }\r\n      case  1: { d = p1;              p1 =           0; break; }\r\n      default: { d = 0; break; }\r\n    }\r\n\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\r\n\r\n    --kappa;\r\n    let tmp = ((<u64>p1) << one_exp) + p2;\r\n    if (tmp <= delta) {\r\n      _K += kappa;\r\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    p2    *= 10;\r\n    delta *= 10;\r\n\r\n    let d = p2 >> one_exp;\r\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\r\n\r\n    p2 &= mask;\r\n    --kappa;\r\n    if (p2 < delta) {\r\n      _K += kappa;\r\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\r\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\r\n      return len;\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction genExponent(buffer: usize, k: i32): i32 {\r\n  var sign = k < 0;\r\n  if (sign) k = -k;\r\n  var decimals = decimalCount32(k) + 1;\r\n  utoa32_dec_core(buffer, k, decimals);\r\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\r\n  return decimals;\r\n}\r\n\r\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\r\n  if (!k) {\r\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\r\n    return length + 2;\r\n  }\r\n\r\n  var kk = length + k;\r\n  if (length <= kk && kk <= 21) {\r\n    // 1234e7 -> 12340000000\r\n    for (let i = length; i < kk; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0);\r\n    }\r\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\r\n    return kk + 2;\r\n  } else if (kk > 0 && kk <= 21) {\r\n    // 1234e-2 -> 12.34\r\n    let ptr = buffer + (kk << 1);\r\n    memory.copy(\r\n      ptr + 2,\r\n      ptr,\r\n      -k << 1\r\n    );\r\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\r\n    return length + 1;\r\n  } else if (-6 < kk && kk <= 0) {\r\n    // 1234e-6 -> 0.001234\r\n    let offset = 2 - kk;\r\n    memory.copy(\r\n      buffer + (offset << 1),\r\n      buffer,\r\n      length << 1\r\n    );\r\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\r\n    for (let i = 2; i < offset; ++i) {\r\n      store<u16>(buffer + (i << 1), CharCode._0);\r\n    }\r\n    return length + offset;\r\n  } else if (length == 1) {\r\n    // 1e30\r\n    store<u16>(buffer, CharCode.e, 2);\r\n    length = genExponent(buffer + 4, kk - 1);\r\n    return length + 2;\r\n  } else {\r\n    let len = length << 1;\r\n    memory.copy(\r\n      buffer + 4,\r\n      buffer + 2,\r\n      len - 2\r\n    );\r\n    store<u16>(buffer,       CharCode.DOT, 2);\r\n    store<u16>(buffer + len, CharCode.e,   2);\r\n    length += genExponent(buffer + len + 4, kk - 1);\r\n    return length + 2;\r\n  }\r\n}\r\n\r\nfunction dtoa_core(buffer: usize, value: f64): i32 {\r\n  var sign = i32(value < 0);\r\n  if (sign) {\r\n    value = -value;\r\n    store<u16>(buffer, CharCode.MINUS);\r\n  }\r\n  // assert(value > 0 && value <= 1.7976931348623157e308);\r\n  var len = grisu2(value, buffer, sign);\r\n  len = prettify(buffer + (sign << 1), len - sign, _K);\r\n  return len + sign;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\r\n\r\nexport function dtoa(value: f64): String {\r\n  if (value == 0) return \"0.0\";\r\n  if (!isFinite(value)) {\r\n    if (isNaN(value)) return \"NaN\";\r\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\r\n  }\r\n  var size = dtoa_core(dtoa_buf, value) << 1;\r\n  var result = changetype<String>(__new(size, idof<String>()));\r\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\r\n  return result;\r\n}\r\n\r\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\r\n  var sign: u32 = 0;\r\n  if (isSigned<T>()) {\r\n    sign = u32(value < 0);\r\n    if (sign) {\r\n      value = changetype<T>(-value);\r\n      store<u16>(buffer, CharCode.MINUS);\r\n    }\r\n  }\r\n  if (ASC_SHRINK_LEVEL <= 1) {\r\n    if (isSigned<T>()) {\r\n      if (sizeof<T>() <= 4) {\r\n        if (<u32>value < 10) {\r\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\r\n          return 1 + sign;\r\n        }\r\n      } else {\r\n        if (<u64>value < 10) {\r\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\r\n          return 1 + sign;\r\n        }\r\n      }\r\n    } else {\r\n      if (value < 10) {\r\n        store<u16>(buffer, value | CharCode._0);\r\n        return 1;\r\n      }\r\n    }\r\n  }\r\n  var decimals = sign;\r\n  if (sizeof<T>() <= 4) {\r\n    decimals += decimalCount32(value);\r\n    utoa32_dec_core(buffer, value, decimals);\r\n  } else {\r\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\r\n      let val32 = <u32>value;\r\n      decimals += decimalCount32(val32);\r\n      utoa32_dec_core(buffer, val32, decimals);\r\n    } else {\r\n      decimals += decimalCount64High(value);\r\n      utoa64_dec_core(buffer, value, decimals);\r\n    }\r\n  }\r\n  return decimals;\r\n}\r\n\r\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\r\n  if (value == 0) {\r\n    store<u16>(buffer, CharCode._0);\r\n    store<u16>(buffer, CharCode.DOT, 2);\r\n    store<u16>(buffer, CharCode._0,  4);\r\n    return 3;\r\n  }\r\n  if (!isFinite(value)) {\r\n    if (isNaN(value)) {\r\n      store<u16>(buffer, CharCode.N);\r\n      store<u16>(buffer, CharCode.a, 2);\r\n      store<u16>(buffer, CharCode.N, 4);\r\n      return 3;\r\n    } else {\r\n      let sign = value < 0;\r\n      if (sign) {\r\n        store<u16>(buffer, CharCode.MINUS); // -\r\n        buffer += 2;\r\n      }\r\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\r\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\r\n      return 8 + u32(sign);\r\n    }\r\n  }\r\n  return dtoa_core(buffer, value);\r\n}\r\n","//\r\n// Lookup data for exp2f\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const EXP2F_TABLE_BITS = 5;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\r\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\r\n  // used for computing 2^(k/N) for an int |k| < 150 N as\r\n  // double(tab[k%N] + (k << 52-BITS))\r\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\r\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\r\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\r\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\r\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\r\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\r\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\r\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\r\n]);\r\n\r\n// ULP error: 0.502 (nearest rounding.)\r\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\r\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function exp2f_lut(x: f32): f32 {\r\n  const\r\n    N      = 1 << EXP2F_TABLE_BITS,\r\n    N_MASK = N - 1,\r\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\r\n    Ox127f = reinterpret<f32>(0x7F000000);\r\n\r\n  const\r\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\r\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\r\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\r\n\r\n  var xd = <f64>x;\r\n  var ix = reinterpret<u32>(x);\r\n  var ux = ix >> 20 & 0x7FF;\r\n  if (ux >= 0x430) {\r\n    // |x| >= 128 or x is nan.\r\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\r\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\r\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\r\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\r\n  }\r\n\r\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\r\n  var kd = xd + shift;\r\n  var ki = reinterpret<u64>(kd);\r\n  var r  = xd - (kd - shift);\r\n  var t: u64, y: f64, s: f64;\r\n\r\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\r\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\r\n  t += ki << (52 - EXP2F_TABLE_BITS);\r\n  s  = reinterpret<f64>(t);\r\n  y  = C2 * r + 1;\r\n  y += (C0 * r + C1) * (r  * r);\r\n  y *= s;\r\n\r\n  return <f32>y;\r\n}\r\n\r\n// ULP error: 0.502 (nearest rounding.)\r\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\r\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function expf_lut(x: f32): f32 {\r\n  const\r\n    N        = 1 << EXP2F_TABLE_BITS,\r\n    N_MASK   = N - 1,\r\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\r\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\r\n    Ox1p127f = reinterpret<f32>(0x7F000000);\r\n\r\n  const\r\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\r\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\r\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\r\n\r\n  var xd = <f64>x;\r\n  var ix = reinterpret<u32>(x);\r\n  var ux = ix >> 20 & 0x7FF;\r\n  if (ux >= 0x42B) {\r\n    // |x| >= 88 or x is nan.\r\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\r\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\r\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\r\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\r\n  }\r\n\r\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\r\n  var z = InvLn2N * xd;\r\n\r\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\r\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\r\n  // can be bigger which gives larger approximation error.\r\n  var kd = <f64>(z + shift);\r\n  var ki = reinterpret<u64>(kd);\r\n  var r  = z - (kd - shift);\r\n  var s: f64, y: f64, t: u64;\r\n\r\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\r\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\r\n  t += ki << (52 - EXP2F_TABLE_BITS);\r\n  s  = reinterpret<f64>(t);\r\n  z  = C0 * r + C1;\r\n  y  = C2 * r + 1;\r\n  y += z * (r * r);\r\n  y *= s;\r\n\r\n  return <f32>y;\r\n}\r\n\r\n//\r\n// Lookup data for log2f\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const LOG2F_TABLE_BITS = 4;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\r\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\r\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\r\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\r\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\r\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\r\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\r\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\r\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\r\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\r\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\r\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\r\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\r\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\r\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\r\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\r\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\r\n]);\r\n\r\n// ULP error: 0.752 (nearest rounding.)\r\n// Relative error: 1.9 * 2^-26 (before rounding.)\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function log2f_lut(x: f32): f32 {\r\n  const\r\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\r\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\r\n\r\n  const\r\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\r\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\r\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\r\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\r\n\r\n  var ux = reinterpret<u32>(x);\r\n  // Fix sign of zero with downward rounding when x==1.\r\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\r\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\r\n    // x < 0x1p-126 or inf or nan.\r\n    if (ux * 2 == 0) return -Infinity;\r\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\r\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\r\n    // x is subnormal, normalize it.\r\n    ux = reinterpret<u32>(x * Ox1p23f);\r\n    ux -= 23 << 23;\r\n  }\r\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\r\n  // The range is split into N subintervals.\r\n  // The ith subinterval contains z and c is near its center.\r\n  var tmp  = ux - 0x3F330000;\r\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\r\n  var top  = tmp & 0xFF800000;\r\n  var iz   = ux - top;\r\n  var k    = <i32>tmp >> 23;\r\n\r\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\r\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\r\n  var z    = <f64>reinterpret<f32>(iz);\r\n\r\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\r\n  var r  = z * invc - 1;\r\n  var y0 = logc + <f64>k;\r\n\r\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\r\n  var y  = A1 * r + A2;\r\n  var p  = A3 * r + y0;\r\n  var r2 = r * r;\r\n  y += A0 * r2;\r\n  y  = y * r2 + p;\r\n\r\n  return <f32>y;\r\n}\r\n\r\n//\r\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const LOGF_TABLE_BITS = 4;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\r\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\r\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\r\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\r\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\r\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\r\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\r\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\r\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\r\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\r\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\r\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\r\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\r\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\r\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\r\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\r\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\r\n]);\r\n\r\n// ULP error: 0.818 (nearest rounding.)\r\n// Relative error: 1.957 * 2^-26 (before rounding.)\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function logf_lut(x: f32): f32 {\r\n  const\r\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\r\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\r\n\r\n  const\r\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\r\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\r\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\r\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\r\n\r\n  var ux = reinterpret<u32>(x);\r\n  // Fix sign of zero with downward rounding when x==1.\r\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\r\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\r\n    // x < 0x1p-126 or inf or nan.\r\n    if ((ux << 1) == 0) return -Infinity;\r\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\r\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\r\n    // x is subnormal, normalize it.\r\n    ux = reinterpret<u32>(x * Ox1p23f);\r\n    ux -= 23 << 23;\r\n  }\r\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\r\n  // The range is split into N subintervals.\r\n  // The ith subinterval contains z and c is near its center.\r\n  var tmp = ux - 0x3F330000;\r\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\r\n  var k   = <i32>tmp >> 23;\r\n  var iz  = ux - (tmp & 0x1FF << 23);\r\n\r\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\r\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\r\n\r\n  var z = <f64>reinterpret<f32>(iz);\r\n\r\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\r\n  var r = z * invc - 1;\r\n  var y0 = logc + <f64>k * Ln2;\r\n\r\n  // Pipelined polynomial evaluation to approximate log1p(r).\r\n  var r2 = r * r;\r\n  var y  = A1 * r + A2;\r\n  y += A0 * r2;\r\n  y = y * r2 + (y0 + r);\r\n\r\n  return <f32>y;\r\n}\r\n\r\n//\r\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction zeroinfnanf(ux: u32): bool {\r\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\r\n}\r\n\r\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\r\n// the bit representation of a non-zero finite floating-point value.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction checkintf(iy: u32): i32 {\r\n  var e = iy >> 23 & 0xFF;\r\n  if (e < 0x7F     ) return 0;\r\n  if (e > 0x7F + 23) return 2;\r\n  e = 1 << (0x7F + 23 - e);\r\n  if (iy & (e - 1)) return 0;\r\n  if (iy &  e     ) return 1;\r\n  return 2;\r\n}\r\n\r\n// Subnormal input is normalized so ix has negative biased exponent.\r\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction log2f_inline(ux: u32): f64 {\r\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\r\n\r\n  const\r\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\r\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\r\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\r\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\r\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\r\n\r\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\r\n  // The range is split into N subintervals.\r\n  // The ith subinterval contains z and c is near its center.\r\n  var tmp  = ux - 0x3F330000;\r\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\r\n  var top  = tmp & 0xFF800000;\r\n  var uz   = ux - top;\r\n  var k    = <i32>(<i32>top >> 23);\r\n\r\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\r\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\r\n  var z    = <f64>reinterpret<f32>(uz);\r\n\r\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\r\n  var r  = z * invc - 1;\r\n  var y0 = logc + <f64>k;\r\n\r\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\r\n  var y = A0 * r + A1;\r\n  var p = A2 * r + A3;\r\n  var q = A4 * r + y0;\r\n\r\n  r *= r;\r\n  q += p * r;\r\n  y  = y * (r * r) + q;\r\n\r\n  return y;\r\n}\r\n\r\n// The output of log2 and thus the input of exp2 is either scaled by N\r\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\r\n// in [-1021,1023], sign_bias sets the sign of the result.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\r\n  const\r\n    N      = 1 << EXP2F_TABLE_BITS,\r\n    N_MASK = N - 1,\r\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\r\n\r\n  const\r\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\r\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\r\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\r\n\r\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\r\n  var kd = <f64>(xd + shift);\r\n  var ki = reinterpret<u64>(kd);\r\n  var r  = xd - (kd - shift);\r\n  var t: u64, z: f64, y: f64, s: f64;\r\n\r\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\r\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\r\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\r\n  s  = reinterpret<f64>(t);\r\n  z  = C0 * r + C1;\r\n  y  = C2 * r + 1;\r\n  y += z * (r * r);\r\n  y *= s;\r\n  return <f32>y;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction xflowf(sign: u32, y: f32): f32 {\r\n  return select<f32>(-y, y, sign) * y;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction oflowf(sign: u32): f32 {\r\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction uflowf(sign: u32): f32 {\r\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function powf_lut(x: f32, y: f32): f32 {\r\n  const\r\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\r\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\r\n    LOWER_LIMIT = -150.0,\r\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\r\n\r\n  var signBias: u32 = 0;\r\n  var ix = reinterpret<u32>(x);\r\n  var iy = reinterpret<u32>(y);\r\n  var ny = 0;\r\n\r\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\r\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\r\n    if (ny) {\r\n      if ((iy << 1) == 0) return 1.0;\r\n      if (ix == 0x3F800000) return NaN; // original: 1.0\r\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\r\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\r\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\r\n      return y * y;\r\n    }\r\n    if (zeroinfnanf(ix)) {\r\n      let x2 = x * x;\r\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\r\n      return iy >> 31 ? 1 / x2 : x2;\r\n    }\r\n    // x and y are non-zero finite.\r\n    if (ix >> 31) {\r\n      // Finite x < 0.\r\n      let yint = checkintf(iy);\r\n      if (yint == 0) return (x - x) / (x - x);\r\n      if (yint == 1) signBias = SIGN_BIAS;\r\n      ix &= 0x7FFFFFFF;\r\n    }\r\n    if (ix < 0x00800000) {\r\n      // Normalize subnormal x so exponent becomes negative.\r\n      ix = reinterpret<u32>(x * Ox1p23f);\r\n      ix &= 0x7FFFFFFF;\r\n      ix -= 23 << 23;\r\n    }\r\n  }\r\n  var logx = log2f_inline(ix);\r\n  var ylogx = y * logx; // cannot overflow, y is single prec.\r\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\r\n    // |y * log(x)| >= 126\r\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\r\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\r\n  }\r\n  return exp2f_inline(ylogx, signBias);\r\n}\r\n\r\n//\r\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const EXP_TABLE_BITS = 7;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\r\n  0x0000000000000000, 0x3FF0000000000000,\r\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\r\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\r\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\r\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\r\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\r\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\r\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\r\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\r\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\r\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\r\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\r\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\r\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\r\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\r\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\r\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\r\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\r\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\r\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\r\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\r\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\r\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\r\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\r\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\r\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\r\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\r\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\r\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\r\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\r\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\r\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\r\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\r\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\r\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\r\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\r\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\r\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\r\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\r\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\r\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\r\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\r\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\r\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\r\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\r\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\r\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\r\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\r\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\r\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\r\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\r\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\r\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\r\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\r\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\r\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\r\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\r\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\r\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\r\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\r\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\r\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\r\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\r\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\r\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\r\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\r\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\r\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\r\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\r\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\r\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\r\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\r\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\r\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\r\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\r\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\r\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\r\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\r\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\r\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\r\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\r\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\r\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\r\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\r\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\r\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\r\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\r\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\r\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\r\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\r\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\r\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\r\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\r\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\r\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\r\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\r\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\r\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\r\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\r\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\r\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\r\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\r\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\r\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\r\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\r\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\r\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\r\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\r\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\r\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\r\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\r\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\r\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\r\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\r\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\r\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\r\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\r\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\r\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\r\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\r\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\r\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\r\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\r\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\r\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\r\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\r\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\r\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\r\n]);\r\n\r\n// Handle cases that may overflow or underflow when computing the result that\r\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\r\n// scale is in SBITS, however it has a computed exponent that may have\r\n// overflown into the sign bit so that needs to be adjusted before using it as\r\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\r\n// adjustment of scale, positive k here means the result may overflow and\r\n// negative k means the result may underflow.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\r\n  const\r\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\r\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\r\n\r\n  var scale: f64;\r\n  if (!(ki & 0x80000000)) {\r\n    // k > 0, the exponent of scale might have overflowed by <= 460.\r\n    sbits -= u64(1009) << 52;\r\n    scale = reinterpret<f64>(sbits);\r\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\r\n  }\r\n  // k < 0, need special care in the subnormal range.\r\n  sbits += u64(1022) << 52;\r\n  // Note: sbits is signed scale.\r\n  scale = reinterpret<f64>(sbits);\r\n  var y = scale + scale * tmp;\r\n  if (abs(y) < 1.0) {\r\n    // Round y to the right precision before scaling it into the subnormal\r\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\r\n    // E is the worst-case ulp error outside the subnormal range.  So this\r\n    // is only useful if the goal is better than 1 ulp worst-case error.\r\n    let one = copysign(1.0, y);\r\n    let lo = scale - y + scale * tmp;\r\n    let hi = one + y;\r\n    lo = one - hi + y + lo;\r\n    y  = (hi + lo) - one;\r\n    // Fix the sign of 0.\r\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\r\n  }\r\n  return y * Ox1p_1022;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function exp_lut(x: f64): f64 {\r\n  const\r\n    N      = 1 << EXP_TABLE_BITS,\r\n    N_MASK = N - 1;\r\n\r\n  const\r\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\r\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\r\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\r\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\r\n\r\n  const\r\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\r\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\r\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\r\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\r\n\r\n  var ux = reinterpret<u64>(x);\r\n  var abstop = <u32>(ux >> 52 & 0x7FF);\r\n  if (abstop - 0x3C9 >= 0x03F) {\r\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\r\n    if (abstop >= 0x409) {\r\n      if (ux == 0xFFF0000000000000) return 0;\r\n      if (abstop >= 0x7FF) return 1.0 + x;\r\n      return select<f64>(0, Infinity, ux >> 63);\r\n    }\r\n    // Large x is special cased below.\r\n    abstop = 0;\r\n  }\r\n\r\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\r\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\r\n  var z = InvLn2N * x;\r\n  // #if TOINT_INTRINSICS\r\n  // \tkd = roundtoint(z);\r\n  // \tki = converttoint(z);\r\n  // #elif EXP_USE_TOINT_NARROW\r\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\r\n  // var kd = z + shift;\r\n  // var ki = reinterpret<u64>(kd) >> 16;\r\n  // var kd = <f64><i32>ki;\r\n  // #else\r\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\r\n  var kd = z + shift;\r\n  var ki = reinterpret<u64>(kd);\r\n  kd -= shift;\r\n  // #endif\r\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\r\n  // 2^(k/N) ~= scale * (1 + tail).\r\n  var idx = <usize>((ki & N_MASK) << 1);\r\n  var top = ki << (52 - EXP_TABLE_BITS);\r\n\r\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\r\n  // This is only a valid scale when -1023*N < k < 1024*N\r\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\r\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\r\n  // Evaluation is optimized assuming superscalar pipelined execution.\r\n  var r2 = r * r;\r\n  // Without fma the worst case error is 0.25/N ulp larger.\r\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\r\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\r\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\r\n  var scale = reinterpret<f64>(sbits);\r\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\r\n  // is no spurious underflow here even without fma.\r\n  return scale + scale * tmp;\r\n}\r\n\r\n//\r\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\r\n//\r\n\r\n// Handle cases that may overflow or underflow when computing the result that\r\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\r\n// scale is in SBITS, however it has a computed exponent that may have\r\n// overflown into the sign bit so that needs to be adjusted before using it as\r\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\r\n// adjustment of scale, positive k here means the result may overflow and\r\n// negative k means the result may underflow.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\r\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\r\n  var scale: f64;\r\n  if ((ki & 0x80000000) == 0) {\r\n    // k > 0, the exponent of scale might have overflowed by 1\r\n    sbits -= u64(1) << 52;\r\n    scale = reinterpret<f64>(sbits);\r\n    return 2 * (scale * tmp + scale);\r\n  }\r\n  // k < 0, need special care in the subnormal range\r\n  sbits += u64(1022) << 52;\r\n  scale = reinterpret<f64>(sbits);\r\n  var y = scale * tmp + scale;\r\n  if (y < 1.0) {\r\n    // Round y to the right precision before scaling it into the subnormal\r\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\r\n    // E is the worst-case ulp error outside the subnormal range. So this\r\n    // is only useful if the goal is better than 1 ulp worst-case error.\r\n    let hi: f64, lo: f64;\r\n    lo = scale - y + scale * tmp;\r\n    hi = 1.0 + y;\r\n    lo = 1.0 - hi + y + lo;\r\n    y = (hi + lo) - 1.0;\r\n  }\r\n  return y * Ox1p_1022;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function exp2_lut(x: f64): f64 {\r\n  const\r\n    N      = 1 << EXP_TABLE_BITS,\r\n    N_MASK = N - 1,\r\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\r\n\r\n  const\r\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\r\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\r\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\r\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\r\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\r\n\r\n  var ux = reinterpret<u64>(x);\r\n  var abstop = <u32>(ux >> 52 & 0x7ff);\r\n  if (abstop - 0x3C9 >= 0x03F) {\r\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\r\n    if (abstop >= 0x409) {\r\n      if (ux == 0xFFF0000000000000) return 0;\r\n      if (abstop >= 0x7FF) return 1.0 + x;\r\n      if (!(ux >> 63)) return Infinity;\r\n      else if (ux >= 0xC090CC0000000000) return 0;\r\n    }\r\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\r\n  }\r\n\r\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\r\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\r\n  var kd = x + shift;\r\n  var ki = reinterpret<u64>(kd);\r\n  kd -= shift; // k/N for int k\r\n  var r = x - kd;\r\n  // 2^(k/N) ~= scale * (1 + tail)\r\n  var idx = <usize>((ki & N_MASK) << 1);\r\n  var top = ki << (52 - EXP_TABLE_BITS);\r\n\r\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\r\n  // This is only a valid scale when -1023*N < k < 1024*N\r\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\r\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\r\n  // Evaluation is optimized assuming superscalar pipelined execution\r\n  var r2 = r * r;\r\n  // Without fma the worst case error is 0.5/N ulp larger.\r\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\r\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\r\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\r\n  var scale = reinterpret<f64>(sbits);\r\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\r\n  // is no spurious underflow here even without fma.\r\n  return scale * tmp + scale;\r\n}\r\n\r\n//\r\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const LOG2_TABLE_BITS = 6;\r\n\r\n/* Algorithm:\r\n\r\n  x = 2^k z\r\n  log2(x) = k + log2(c) + log2(z/c)\r\n  log2(z/c) = poly(z/c - 1)\r\n\r\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\r\ninto the ith one, then table entries are computed as\r\n\r\n  tab[i].invc = 1/c\r\n  tab[i].logc = (double)log2(c)\r\n  tab2[i].chi = (double)c\r\n  tab2[i].clo = (double)(c - (double)c)\r\n\r\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\r\nfloating point invc candidates around 1/center and selecting one for which\r\n\r\n  1) the rounding error in 0x1.8p10 + logc is 0,\r\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\r\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\r\n\r\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\r\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\r\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\r\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\r\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\r\n  //            invc                  ,                logc\r\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\r\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\r\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\r\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\r\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\r\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\r\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\r\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\r\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\r\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\r\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\r\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\r\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\r\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\r\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\r\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\r\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\r\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\r\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\r\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\r\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\r\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\r\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\r\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\r\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\r\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\r\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\r\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\r\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\r\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\r\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\r\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\r\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\r\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\r\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\r\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\r\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\r\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\r\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\r\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\r\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\r\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\r\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\r\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\r\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\r\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\r\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\r\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\r\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\r\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\r\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\r\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\r\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\r\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\r\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\r\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\r\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\r\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\r\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\r\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\r\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\r\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\r\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\r\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\r\n  //              chi                 ,                 clo\r\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\r\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\r\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\r\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\r\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\r\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\r\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\r\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\r\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\r\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\r\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\r\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\r\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\r\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\r\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\r\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\r\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\r\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\r\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\r\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\r\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\r\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\r\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\r\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\r\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\r\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\r\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\r\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\r\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\r\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\r\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\r\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\r\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\r\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\r\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\r\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\r\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\r\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\r\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\r\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\r\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\r\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\r\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\r\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\r\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\r\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\r\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\r\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\r\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\r\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\r\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\r\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\r\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\r\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\r\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\r\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\r\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\r\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\r\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\r\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\r\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\r\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\r\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\r\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function log2_lut(x: f64): f64 {\r\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\r\n\r\n  const\r\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\r\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\r\n\r\n  const\r\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\r\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\r\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\r\n\r\n  const\r\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\r\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\r\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\r\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\r\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\r\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\r\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\r\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\r\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\r\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\r\n\r\n  const\r\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\r\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\r\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\r\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\r\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\r\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\r\n\r\n  var ix = reinterpret<u64>(x);\r\n  if (ix - LO < HI - LO) {\r\n    let r = x - 1.0;\r\n    // #if __FP_FAST_FMA\r\n    //     hi = r * InvLn2hi;\r\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\r\n    // #else\r\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\r\n    let rlo = r - rhi;\r\n    let hi  = rhi * InvLn2hi;\r\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\r\n    // #endif\r\n    let r2 = r * r; // rounding error: 0x1p-62\r\n    let r4 = r2 * r2;\r\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\r\n    let p = r2 * (B0 + r * B1);\r\n    let y = hi + p;\r\n    lo += hi - y + p;\r\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\r\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\r\n    return y + lo;\r\n  }\r\n  var top = <u32>(ix >> 48);\r\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\r\n    // x < 0x1p-1022 or inf or nan.\r\n    if ((ix << 1) == 0) return -1.0 / (x * x);\r\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\r\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\r\n    // x is subnormal, normalize it.\r\n    ix = reinterpret<u64>(x * Ox1p52);\r\n    ix -= u64(52) << 52;\r\n  }\r\n\r\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\r\n  // The range is split into N subintervals.\r\n  // The ith subinterval contains z and c is near its center.\r\n  var tmp  = ix - 0x3FE6000000000000;\r\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\r\n  var k    = <i64>tmp >> 52;\r\n  var iz   = ix - (tmp & 0xFFF0000000000000);\r\n\r\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\r\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\r\n  var z    = reinterpret<f64>(iz);\r\n  var kd   = <f64>k;\r\n\r\n  // log2(x) = log2(z/c) + log2(c) + k.\r\n  // r ~= z/c - 1, |r| < 1/(2*N).\r\n  // #if __FP_FAST_FMA\r\n  // \t// rounding error: 0x1p-55/N.\r\n  // \tr = __builtin_fma(z, invc, -1.0);\r\n  // \tt1 = r * InvLn2hi;\r\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\r\n  // #else\r\n  // rounding error: 0x1p-55/N + 0x1p-65.\r\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\r\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\r\n\r\n  var r   = (z - chi - clo) * invc;\r\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\r\n  var rlo = r - rhi;\r\n  var t1  = rhi * InvLn2hi;\r\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\r\n  // #endif\r\n\r\n  // hi + lo = r/ln2 + log2(c) + k\r\n  var t3 = kd + logc;\r\n  var hi = t3 + t1;\r\n  var lo = t3 - hi + t1 + t2;\r\n\r\n  // log2(r+1) = r/ln2 + r^2*poly(r)\r\n  // Evaluation is optimized assuming superscalar pipelined execution\r\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\r\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\r\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\r\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\r\n  return lo + r2 * p + hi;\r\n}\r\n\r\n//\r\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const LOG_TABLE_BITS = 7;\r\n\r\n/* Algorithm:\r\n\r\n  x = 2^k z\r\n  log(x) = k ln2 + log(c) + log(z/c)\r\n  log(z/c) = poly(z/c - 1)\r\n\r\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\r\ninto the ith one, then table entries are computed as\r\n\r\n  tab[i].invc = 1/c\r\n  tab[i].logc = (double)log(c)\r\n  tab2[i].chi = (double)c\r\n  tab2[i].clo = (double)(c - (double)c)\r\n\r\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\r\nfloating point invc candidates around 1/center and selecting one for which\r\n\r\n  1) the rounding error in 0x1.8p9 + logc is 0,\r\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\r\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\r\n\r\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\r\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\r\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\r\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\r\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\r\n  //              invc                ,                 logc\r\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\r\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\r\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\r\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\r\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\r\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\r\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\r\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\r\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\r\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\r\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\r\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\r\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\r\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\r\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\r\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\r\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\r\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\r\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\r\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\r\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\r\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\r\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\r\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\r\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\r\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\r\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\r\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\r\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\r\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\r\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\r\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\r\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\r\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\r\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\r\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\r\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\r\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\r\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\r\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\r\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\r\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\r\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\r\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\r\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\r\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\r\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\r\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\r\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\r\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\r\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\r\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\r\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\r\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\r\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\r\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\r\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\r\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\r\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\r\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\r\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\r\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\r\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\r\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\r\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\r\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\r\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\r\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\r\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\r\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\r\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\r\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\r\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\r\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\r\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\r\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\r\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\r\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\r\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\r\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\r\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\r\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\r\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\r\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\r\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\r\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\r\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\r\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\r\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\r\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\r\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\r\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\r\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\r\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\r\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\r\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\r\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\r\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\r\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\r\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\r\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\r\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\r\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\r\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\r\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\r\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\r\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\r\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\r\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\r\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\r\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\r\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\r\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\r\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\r\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\r\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\r\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\r\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\r\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\r\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\r\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\r\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\r\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\r\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\r\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\r\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\r\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\r\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\r\n  //               chi                ,                  clo\r\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\r\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\r\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\r\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\r\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\r\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\r\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\r\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\r\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\r\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\r\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\r\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\r\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\r\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\r\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\r\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\r\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\r\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\r\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\r\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\r\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\r\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\r\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\r\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\r\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\r\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\r\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\r\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\r\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\r\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\r\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\r\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\r\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\r\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\r\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\r\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\r\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\r\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\r\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\r\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\r\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\r\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\r\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\r\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\r\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\r\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\r\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\r\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\r\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\r\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\r\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\r\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\r\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\r\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\r\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\r\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\r\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\r\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\r\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\r\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\r\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\r\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\r\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\r\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\r\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\r\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\r\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\r\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\r\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\r\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\r\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\r\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\r\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\r\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\r\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\r\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\r\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\r\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\r\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\r\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\r\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\r\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\r\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\r\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\r\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\r\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\r\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\r\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\r\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\r\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\r\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\r\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\r\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\r\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\r\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\r\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\r\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\r\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\r\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\r\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\r\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\r\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\r\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\r\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\r\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\r\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\r\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\r\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\r\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\r\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\r\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\r\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\r\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\r\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\r\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\r\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\r\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\r\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\r\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\r\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\r\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\r\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\r\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\r\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\r\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\r\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\r\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\r\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function log_lut(x: f64): f64 {\r\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\r\n\r\n  const\r\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\r\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\r\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\r\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\r\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\r\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\r\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\r\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\r\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\r\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\r\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\r\n\r\n  const\r\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\r\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\r\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\r\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\r\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\r\n\r\n  const\r\n    LO: u64 = 0x3FEE000000000000,\r\n    HI: u64 = 0x3FF1090000000000;\r\n\r\n  const\r\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\r\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\r\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\r\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\r\n\r\n  var ix = reinterpret<u64>(x);\r\n  if (ix - LO < HI - LO) {\r\n    let r  = x - 1.0;\r\n    let r2 = r * r;\r\n    let r3 = r2 * r;\r\n    let y =\r\n      r3 * (B1 + r * B2 + r2 * B3 +\r\n      r3 * (B4 + r * B5 + r2 * B6 +\r\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\r\n    // Worst-case error is around 0.507 ULP\r\n    let w   = r * Ox1p27;\r\n    let rhi = r + w - w;\r\n    let rlo = r - rhi;\r\n    w = rhi * rhi * B0; // B[0] == -0.5\r\n    let hi = r + w;\r\n    let lo = r - hi + w;\r\n    lo += B0 * rlo * (rhi + r);\r\n    return y + lo + hi;\r\n  }\r\n  var top = u32(ix >> 48);\r\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\r\n    // x < 0x1p-1022 or inf or nan\r\n    if ((ix << 1) == 0) return -1.0 / (x * x);\r\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\r\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\r\n    // x is subnormal, normalize it\r\n    ix = reinterpret<u64>(x * Ox1p52);\r\n    ix -= u64(52) << 52;\r\n  }\r\n\r\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\r\n  // The range is split into N subintervals.\r\n  // The ith subinterval contains z and c is near its center.\r\n  var tmp  = ix - 0x3FE6000000000000;\r\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\r\n  var k    = <i64>tmp >> 52;\r\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\r\n\r\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\r\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\r\n  var z    = reinterpret<f64>(iz);\r\n\r\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\r\n  // r ~= z/c - 1, |r| < 1/(2*N)\r\n  // #if __FP_FAST_FMA\r\n  // \t// rounding error: 0x1p-55/N\r\n  // \tr = __builtin_fma(z, invc, -1.0);\r\n  // #else\r\n  // rounding error: 0x1p-55/N + 0x1p-66\r\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\r\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\r\n  var r = (z - chi - clo) * invc;\r\n  // #endif\r\n  var kd = <f64>k;\r\n\r\n  // hi + lo = r + log(c) + k*Ln2\r\n  var w  = kd * Ln2hi + logc;\r\n  var hi = w + r;\r\n  var lo = w - hi + r + kd * Ln2lo;\r\n\r\n  // log(x) = lo + (log1p(r) - r) + hi\r\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\r\n  // Worst case error if |y| > 0x1p-5:\r\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\r\n  // Worst case error if |y| > 0x1p-4:\r\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\r\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\r\n}\r\n\r\n//\r\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\r\n//\r\n\r\n// @ts-ignore: decorator\r\n@inline const POW_LOG_TABLE_BITS = 7;\r\n\r\n/* Algorithm:\r\n\r\n  x = 2^k z\r\n  log(x) = k ln2 + log(c) + log(z/c)\r\n  log(z/c) = poly(z/c - 1)\r\n\r\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\r\nand z falls into the ith one, then table entries are computed as\r\n\r\n  tab[i].invc = 1/c\r\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\r\n  tab[i].logctail = (double)(log(c) - logc)\r\n\r\nwhere c is chosen near the center of the subinterval such that 1/c has only a\r\nfew precision bits so z/c - 1 is exactly representible as double:\r\n\r\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\r\n\r\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\r\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\r\nerror and the interval for z is selected such that near x == 1, where log(x)\r\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\r\n  //             invc                 ,pad,               logc                 ,               logctail\r\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\r\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\r\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\r\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\r\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\r\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\r\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\r\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\r\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\r\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\r\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\r\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\r\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\r\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\r\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\r\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\r\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\r\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\r\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\r\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\r\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\r\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\r\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\r\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\r\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\r\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\r\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\r\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\r\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\r\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\r\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\r\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\r\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\r\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\r\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\r\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\r\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\r\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\r\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\r\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\r\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\r\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\r\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\r\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\r\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\r\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\r\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\r\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\r\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\r\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\r\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\r\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\r\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\r\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\r\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\r\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\r\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\r\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\r\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\r\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\r\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\r\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\r\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\r\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\r\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\r\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\r\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\r\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\r\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\r\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\r\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\r\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\r\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\r\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\r\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\r\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\r\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\r\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\r\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\r\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\r\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\r\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\r\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\r\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\r\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\r\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\r\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\r\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\r\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\r\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\r\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\r\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\r\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\r\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\r\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\r\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\r\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\r\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\r\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\r\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\r\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\r\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\r\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\r\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\r\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\r\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\r\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\r\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\r\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\r\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\r\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\r\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\r\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\r\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\r\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\r\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\r\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\r\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\r\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\r\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\r\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\r\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\r\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\r\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\r\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\r\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\r\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\r\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\r\n]);\r\n\r\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\r\n// the bit representation of a non-zero finite floating-point value.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction checkint(iy: u64): i32 {\r\n  var e = iy >> 52 & 0x7FF;\r\n  if (e < 0x3FF     ) return 0;\r\n  if (e > 0x3FF + 52) return 2;\r\n  e = u64(1) << (0x3FF + 52 - e);\r\n  if (iy & (e - 1)) return 0;\r\n  if (iy &  e     ) return 1;\r\n  return 2;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction xflow(sign: u32, y: f64): f64 {\r\n  return select(-y, y, sign) * y;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction uflow(sign: u32): f64 {\r\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction oflow(sign: u32): f64 {\r\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\r\n}\r\n\r\n// Returns 1 if input is the bit representation of 0, infinity or nan.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction zeroinfnan(u: u64): bool {\r\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy var log_tail: f64 = 0;\r\n\r\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\r\n// additional 15 bits precision. IX is the bit representation of x, but\r\n// normalized in the subnormal range using the sign bit for the exponent.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction log_inline(ix: u64): f64 {\r\n  const N = 1 << POW_LOG_TABLE_BITS;\r\n  const N_MASK = N - 1;\r\n\r\n  const\r\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\r\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\r\n\r\n  const\r\n    A0 = reinterpret<f64>(0xBFE0000000000000),\r\n    A1 = reinterpret<f64>(0xBFE5555555555560),\r\n    A2 = reinterpret<f64>(0x3FE0000000000006),\r\n    A3 = reinterpret<f64>(0x3FE999999959554E),\r\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\r\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\r\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\r\n\r\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\r\n  // The range is split into N subintervals.\r\n  // The ith subinterval contains z and c is near its center.\r\n  var tmp = ix - 0x3fE6955500000000;\r\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\r\n  var k   = <i64>tmp >> 52;\r\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\r\n  var z   = reinterpret<f64>(iz);\r\n  var kd  = <f64>k;\r\n\r\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\r\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\r\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\r\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\r\n\r\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\r\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\r\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\r\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\r\n  var zlo = z - zhi;\r\n  var rhi = zhi * invc - 1.0;\r\n  var rlo = zlo * invc;\r\n  var r   = rhi + rlo;\r\n\r\n  // k * Ln2 + log(c) + r.\r\n  var t1  = kd * Ln2hi + logc;\r\n  var t2  = t1 + r;\r\n  var lo1 = kd * Ln2lo + logctail;\r\n  var lo2 = t1 - t2 + r;\r\n\r\n  // Evaluation is optimized assuming superscalar pipelined execution.\r\n  var ar  = A0 * r; // A[0] = -0.5\r\n  var ar2 = r * ar;\r\n  var ar3 = r * ar2;\r\n  // k * Ln2 + log(c) + r + A[0] * r * r.\r\n  var arhi  = A0  * rhi;\r\n  var arhi2 = rhi * arhi;\r\n  var hi    = t2  + arhi2;\r\n  var lo3   = rlo * (ar + arhi);\r\n  var lo4   = t2 - hi + arhi2;\r\n\r\n  // p = log1p(r) - r - A[0] * r * r.\r\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\r\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\r\n  var y  = hi + lo;\r\n  log_tail = hi - y + lo;\r\n\r\n  return y;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\r\n\r\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\r\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\r\n  const N      = 1 << EXP_TABLE_BITS;\r\n  const N_MASK = N - 1;\r\n\r\n  const\r\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\r\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\r\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\r\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\r\n\r\n  const\r\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\r\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\r\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\r\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\r\n\r\n  var abstop: u32;\r\n  var ki: u64, top: u64, sbits: u64;\r\n  var idx: usize;\r\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\r\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\r\n\r\n  var ux = reinterpret<u64>(x);\r\n  abstop = <u32>(ux >> 52) & 0x7FF;\r\n  if (abstop - 0x3C9 >= 0x03F) {\r\n    if (abstop - 0x3C9 >= 0x80000000) {\r\n      // Avoid spurious underflow for tiny x.\r\n      // Note: 0 is common input.\r\n      return select(-1.0, 1.0, sign_bias);\r\n    }\r\n    if (abstop >= 0x409) { // top12(1024.0)\r\n      // Note: inf and nan are already handled.\r\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\r\n    }\r\n    // Large x is special cased below.\r\n    abstop = 0;\r\n  }\r\n\r\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\r\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\r\n  z = InvLn2N * x;\r\n\r\n  // #if TOINT_INTRINSICS\r\n  //   kd = roundtoint(z);\r\n  //   ki = converttoint(z);\r\n  // #elif EXP_USE_TOINT_NARROW\r\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\r\n  //   kd = eval_as_double(z + shift);\r\n  //   ki = asuint64(kd) >> 16;\r\n  //   kd = (double_t)(int32_t)ki;\r\n  // #else\r\n  // z - kd is in [-1, 1] in non-nearest rounding modes\r\n  kd  = z + shift;\r\n  ki  = reinterpret<u64>(kd);\r\n  kd -= shift;\r\n  // #endif\r\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\r\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\r\n  r += xtail;\r\n  // 2^(k/N) ~= scale * (1 + tail)\r\n  idx = <usize>((ki & N_MASK) << 1);\r\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\r\n\r\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\r\n  // This is only a valid scale when -1023*N < k < 1024*N\r\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\r\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\r\n  // Evaluation is optimized assuming superscalar pipelined execution.\r\n  r2 = r * r;\r\n  // Without fma the worst case error is 0.25/N ulp larger.\r\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\r\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\r\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\r\n  scale = reinterpret<f64>(sbits);\r\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\r\n  // is no spurious underflow here even without fma.\r\n  return scale + scale * tmp;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function pow_lut(x: f64, y: f64): f64 {\r\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\r\n\r\n  var sign_bias: u32 = 0;\r\n  var ix = reinterpret<u64>(x);\r\n  var iy = reinterpret<u64>(y);\r\n  var topx = ix >> 52;\r\n  var topy = iy >> 52;\r\n\r\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\r\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\r\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\r\n    // Special cases: (x < 0x1p-126 or inf or nan) or\r\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\r\n    if (zeroinfnan(iy)) {\r\n      if ((iy << 1) == 0) return 1.0;\r\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\r\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\r\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\r\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\r\n      return y * y;\r\n    }\r\n    if (zeroinfnan(ix)) {\r\n      let x2 = x * x;\r\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\r\n      return iy >> 63 ? 1 / x2 : x2;\r\n    }\r\n    // Here x and y are non-zero finite\r\n    if (ix >> 63) {\r\n      // Finite x < 0\r\n      let yint = checkint(iy);\r\n      if (yint == 0) return (x - x) / (x - x);\r\n      if (yint == 1) sign_bias = SIGN_BIAS;\r\n      ix   &= 0x7FFFFFFFFFFFFFFF;\r\n      topx &= 0x7FF;\r\n    }\r\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\r\n      // Note: sign_bias == 0 here because y is not odd.\r\n      if (ix == 0x3FF0000000000000) return 1;\r\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\r\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\r\n    }\r\n    if (topx == 0) {\r\n      // Normalize subnormal x so exponent becomes negative.\r\n      ix = reinterpret<u64>(x * Ox1p52);\r\n      ix &= 0x7FFFFFFFFFFFFFFF;\r\n      ix -= u64(52) << 52;\r\n    }\r\n  }\r\n\r\n  var hi = log_inline(ix);\r\n  var lo = log_tail;\r\n  var ehi: f64, elo: f64;\r\n  // #if __FP_FAST_FMA\r\n  //   ehi = y * hi;\r\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\r\n  // #else\r\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\r\n  var ylo = y - yhi;\r\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\r\n  var llo = hi - lhi + lo;\r\n  ehi = yhi * lhi;\r\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\r\n  // #endif\r\n  return exp_inline(ehi, elo, sign_bias);\r\n}\r\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\r\nimport { ipow32 } from \"../math\";\r\n\r\n// All tables are stored as two staged lookup tables (static tries)\r\n// because the full range of Unicode symbols can't be efficiently\r\n// represented as-is in memory (see Unicode spec ch 5, p.196):\r\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\r\n// Tables have been generated using these forked musl tools:\r\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\r\n\r\n// Lookup table to check if a character is alphanumeric or not\r\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\r\n// size: 3904 bytes\r\n// @ts-ignore\r\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\r\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\r\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\r\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\r\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\r\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\r\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\r\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\r\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\r\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\r\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\r\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\r\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\r\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\r\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\r\n  16,16,125,16,16,16,\r\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\r\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\r\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\r\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\r\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\r\n  31,254,225,255,\r\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\r\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\r\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\r\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\r\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\r\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\r\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\r\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\r\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\r\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\r\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\r\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\r\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\r\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\r\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\r\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\r\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\r\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\r\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\r\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\r\n  63,\r\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\r\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\r\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\r\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\r\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\r\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\r\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\r\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\r\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\r\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\r\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\r\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\r\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\r\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,\r\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\r\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\r\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\r\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\r\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\r\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\r\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\r\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\r\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\r\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\r\n  255,\r\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\r\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\r\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\r\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\r\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\r\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\r\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\r\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\r\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\r\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\r\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\r\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\r\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\r\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\r\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\r\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\r\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\r\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\r\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\r\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\r\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\r\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\r\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\r\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\r\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\r\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\r\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\r\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\r\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\r\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,\r\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\r\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\r\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\r\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\r\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\r\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\r\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\r\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\r\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\r\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\r\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\r\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\r\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\r\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\r\n]);\r\n\r\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\r\n// @ts-ignore: decorator\r\n@lazy @inline const CASED = memory.data<u8>([\r\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\r\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\r\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\r\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\r\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\r\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\r\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\r\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\r\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\r\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\r\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\r\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\r\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\r\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\r\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\r\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\r\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\r\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\r\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\r\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\r\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\r\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\r\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\r\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0\r\n]);\r\n\r\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\r\n// @ts-ignore: decorator\r\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\r\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\r\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\r\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\r\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\r\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\r\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\r\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\r\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\r\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\r\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\r\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\r\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\r\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\r\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\r\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\r\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\r\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\r\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\r\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\r\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\r\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\r\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\r\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\r\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\r\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\r\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\r\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\r\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\r\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\r\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\r\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\r\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\r\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\r\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\r\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\r\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\r\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\r\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\r\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\r\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\r\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\r\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\r\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\r\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\r\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\r\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\r\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\r\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\r\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\r\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\r\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n  0,0,0,0,0,0,0,248\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const LOWER127 = memory.data<u8>([\r\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\r\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\r\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\r\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\r\n  64,\r\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\r\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\r\n  91,92,93,94,95,96,\r\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\r\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\r\n  123,124,125,126,127\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const UPPER127 = memory.data<u8>([\r\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\r\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\r\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\r\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\r\n  64,\r\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\r\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\r\n  91,92,93,94,95,96,\r\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\r\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\r\n  123,124,125,126,127\r\n]);\r\n\r\n// 23 * 8 = 184 bytes\r\n// @ts-ignore: decorator\r\n@lazy @inline const POWERS10 = memory.data<f64>([\r\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\r\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\r\n  1e20, 1e21, 1e22\r\n]);\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  I = 0x49,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5A,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isAscii(c: u32): bool {\r\n  return !(c >> 7);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isLower8(c: u32): bool {\r\n  return c - CharCode.a < 26;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isUpper8(c: u32): bool {\r\n  return c - CharCode.A < 26;\r\n}\r\n\r\nexport function isSpace(c: u32): bool {\r\n  if (c < 0x1680) { // < <LS> (1)\r\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\r\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\r\n    // @ts-ignore: cast\r\n    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);\r\n  }\r\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\r\n  switch (c) {\r\n    case 0x1680: // <LS> (1)\r\n    case 0x2028: // <LS> (2)\r\n    case 0x2029: // <PS>\r\n    case 0x202F: // <NNS>\r\n    case 0x205F: // <MMSP>\r\n    case 0x3000: // <IS>\r\n    case 0xFEFF: return true; // <ZWNBSP>\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function isAlpha(c: u32): bool {\r\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\r\n  if (c < 0x20000) {\r\n    // @ts-ignore: cast\r\n    return stagedBinaryLookup(ALPHA_TABLE, c);\r\n  }\r\n  return c < 0x2FFFE;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isCased(c: u32): bool {\r\n  // @ts-ignore: cast\r\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isCaseIgnorable(c: u32): bool {\r\n  // @ts-ignore: cast\r\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\r\n  const lookaheadLimit = 30; // max lookahead limit\r\n  var found = false;\r\n  var pos = index;\r\n  var minPos = max(0, pos - lookaheadLimit);\r\n  while (pos > minPos) {\r\n    let c = codePointBefore(buffer, pos);\r\n    if (!isCaseIgnorable(c)) {\r\n      if (isCased(c)) {\r\n        found = true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n    pos -= isize(c >= 0x10000) + 1;\r\n  }\r\n  if (!found) return false;\r\n  pos = index + 1;\r\n  var maxPos = min(pos + lookaheadLimit, len);\r\n  while (pos < maxPos) {\r\n    let c = <u32>load<u16>(buffer + (pos << 1));\r\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\r\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\r\n      if ((c1 & 0xFC00) == 0xDC00) {\r\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\r\n      }\r\n    }\r\n    if (!isCaseIgnorable(c)) {\r\n      return !isCased(c);\r\n    }\r\n    pos += isize(c >= 0x10000) + 1;\r\n  }\r\n  return true;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction codePointBefore(buffer: usize, index: isize): i32 {\r\n  if (index <= 0) return -1;\r\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\r\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\r\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\r\n    if ((c1 & 0xFC00) == 0xD800) {\r\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\r\n    }\r\n  }\r\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\r\n}\r\n\r\n// Search routine for two-staged lookup tables\r\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\r\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\r\n}\r\n\r\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\r\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\r\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\r\n      do {\r\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\r\n        ptr1 += 8;\r\n        ptr2 += 8;\r\n        len  -= 4;\r\n      } while (len >= 4);\r\n    }\r\n  }\r\n  while (len--) {\r\n    let a = <i32>load<u16>(ptr1);\r\n    let b = <i32>load<u16>(ptr2);\r\n    if (a != b) return a - b;\r\n    ptr1 += 2;\r\n    ptr2 += 2;\r\n  }\r\n  return 0;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function toLower8(c: u32): u32 {\r\n  if (ASC_SHRINK_LEVEL > 0) {\r\n    return c | u32(isUpper8(c)) << 5;\r\n  } else {\r\n    return <u32>load<u8>(LOWER127 + c);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function toUpper8(c: u32): u32 {\r\n  if (ASC_SHRINK_LEVEL > 0) {\r\n    return c & ~(u32(isLower8(c)) << 5);\r\n  } else {\r\n    return <u32>load<u8>(UPPER127 + c);\r\n  }\r\n}\r\n\r\n/** Parses a string to an integer (usually), using the specified radix. */\r\nexport function strtol<T>(str: string, radix: i32 = 0): T {\r\n  var len = str.length;\r\n  if (!len) {\r\n    if (isFloat<T>()) {\r\n      // @ts-ignore: cast\r\n      return <T>NaN;\r\n    } else {\r\n      // @ts-ignore: cast\r\n      return <T>0;\r\n    }\r\n  }\r\n\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <u32>load<u16>(ptr);\r\n\r\n  // trim white spaces\r\n  while (isSpace(code)) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  // determine sign\r\n  // @ts-ignore\r\n  var sign: T = 1;\r\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\r\n    if (!--len) {\r\n      if (isFloat<T>()) {\r\n        // @ts-ignore: cast\r\n        return <T>NaN;\r\n      } else {\r\n        // @ts-ignore: cast\r\n        return <T>0;\r\n      }\r\n    }\r\n    if (code == CharCode.MINUS) {\r\n      // @ts-ignore: type\r\n      sign = -1;\r\n    }\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\r\n  if (radix) {\r\n    if (radix < 2 || radix > 36) {\r\n      if (isFloat<T>()) {\r\n        // @ts-ignore: cast\r\n        return <T>NaN;\r\n      } else {\r\n        // @ts-ignore: cast\r\n        return <T>0;\r\n      }\r\n    }\r\n    // handle case as parseInt(\"0xFF\", 16) by spec\r\n    if (radix == 16) {\r\n      if (\r\n        len > 2 &&\r\n        code == CharCode._0 &&\r\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\r\n      ) {\r\n        ptr += 4; len -= 2;\r\n      }\r\n    }\r\n  } else {\r\n    // determine radix by literal prefix\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<u32>load<u16>(ptr, 2) | 32) {\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (!radix) radix = 10;\r\n  }\r\n\r\n  // calculate value\r\n  // @ts-ignore: type\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <u32>load<u16>(ptr);\r\n    if (code - CharCode._0 < 10) {\r\n      code -= CharCode._0;\r\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\r\n      code -= CharCode.a - 10;\r\n    }\r\n    if (code >= <u32>radix) {\r\n      if (!num) {\r\n        if (isFloat<T>()) {\r\n          // @ts-ignore: cast\r\n          return <T>NaN;\r\n        } else {\r\n          // @ts-ignore: cast\r\n          return <T>0;\r\n        }\r\n      }\r\n      break;\r\n    }\r\n    // @ts-ignore: type\r\n    num = num * radix + code;\r\n    ptr += 2;\r\n  }\r\n  // @ts-ignore: type\r\n  return sign * num;\r\n}\r\n\r\nexport function strtod(str: string): f64 {\r\n  var len = str.length;\r\n  if (!len) return NaN;\r\n\r\n  var ptr  = changetype<usize>(str);\r\n  var code = <u32>load<u16>(ptr);\r\n\r\n  var sign = 1.0;\r\n  // skip white spaces\r\n  while (len && isSpace(code)) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (!len) return NaN;\r\n\r\n  // try parse '-' or '+'\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return NaN;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return NaN;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  // try parse Infinity\r\n  if (len >= 8 && code == CharCode.I) {\r\n    if (\r\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\r\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\r\n    ) {\r\n      return Infinity * sign;\r\n    }\r\n    return NaN;\r\n  }\r\n  // validate next symbol\r\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\r\n    return NaN;\r\n  }\r\n  var savedPtr = ptr;\r\n  // skip zeros\r\n  while (code == CharCode._0) {\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  if (len <= 0) return 0;\r\n  const capacity = 19; // int(64 * 0.3010)\r\n  var pointed = false;\r\n  var consumed = 0;\r\n  var position = 0;\r\n  var x: u64 = 0;\r\n  if (code == CharCode.DOT) {\r\n    let noDigits = !(savedPtr - ptr);\r\n    ptr += 2; --len;\r\n    if (!len && noDigits) return NaN;\r\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\r\n    if (len <= 0) return 0;\r\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\r\n  }\r\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\r\n    if (digit < 10) {\r\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\r\n      ++consumed;\r\n    } else {\r\n      position = consumed;\r\n      pointed = true;\r\n    }\r\n    if (!--len) break;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n\r\n  if (!pointed) position = consumed;\r\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\r\n}\r\n\r\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\r\n\r\n  var sepLen = separator.length;\r\n  var valueLen = 5; // max possible length of element len(\"false\")\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\r\n  var offset = 0;\r\n  var value: bool;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<bool>(dataStart + i);\r\n    valueLen = 4 + i32(!value);\r\n    memory.copy(\r\n      changetype<usize>(result) + (<usize>offset << 1),\r\n      changetype<usize>(select(\"true\", \"false\", value)),\r\n      <usize>valueLen << 1\r\n    );\r\n    offset += valueLen;\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<bool>(dataStart + <usize>lastIndex);\r\n  valueLen = 4 + i32(!value);\r\n  memory.copy(\r\n    changetype<usize>(result) + (<usize>offset << 1),\r\n    changetype<usize>(select(\"true\", \"false\", value)),\r\n    valueLen << 1\r\n  );\r\n  offset += valueLen;\r\n\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    let value = load<T>(dataStart);\r\n    if (isSigned<T>()) {\r\n      if (sizeof<T>() <= 4) {\r\n        // @ts-ignore: type\r\n        return changetype<string>(itoa32(<i32>value, 10));\r\n      } else {\r\n        // @ts-ignore: type\r\n        return changetype<string>(itoa64(<i32>value, 10));\r\n      }\r\n    } else {\r\n      if (sizeof<T>() <= 4) {\r\n        // @ts-ignore: type\r\n        return changetype<string>(utoa32(<u32>value, 10));\r\n      } else {\r\n        // @ts-ignore: type\r\n        return changetype<string>(utoa64(<u64>value, 10));\r\n      }\r\n    }\r\n  }\r\n\r\n  var sepLen = separator.length;\r\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\r\n  var offset = 0;\r\n  var value: T;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    return changetype<string>(dtoa(\r\n      // @ts-ignore: type\r\n      load<T>(dataStart))\r\n    );\r\n  }\r\n\r\n  const valueLen = MAX_DOUBLE_LENGTH;\r\n  var sepLen = separator.length;\r\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\r\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\r\n  var offset = 0;\r\n  var value: T;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\r\n  if (estLen > offset) return result.substring(0, offset);\r\n  return result;\r\n}\r\n\r\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  if (!lastIndex) {\r\n    // @ts-ignore: type\r\n    return load<string>(dataStart) || \"\";\r\n  }\r\n  var estLen = 0;\r\n  var value: string;\r\n  for (let i = 0; i < length; ++i) {\r\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\r\n    // @ts-ignore: type\r\n    if (value !== null) estLen += value.length;\r\n  }\r\n  var offset = 0;\r\n  var sepLen = separator.length;\r\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\r\n    if (value !== null) {\r\n      let valueLen = value.length;\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(value),\r\n        <usize>valueLen << 1\r\n      );\r\n      offset += valueLen;\r\n    }\r\n    if (sepLen) {\r\n      memory.copy(\r\n        changetype<usize>(result) + (<usize>offset << 1),\r\n        changetype<usize>(separator),\r\n        <usize>sepLen << 1\r\n      );\r\n      offset += sepLen;\r\n    }\r\n  }\r\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\r\n  if (value !== null) {\r\n    memory.copy(\r\n      changetype<usize>(result) + (<usize>offset << 1),\r\n      changetype<usize>(value),\r\n      <usize>value.length << 1\r\n    );\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\r\n  var lastIndex = length - 1;\r\n  if (lastIndex < 0) return \"\";\r\n  var value: T;\r\n  if (!lastIndex) {\r\n    value = load<T>(dataStart);\r\n    // @ts-ignore: type\r\n    return value !== null ? value.toString() : \"\";\r\n  }\r\n  var result = \"\";\r\n  var sepLen = separator.length;\r\n  for (let i = 0; i < lastIndex; ++i) {\r\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    // @ts-ignore: type\r\n    if (value !== null) result += value.toString();\r\n    if (sepLen) result += separator;\r\n  }\r\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\r\n  // @ts-ignore: type\r\n  if (value !== null) result += value.toString();\r\n  return result;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scientific(significand: u64, exp: i32): f64 {\r\n  if (!significand || exp < -342) return 0;\r\n  if (exp > 308) return Infinity;\r\n  // Try use fast path\r\n  // Use fast path for string-to-double conversion if possible\r\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\r\n  // Simple integer\r\n  var significandf = <f64>significand;\r\n  if (!exp) return significandf;\r\n  if (exp > 22 && exp <= 22 + 15) {\r\n    significandf *= pow10(exp - 22);\r\n    exp = 22;\r\n  }\r\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\r\n    if (exp > 0) return significandf * pow10(exp);\r\n    return significandf / pow10(-exp);\r\n  } else if (exp < 0) {\r\n    return scaledown(significand, exp);\r\n  } else {\r\n    return scaleup(significand, exp);\r\n  }\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scaledown(significand: u64, exp: i32): f64 {\r\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\r\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\r\n\r\n  var shift = clz(significand);\r\n  significand <<= shift;\r\n  shift = exp - shift;\r\n\r\n  for (; exp <= -14; exp += 14) {\r\n    let q = significand / denom;\r\n    let r = significand % denom;\r\n    let s = clz(q);\r\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\r\n    shift -= s;\r\n  }\r\n  var b = <u64>ipow32(5, -exp);\r\n  var q = significand / b;\r\n  var r = significand % b;\r\n  var s = clz(q);\r\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\r\n  shift -= s;\r\n\r\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction scaleup(significand: u64, exp: i32): f64 {\r\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\r\n  var shift = ctz(significand);\r\n  significand >>= shift;\r\n  shift += exp;\r\n\r\n  __fixmulShift = shift;\r\n  for (; exp >= 13; exp -= 13) {\r\n    significand = fixmul(significand, coeff);\r\n  }\r\n  significand = fixmul(significand, <u32>ipow32(5, exp));\r\n  shift = __fixmulShift;\r\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\r\n}\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction parseExp(ptr: usize, len: i32): i32 {\r\n  var sign = 1, magnitude = 0;\r\n  var code = <u32>load<u16>(ptr);\r\n  // check code is 'e' or 'E'\r\n  if ((code | 32) != CharCode.e) return 0;\r\n\r\n  if (!--len) return 0;\r\n  code = <u32>load<u16>(ptr += 2);\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n  // skip zeros\r\n  while (code == CharCode._0) {\r\n    if (!--len) return 0;\r\n    code = <u32>load<u16>(ptr += 2);\r\n  }\r\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\r\n    if (magnitude >= 3200) return sign * 3200;\r\n    magnitude = 10 * magnitude + digit;\r\n    code = <u32>load<u16>(ptr += 2);\r\n    --len;\r\n  }\r\n  return sign * magnitude;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy var __fixmulShift: u64 = 0;\r\n\r\n// Adopted from metallic lib:\r\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction fixmul(a: u64, b: u32): u64 {\r\n  var low  = (a & 0xFFFFFFFF) * b;\r\n  var high = (a >> 32) * b + (low >> 32);\r\n  var overflow = <u32>(high >> 32);\r\n  var space = clz(overflow);\r\n  var revspace: u64 = 32 - space;\r\n  __fixmulShift += revspace;\r\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction pow10(n: i32): f64 {\r\n  // argument `n` should bounds in [0, 22] range\r\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\r\nimport { idof } from \"./builtins\";\r\nimport { Array } from \"./array\";\r\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\r\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\r\n\r\n@final\r\nexport class StaticArray<T> {\r\n  [key: number]: T;\r\n\r\n  // Note that the interface of StaticArray instances must be a semantically\r\n  // compatible subset of Array<T> in order for syntax highlighting to work\r\n  // properly, for instance when creating static arrays from array literals.\r\n  // The additionally provided static methods take care of dealing with static\r\n  // arrays exclusively, without having to convert to Array<T> first.\r\n\r\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\r\n    var length = source.length;\r\n    var outSize = <usize>length << alignof<T>();\r\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\r\n    if (isManaged<T>()) {\r\n      let sourcePtr = source.dataStart;\r\n      for (let i = 0; i < length; ++i) {\r\n        let off = <usize>i << alignof<T>();\r\n        let ref = load<usize>(sourcePtr + off);\r\n        store<usize>(changetype<usize>(out) + off, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n    } else {\r\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\r\n    }\r\n    return out;\r\n  }\r\n\r\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\r\n    var sourceLen = source.length;\r\n    var otherLen = select(0, other.length, other === null);\r\n    var outLen = sourceLen + otherLen;\r\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\r\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\r\n    var outStart = changetype<usize>(out);\r\n    var sourceSize = <usize>sourceLen << alignof<T>();\r\n    if (isManaged<T>()) {\r\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(changetype<usize>(source) + offset);\r\n        store<usize>(outStart + offset, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n      outStart += sourceSize;\r\n      let otherSize = <usize>otherLen << alignof<T>();\r\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(changetype<usize>(other) + offset);\r\n        store<usize>(outStart + offset, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n    } else {\r\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\r\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\r\n    }\r\n    return out;\r\n  }\r\n\r\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\r\n    var length = source.length;\r\n    start = start < 0 ? max(start + length, 0) : min(start, length);\r\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\r\n    length = max(end - start, 0);\r\n    var sliceSize = <usize>length << alignof<T>();\r\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\r\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\r\n    if (isManaged<T>()) {\r\n      let off: usize = 0;\r\n      while (off < sliceSize) {\r\n        let ref = load<usize>(sourcePtr + off);\r\n        store<usize>(changetype<usize>(slice) + off, ref);\r\n        __link(changetype<usize>(slice), ref, true);\r\n        off += sizeof<usize>();\r\n      }\r\n    } else {\r\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\r\n    }\r\n    return slice;\r\n  }\r\n\r\n  constructor(length: i32) {\r\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\r\n    var outSize = <usize>length << alignof<T>();\r\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\r\n    memory.fill(changetype<usize>(out), 0, outSize);\r\n    return out;\r\n  }\r\n\r\n  get length(): i32 {\r\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\r\n  }\r\n\r\n  @operator(\"[]\") private __get(index: i32): T {\r\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    var value = this.__uget(index);\r\n    if (isReference<T>()) {\r\n      if (!isNullable<T>()) {\r\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n\r\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\r\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\r\n  }\r\n\r\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\r\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    this.__uset(index, value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\r\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\r\n    if (isManaged<T>()) {\r\n      __link(changetype<usize>(this), changetype<usize>(value), true);\r\n    }\r\n  }\r\n\r\n  includes(value: T, fromIndex: i32 = 0): bool {\r\n    if (isFloat<T>()) {\r\n      let length = this.length;\r\n      if (length == 0 || fromIndex >= length) return false;\r\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n      while (fromIndex < length) {\r\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\r\n        // @ts-ignore\r\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\r\n        ++fromIndex;\r\n      }\r\n      return false;\r\n    } else {\r\n      return this.indexOf(value, fromIndex) >= 0;\r\n    }\r\n  }\r\n\r\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\r\n    var length = this.length;\r\n    if (length == 0 || fromIndex >= length) return -1;\r\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n    while (fromIndex < length) {\r\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\r\n    var length = this.length;\r\n    if (length == 0) return -1;\r\n    if (fromIndex < 0) fromIndex = length + fromIndex;\r\n    else if (fromIndex >= length) fromIndex = length - 1;\r\n    while (fromIndex >= 0) {\r\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  concat(other: Array<T>): Array<T> {\r\n    var thisLen = this.length;\r\n    var otherLen = select(0, other.length, other === null);\r\n    var outLen = thisLen + otherLen;\r\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\r\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\r\n    var outStart = out.dataStart;\r\n    var thisSize = <usize>thisLen << alignof<T>();\r\n    if (isManaged<T>()) {\r\n      let thisStart = changetype<usize>(this);\r\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(thisStart + offset);\r\n        store<usize>(outStart + offset, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n      outStart += thisSize;\r\n      let otherStart = other.dataStart;\r\n      let otherSize = <usize>otherLen << alignof<T>();\r\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(otherStart + offset);\r\n        store<usize>(outStart + offset, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n    } else {\r\n      memory.copy(outStart, changetype<usize>(this), thisSize);\r\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\r\n    }\r\n    return out;\r\n  }\r\n\r\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length = this.length;\r\n    start = start < 0 ? max(start + length, 0) : min(start, length);\r\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\r\n    length = max(end - start, 0);\r\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\r\n    var sliceBase = slice.dataStart;\r\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\r\n    if (isManaged<T>()) {\r\n      let off = <usize>0;\r\n      let end = <usize>length << alignof<usize>();\r\n      while (off < end) {\r\n        let ref = load<usize>(thisBase + off);\r\n        store<usize>(sliceBase + off, ref);\r\n        __link(changetype<usize>(slice), ref, true);\r\n        off += sizeof<usize>();\r\n      }\r\n    } else {\r\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\r\n    }\r\n    return slice;\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\r\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\r\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\r\n    }\r\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\r\n    ERROR(\"unspported element type\");\r\n    return <string>unreachable();\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  // RT integration\r\n\r\n  @unsafe private __visit(cookie: u32): void {\r\n    if (isManaged<T>()) {\r\n      let cur = changetype<usize>(this);\r\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\r\n      while (cur < end) {\r\n        let val = load<usize>(cur);\r\n        if (val) __visit(val, cookie);\r\n        cur += sizeof<usize>();\r\n      }\r\n    }\r\n  }\r\n}\r\n","// Common error messages for use accross the standard library. Keeping error messages compact\r\n// and reusing them where possible ensures minimal static data in binaries.\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_EMPTYARRAY: string = \"Array is empty\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline\r\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\r\n","import { memcmp, memmove, memset } from \"./util/memory\";\r\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\r\n\r\n/** Memory manager interface. */\r\nexport namespace memory {\r\n\r\n  /** Gets the size of the memory in pages. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function size(): i32;\r\n\r\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export declare function grow(pages: i32): i32;\r\n\r\n  /** Fills a section in memory with the specified byte value. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function fill(dst: usize, c: u8, n: usize): void {\r\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Copies a section of memory to another. Has move semantics. */\r\n  // @ts-ignore: decorator\r\n  @unsafe @builtin\r\n  export function copy(dst: usize, src: usize, n: usize): void {\r\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\r\n  }\r\n\r\n  /** Initializes a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Drops a memory segment. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function drop(segmentIndex: u32): void {\r\n    throw new Error(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  /** Repeats a section of memory at a specific address. */\r\n  // @ts-ignore: decorator\r\n  @unsafe\r\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\r\n    var index: usize = 0;\r\n    var total = srcLength * count;\r\n    while (index < total) {\r\n      memory.copy(dst + index, src, srcLength);\r\n      index += srcLength;\r\n    }\r\n  }\r\n\r\n  /** Compares a section of memory to another. */\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\r\n    return memcmp(vl, vr, n);\r\n  }\r\n\r\n  /** Gets a pointer to a static chunk of memory of the given size. */\r\n  // @ts-ignore: decorator\r\n  @builtin\r\n  export declare function data<T>(size: T, align?: i32): usize;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare const __heap_base: usize;\r\n\r\n/** Heap memory interface. */\r\nexport namespace heap {\r\n\r\n  /** Allocates a chunk of memory of at least the specified size. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function alloc(size: usize): usize {\r\n    return __alloc(size);\r\n  }\r\n\r\n  /** Reallocates a chunk of memory to have at least the specified size. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\r\n    return __realloc(ptr, size);\r\n  }\r\n\r\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub/none runtime. */\r\n  // @ts-ignore: decorator\r\n  @unsafe export function free(ptr: usize): void {\r\n    __free(ptr);\r\n  }\r\n}\r\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (<u32>dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\r\n  if (dest === src) return;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (src - dest - n <= -(n << 1)) {\r\n      memcpy(dest, src, n);\r\n      return;\r\n    }\r\n  }\r\n  if (dest < src) {\r\n    if (ASC_SHRINK_LEVEL < 2) {\r\n      if ((src & 7) == (dest & 7)) {\r\n        while (dest & 7) {\r\n          if (!n) return;\r\n          --n;\r\n          store<u8>(dest++, load<u8>(src++));\r\n        }\r\n        while (n >= 8) {\r\n          store<u64>(dest, load<u64>(src));\r\n          n    -= 8;\r\n          dest += 8;\r\n          src  += 8;\r\n        }\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if (ASC_SHRINK_LEVEL < 2) {\r\n      if ((src & 7) == (dest & 7)) {\r\n        while ((dest + n) & 7) {\r\n          if (!n) return;\r\n          store<u8>(dest + --n, load<u8>(src + n));\r\n        }\r\n        while (n >= 8) {\r\n          n -= 8;\r\n          store<u64>(dest + n, load<u64>(src + n));\r\n        }\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\r\n  if (ASC_SHRINK_LEVEL > 1) {\r\n    while (n) {\r\n      store<u8>(dest++, c);\r\n      --n;\r\n    }\r\n  } else {\r\n    // fill head and tail with minimal branching\r\n    if (!n) return;\r\n    let dend = dest + n - 4;\r\n    store<u8>(dest, c);\r\n    store<u8>(dend, c, 3);\r\n    if (n <= 2) return;\r\n    store<u8>(dest, c, 1);\r\n    store<u8>(dest, c, 2);\r\n    store<u8>(dend, c, 2);\r\n    store<u8>(dend, c, 1);\r\n    if (n <= 6) return;\r\n    store<u8>(dest, c, 3);\r\n    store<u8>(dend, c);\r\n    if (n <= 8) return;\r\n\r\n    // advance pointer to align it at 4-byte boundary\r\n    let k: usize = -dest & 3;\r\n    dest += k;\r\n    n -= k;\r\n    n &= -4;\r\n\r\n    let c32: u32 = <u32>-1 / 255 * c;\r\n\r\n    // fill head/tail up to 28 bytes each in preparation\r\n    dend = dest + n - 28;\r\n    store<u32>(dest, c32);\r\n    store<u32>(dend, c32, 24);\r\n    if (n <= 8) return;\r\n    store<u32>(dest, c32, 4);\r\n    store<u32>(dest, c32, 8);\r\n    store<u32>(dend, c32, 16);\r\n    store<u32>(dend, c32, 20);\r\n    if (n <= 24) return;\r\n    store<u32>(dest, c32, 12);\r\n    store<u32>(dest, c32, 16);\r\n    store<u32>(dest, c32, 20);\r\n    store<u32>(dest, c32, 24);\r\n    store<u32>(dend, c32);\r\n    store<u32>(dend, c32, 4);\r\n    store<u32>(dend, c32, 8);\r\n    store<u32>(dend, c32, 12);\r\n\r\n    // align to a multiple of 8\r\n    k = 24 + (dest & 4);\r\n    dest += k;\r\n    n -= k;\r\n\r\n    // copy 32 bytes each\r\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n    while (n >= 32) {\r\n      store<u64>(dest, c64);\r\n      store<u64>(dest, c64, 8);\r\n      store<u64>(dest, c64, 16);\r\n      store<u64>(dest, c64, 24);\r\n      n -= 32;\r\n      dest += 32;\r\n    }\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\r\n  if (vl == vr) return 0;\r\n  if (ASC_SHRINK_LEVEL < 2) {\r\n    if ((vl & 7) == (vr & 7)) {\r\n      while (vl & 7) {\r\n        if (!n) return 0;\r\n        let a = <i32>load<u8>(vl);\r\n        let b = <i32>load<u8>(vr);\r\n        if (a != b) return a - b;\r\n        n--; vl++; vr++;\r\n      }\r\n      while (n >= 8) {\r\n        if (load<u64>(vl) != load<u64>(vr)) break;\r\n        vl += 8;\r\n        vr += 8;\r\n        n  -= 8;\r\n      }\r\n    }\r\n  }\r\n  while (n--) {\r\n    let a = <i32>load<u8>(vl);\r\n    let b = <i32>load<u8>(vr);\r\n    if (a != b) return a - b;\r\n    vl++; vr++;\r\n  }\r\n  return 0;\r\n}\r\n","import { performance, commonRandomJS } from './common'\r\n\r\n// classes\r\nclass Csr {\r\n  constructor(\r\n    public numRows: i32,\r\n    public numCols: i32,\r\n    public densityPerc: f64,\r\n    public densityPpm: f64,\r\n    public nzPerRow: f64,\r\n    public numNonZeros: i32,\r\n    public stdev: f64,\r\n    public aRow: StaticArray<u32>,\r\n    public aCol: StaticArray<u32>,\r\n    public ax: StaticArray<f32>\r\n  ) {}\r\n}\r\n\r\nconst newArray = function (dim: i32): StaticArray<f64> {\r\n  const xs = new StaticArray<f64>(dim)\r\n  for (let i = 0; i < dim; ++i) {\r\n    unchecked((xs[i] = 0))\r\n  }\r\n  return xs\r\n}\r\n\r\n/* Ziggurat code taken from james bloomer's implementation that can be\r\n * found at  https://github.com/jamesbloomer/node-ziggurat\r\n */\r\nclass Ziggurat {\r\n  public jsr: i32 = 123456789\r\n  public wn: StaticArray<f64> = newArray(128)\r\n  public fn: StaticArray<f64> = newArray(128)\r\n  public kn: StaticArray<f64> = newArray(128)\r\n\r\n  constructor() {\r\n    this.zigset()\r\n  }\r\n\r\n  public nextGaussian(): f64 {\r\n    return this.RNOR()\r\n  }\r\n\r\n  RNOR(): f64 {\r\n    const hz = this.SHR3()\r\n    const iz = hz & 127\r\n    return Math.abs(hz) < unchecked(this.kn[iz]) ? hz * unchecked(this.wn[iz]) : this.nfix(hz, iz)\r\n  }\r\n\r\n  nfix(hz: i32, iz: i32): f64 {\r\n    const r: f64 = 3.442619855899\r\n    const r1: f64 = 1.0 / r\r\n    let x: f64\r\n    let y: f64\r\n    // eslint-disable-next-line no-constant-condition\r\n    while (true) {\r\n      unchecked((x = hz * this.wn[iz]))\r\n      if (iz === 0) {\r\n        x = -Math.log(this.UNI()) * r1\r\n        y = -Math.log(this.UNI())\r\n        while (y + y < x * x) {\r\n          x = -Math.log(this.UNI()) * r1\r\n          y = -Math.log(this.UNI())\r\n        }\r\n        return hz > 0 ? r + x : -r - x\r\n      }\r\n\r\n      if (\r\n        unchecked(this.fn[iz] + this.UNI() * this.fn[iz - 1] - this.fn[iz]) < Math.exp(-0.5 * x * x)\r\n      ) {\r\n        return x\r\n      }\r\n\r\n      hz = this.SHR3()\r\n      iz = hz & 127\r\n\r\n      if (Math.abs(hz) < unchecked(this.kn[iz])) {\r\n        return unchecked(hz * this.wn[iz])\r\n      }\r\n    }\r\n  }\r\n\r\n  SHR3(): i32 {\r\n    const jz = this.jsr\r\n    let jzr = this.jsr\r\n    jzr ^= jzr << 13\r\n    jzr ^= jzr >>> 17\r\n    jzr ^= jzr << 5\r\n    this.jsr = jzr\r\n    return (jz + jzr) | 0\r\n  }\r\n\r\n  UNI(): f64 {\r\n    return 0.5 * (1 + this.SHR3() / -Math.pow(2, 31))\r\n  }\r\n\r\n  zigset(): void {\r\n    const m1 = 2147483648.0\r\n    let dn = 3.442619855899\r\n    let tn = dn\r\n    const vn = 9.91256303526217e-3\r\n\r\n    const q = vn / Math.exp(-0.5 * dn * dn)\r\n    unchecked((this.kn[0] = Math.floor((dn / q) * m1)))\r\n    unchecked((this.kn[1] = 0))\r\n\r\n    unchecked((this.wn[0] = q / m1))\r\n    unchecked((this.wn[127] = dn / m1))\r\n\r\n    unchecked((this.fn[0] = 1.0))\r\n    unchecked((this.fn[127] = Math.exp(-0.5 * dn * dn)))\r\n\r\n    for (let i = 126; i >= 1; i--) {\r\n      dn = Math.sqrt(-2.0 * Math.log(vn / dn + Math.exp(-0.5 * dn * dn)))\r\n      unchecked((this.kn[i + 1] = Math.floor((dn / tn) * m1)))\r\n      tn = dn\r\n      unchecked((this.fn[i] = Math.exp(-0.5 * dn * dn)))\r\n      unchecked((this.wn[i] = dn / m1))\r\n    }\r\n  }\r\n}\r\n\r\nconst gaussian = new Ziggurat()\r\n\r\nfunction randNorm(): f64 {\r\n  return gaussian.nextGaussian()\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction rand(): i64 {\r\n  const n = commonRandomJS() * (Math.pow(2, 32) - 1)\r\n  return (Math.floor(n) ? Math.floor(n) : Math.ceil(n)) as i64\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction genRand(lb: i32, hb: i32): i32 {\r\n  if (lb < 0 || hb < 0 || hb < lb) return 0\r\n  const range = hb - lb + 1\r\n  const r = rand()\r\n  const result = (r % range) + lb\r\n  return result as i32\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction randf(): f64 {\r\n  return 1.0 - 2.0 * ((rand() as f64) / (2147483647 + 1.0))\r\n}\r\n\r\nfunction sortArray(a: StaticArray<u32>, start: u32, finish: u32): void {\r\n  const t = a.slice(start, finish).sort()\r\n  for (let i = start; i < finish; ++i) {\r\n    unchecked((a[i] = t[i - start]))\r\n  }\r\n}\r\n\r\nfunction generateRandomCSR(dim: i32, density: i32, stddev: f64): Csr {\r\n  let nnzIthRow: f64, randCol: i32, nnzIthRowDouble: f64\r\n  const densityPerc = density / 10000.0\r\n  const nzPerRow = (dim * density) / 1000000\r\n  const numNonZeros = Math.round(nzPerRow * dim) as i32\r\n  const newStdev = stddev * nzPerRow\r\n\r\n  const m = new Csr(\r\n    dim,\r\n    dim,\r\n    densityPerc,\r\n    0,\r\n    nzPerRow,\r\n    numNonZeros,\r\n    newStdev,\r\n    new StaticArray<u32>(dim + 1),\r\n    new StaticArray<u32>(Math.round(nzPerRow * dim) as i32),\r\n    new StaticArray<f32>(0)\r\n  )\r\n\r\n  unchecked((m.aRow[0] = 0))\r\n  const nnzIthRowDoubled = (2 * m.nzPerRow) as i32\r\n  const highBound = Math.min(m.numCols, nnzIthRowDoubled) as i32\r\n  const usedCols = new Int8Array(m.numCols)\r\n\r\n  for (let i = 0; i < m.numRows; ++i) {\r\n    nnzIthRowDouble = randNorm()\r\n    nnzIthRowDouble *= m.stdev\r\n    nnzIthRowDouble += m.nzPerRow\r\n\r\n    if (nnzIthRowDouble < 0) {\r\n      nnzIthRow = 0\r\n    } else if (nnzIthRowDouble > highBound) {\r\n      nnzIthRow = highBound\r\n    } else {\r\n      nnzIthRow = Math.abs(Math.round(nnzIthRowDouble))\r\n    }\r\n\r\n    unchecked((m.aRow[i + 1] = (m.aRow[i] + nnzIthRow) as u32))\r\n\r\n    // no realloc in static arrays\r\n    if ((unchecked(m.aRow[i + 1]) as i32) > m.numNonZeros) {\r\n      const temp = m.aCol\r\n      m.aCol = new StaticArray<u32>(unchecked(m.aRow[i + 1])) // TA\r\n\r\n      const length = temp.length\r\n      for (let j = 0; j < length; j++) {\r\n        unchecked((m.aCol[j] = temp[j]))\r\n      }\r\n    }\r\n\r\n    for (let j = 0; j < m.numCols; j++) {\r\n      unchecked((usedCols[j] = 0))\r\n    }\r\n\r\n    const castNnzIthRow: i32 = nnzIthRow as i32\r\n    for (let j = 0; j < castNnzIthRow; ++j) {\r\n      randCol = genRand(0, m.numCols - 1)\r\n      if (unchecked(usedCols[randCol])) {\r\n        --j\r\n      } else {\r\n        unchecked((m.aCol[unchecked(m.aRow[i]) + j] = randCol as u32))\r\n        unchecked((usedCols[randCol as i32] = 1))\r\n      }\r\n    }\r\n    // sort the column entries\r\n    sortArray(m.aCol, m.aRow[i], m.aRow[i + 1]) // TA\r\n  }\r\n\r\n  m.numNonZeros = unchecked(m.aRow[m.numRows])\r\n  m.densityPerc = (m.numNonZeros * 100.0) / (m.numCols * m.numRows)\r\n  m.densityPpm = Math.round(m.densityPerc * 10000.0)\r\n\r\n  m.ax = new StaticArray<f32>(m.numNonZeros)\r\n  for (let i = 0; i < m.numNonZeros; ++i) {\r\n    unchecked((m.ax[i] = randf() as f32))\r\n    while (unchecked(m.ax[i] === 0.0)) {\r\n      unchecked((m.ax[i] = randf() as f32))\r\n    }\r\n  }\r\n\r\n  return m\r\n}\r\n\r\nfunction spmvCsr(\r\n  matrix: StaticArray<f32>,\r\n  dim: i32,\r\n  rowv: StaticArray<u32>,\r\n  colv: StaticArray<u32>,\r\n  v: StaticArray<f32>,\r\n  y: StaticArray<f32>,\r\n  out: StaticArray<f32>\r\n): void {\r\n  let rowStart: i32, rowEnd: i32\r\n  let sum: f32 = 0\r\n\r\n  for (let i = 0; i < dim; ++i) {\r\n    unchecked((sum = y[i]))\r\n    unchecked((rowStart = rowv[i]))\r\n    unchecked((rowEnd = rowv[i + 1]))\r\n\r\n    for (let j = rowStart; j < rowEnd; ++j) {\r\n      unchecked((sum += matrix[j] * v[colv[j]]))\r\n    }\r\n    unchecked((out[i] = sum))\r\n  }\r\n}\r\n\r\nexport function spmv(): f64 {\r\n  const dim: i32 = 25000\r\n  const density: i32 = 1000\r\n  const stddev: f64 = 0.005\r\n  const iterations: i32 = 50\r\n  const m = generateRandomCSR(dim, density, stddev)\r\n  const v = new StaticArray<f32>(dim)\r\n  const y = new StaticArray<f32>(dim)\r\n  const out = new StaticArray<f32>(dim)\r\n  for (let i = 0; i < dim; i++) {\r\n    unchecked((v[i] = randf() as f32))\r\n  }\r\n\r\n  const t1 = performance.now()\r\n  for (let i = 0; i < iterations; ++i) {\r\n    spmvCsr(m.ax, dim, m.aRow, m.aCol, v, y, out)\r\n  }\r\n  __collect()\r\n  const t2 = performance.now()\r\n\r\n  return t2 - t1\r\n}\r\n","import * as JSMath from \"./bindings/Math\";\r\nexport { JSMath };\r\n\r\nimport {\r\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\r\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\r\n} from \"./util/math\";\r\n\r\nimport {\r\n  abs as builtin_abs,\r\n  ceil as builtin_ceil,\r\n  clz as builtin_clz,\r\n  copysign as builtin_copysign,\r\n  floor as builtin_floor,\r\n  max as builtin_max,\r\n  min as builtin_min,\r\n  sqrt as builtin_sqrt,\r\n  trunc as builtin_trunc\r\n} from \"./builtins\";\r\n\r\n// SUN COPYRIGHT NOTICE\r\n//\r\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\r\n// Developed at SunPro, a Sun Microsystems, Inc. business.\r\n// Permission to use, copy, modify, and distribute this software\r\n// is freely granted, provided that this notice is preserved.\r\n//\r\n// Applies to all functions marked with a comment referring here.\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\r\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\r\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\r\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\r\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\r\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\r\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\r\n]);\r\n\r\n/** @internal */\r\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\r\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\r\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\r\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\r\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\r\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\r\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\r\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\r\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\r\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\r\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\r\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\r\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\r\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\r\n  return p / q;\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\r\n  const                       // see: musl/src/math/__expo2.c\r\n    k    = <u32>2043,\r\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\r\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\r\n  // in directed rounding correct sign before rounding or overflow is important\r\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\r\n}\r\n\r\n/** @internal */\r\n/* Helper function to eventually get bits of π/2 * |x|\r\n *\r\n * y = π/4 * (frac << clz(frac) >> 11)\r\n * return clz(frac)\r\n *\r\n * Right shift 11 bits to make upper half fit in `double`\r\n */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\r\n  // Bits of π/4\r\n  const p0: u64 = 0xC4C6628B80DC1CD1;\r\n  const p1: u64 = 0xC90FDAA22168C234;\r\n\r\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\r\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\r\n\r\n  var shift = clz(q1);\r\n\r\n  q1 = q1 << shift | q0 >> (64 - shift);\r\n  q0 <<= shift;\r\n\r\n  var lo = umuldi(p1, q1);\r\n  var hi = res128_hi;\r\n\r\n  var ahi = hi >> 11;\r\n  var alo = lo >> 11 | hi << 53;\r\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\r\n\r\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\r\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\r\n\r\n  return shift;\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction umuldi(u: u64, v: u64): u64 {\r\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\r\n\r\n  u1 = u & 0xFFFFFFFF;\r\n  v1 = v & 0xFFFFFFFF;\r\n\r\n  u >>= 32;\r\n  v >>= 32;\r\n\r\n  t  = u1 * v1;\r\n  w0 = t & 0xFFFFFFFF;\r\n  t  = u * v1 + (t >> 32);\r\n  w1 = t >> 32;\r\n  t  = u1 * v + (t & 0xFFFFFFFF);\r\n\r\n  res128_hi = u * v + w1 + (t >> 32);\r\n  return (t << 32) + w0;\r\n}\r\n\r\n/** @internal */\r\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\r\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\r\n  var offset = (magnitude >> 52) - 1045;\r\n  var shift  = offset & 63;\r\n  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\r\n  var s0: u64, s1: u64, s2: u64;\r\n\r\n  var b0 = load<u64>(tblPtr, 0 << 3);\r\n  var b1 = load<u64>(tblPtr, 1 << 3);\r\n  var b2 = load<u64>(tblPtr, 2 << 3);\r\n\r\n  // Get 192 bits of 0x1p-31 / π with `offset` bits skipped\r\n  if (shift) {\r\n    let rshift = 64 - shift;\r\n    let b3 = load<u64>(tblPtr, 3 << 3);\r\n    s0 = b1 >> rshift | b0 << shift;\r\n    s1 = b2 >> rshift | b1 << shift;\r\n    s2 = b3 >> rshift | b2 << shift;\r\n  } else {\r\n    s0 = b0;\r\n    s1 = b1;\r\n    s2 = b2;\r\n  }\r\n\r\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\r\n\r\n  // First 128 bits of fractional part of x/(2π)\r\n  var blo = umuldi(s1, significand);\r\n  var bhi = res128_hi;\r\n\r\n  var ahi = s0 * significand;\r\n  var clo = (s2 >> 32) * (significand >> 32);\r\n  var plo = blo + clo;\r\n  var phi = ahi + bhi + u64(plo < clo);\r\n\r\n  // r: u128 = p << 2\r\n  var rlo = plo << 2;\r\n  var rhi = phi << 2 | plo >> 62;\r\n\r\n  // s: i128 = r >> 127\r\n  var slo = <i64>rhi >> 63;\r\n  var shi = slo >> 1;\r\n  var q   = (<i64>phi >> 62) - slo;\r\n\r\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\r\n  var signbit = (u ^ rhi) & 0x8000000000000000;\r\n  var coeff = reinterpret<f64>(shifter | signbit);\r\n\r\n  rempio2_y0 *= coeff;\r\n  rempio2_y1 *= coeff;\r\n\r\n  return <i32>q;\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\r\n  const pio2_1  = reinterpret<f64>(0x3FF921FB54400000); // 1.57079632673412561417e+00\r\n  const pio2_1t = reinterpret<f64>(0x3DD0B4611A626331); // 6.07710050650619224932e-11\r\n  const pio2_2  = reinterpret<f64>(0x3DD0B4611A600000); // 6.07710050630396597660e-11\r\n  const pio2_2t = reinterpret<f64>(0x3BA3198A2E037073); // 2.02226624879595063154e-21\r\n  const pio2_3  = reinterpret<f64>(0x3BA3198A2E000000); // 2.02226624871116645580e-21\r\n  const pio2_3t = reinterpret<f64>(0x397B839A252049C1); // 8.47842766036889956997e-32\r\n  const invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\r\n\r\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\r\n\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\r\n      let q = 1, z: f64, y0: f64, y1: f64;\r\n      if (!sign) {\r\n        z = x - pio2_1;\r\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\r\n          y0 = z - pio2_1t;\r\n          y1 = (z - y0) - pio2_1t;\r\n        } else { // near pi/2, use 33+33+53 bit pi\r\n          z -= pio2_2;\r\n          y0 = z - pio2_2t;\r\n          y1 = (z - y0) - pio2_2t;\r\n        }\r\n      } else { // negative x\r\n        z = x + pio2_1;\r\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\r\n          y0 = z + pio2_1t;\r\n          y1 = (z - y0) + pio2_1t;\r\n        } else { // near pi/2, use 33+33+53 bit pi\r\n          z += pio2_2;\r\n          y0 = z + pio2_2t;\r\n          y1 = (z - y0) + pio2_2t;\r\n        }\r\n        q = -1;\r\n      }\r\n      rempio2_y0 = y0;\r\n      rempio2_y1 = y1;\r\n      return q;\r\n    }\r\n  }\r\n\r\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\r\n    // Use precise Cody Waite scheme\r\n    let q  = nearest(x * invpio2);\r\n    let r  = x - q * pio2_1;\r\n    let w  = q * pio2_1t; // 1st round good to 85 bit\r\n    let j  = ix >> 20;\r\n    let y0 = r - w;\r\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\r\n    let i  = j - ((hi >> 20) & 0x7FF);\r\n\r\n    if (i > 16) { // 2nd iteration needed, good to 118\r\n      let t = r;\r\n      w  = q * pio2_2;\r\n      r  = t - w;\r\n      w  = q * pio2_2t - ((t - r) - w);\r\n      y0 = r - w;\r\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\r\n      i = j - ((hi >> 20) & 0x7FF);\r\n      if (i > 49) { // 3rd iteration need, 151 bits acc\r\n        let t = r;\r\n        w  = q * pio2_3;\r\n        r  = t - w;\r\n        w  = q * pio2_3t - ((t - r) - w);\r\n        y0 = r - w;\r\n      }\r\n    }\r\n    let y1 = (r - y0) - w;\r\n    rempio2_y0 = y0;\r\n    rempio2_y1 = y1;\r\n    return <i32>q;\r\n  }\r\n  var q = pio2_large_quot(x, u);\r\n  return select(-q, q, sign);\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\r\n  const S1 = reinterpret<f64>(0xBFC5555555555549); // -1.66666666666666324348e-01\r\n  const S2 = reinterpret<f64>(0x3F8111111110F8A6); //  8.33333333332248946124e-03\r\n  const S3 = reinterpret<f64>(0xBF2A01A019C161D5); // -1.98412698298579493134e-04\r\n  const S4 = reinterpret<f64>(0x3EC71DE357B1FE7D); //  2.75573137070700676789e-06\r\n  const S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB); // -2.50507602534068634195e-08\r\n  const S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\r\n  var v = z * x;\r\n  if (!iy) {\r\n    return x + v * (S1 + z * r);\r\n  } else {\r\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\r\n  }\r\n}\r\n\r\n/** @internal */\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\r\n  const C1 = reinterpret<f64>(0x3FA555555555554C); //  4.16666666666666019037e-02\r\n  const C2 = reinterpret<f64>(0xBF56C16C16C15177); // -1.38888888888741095749e-03\r\n  const C3 = reinterpret<f64>(0x3EFA01A019CB1590); //  2.48015872894767294178e-05\r\n  const C4 = reinterpret<f64>(0xBE927E4F809C52AD); // -2.75573143513906633035e-07\r\n  const C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4); //  2.08757232129817482790e-09\r\n  const C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\r\n  var hz = 0.5 * z;\r\n  w = 1.0 - hz;\r\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\r\n}\r\n\r\n/** @internal */\r\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\r\n  const T0  = reinterpret<f64>(0x3FD5555555555563); //  3.33333333333334091986e-01\r\n  const T1  = reinterpret<f64>(0x3FC111111110FE7A); //  1.33333333333201242699e-01\r\n  const T2  = reinterpret<f64>(0x3FABA1BA1BB341FE); //  5.39682539762260521377e-02\r\n  const T3  = reinterpret<f64>(0x3F9664F48406D637); //  2.18694882948595424599e-02\r\n  const T4  = reinterpret<f64>(0x3F8226E3E96E8493); //  8.86323982359930005737e-03\r\n  const T5  = reinterpret<f64>(0x3F6D6D22C9560328); //  3.59207910759131235356e-03\r\n  const T6  = reinterpret<f64>(0x3F57DBC8FEE08315); //  1.45620945432529025516e-03\r\n  const T7  = reinterpret<f64>(0x3F4344D8F2F26501); //  5.88041240820264096874e-04\r\n  const T8  = reinterpret<f64>(0x3F3026F71A8D1068); //  2.46463134818469906812e-04\r\n  const T9  = reinterpret<f64>(0x3F147E88A03792A6); //  7.81794442939557092300e-05\r\n  const T10 = reinterpret<f64>(0x3F12B80F32F0A7E9); //  7.14072491382608190305e-05\r\n  const T11 = reinterpret<f64>(0xBEF375CBDB605373); // -1.85586374855275456654e-05\r\n  const T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\r\n\r\n  const one    = reinterpret<f64>(0x3FF0000000000000); // 1.00000000000000000000e+00\r\n  const pio4   = reinterpret<f64>(0x3FE921FB54442D18); // 7.85398163397448278999e-01\r\n  const pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\r\n\r\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\r\n  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\r\n  var ix = hx & 0x7FFFFFFF; // high word of |x|\r\n  var big = ix >= 0x3FE59428;\r\n  if (big) { // |x| >= 0.6744\r\n    if (hx < 0) { x = -x, y = -y; }\r\n    z = pio4 - x;\r\n    w = pio4lo - y;\r\n    x = z + w;\r\n    y = 0.0;\r\n  }\r\n  z = x * x;\r\n  w = z * z;\r\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\r\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\r\n  s = z * x;\r\n  r = y + z * (s * (r + v) + y);\r\n  r += T0 * s;\r\n  w = x + r;\r\n  if (big) {\r\n    v = iy;\r\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\r\n  }\r\n  if (iy == 1) return w;\r\n  var a: f64, t: f64;\r\n  z = w;\r\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\r\n  v = r - (z - x);  // z + v = r + x\r\n  t = a = -one / w; // a = -1.0 / w\r\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\r\n  s = one + t * z;\r\n  return t + a * (s + t * v);\r\n}\r\n\r\n/** @internal */\r\nfunction dtoi32(x: f64): i32 {\r\n  if (ASC_SHRINK_LEVEL > 0) {\r\n    const inv32 = 1.0 / 4294967296;\r\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\r\n  } else {\r\n    let result = 0;\r\n    let u = reinterpret<u64>(x);\r\n    let e = (u >> 52) & 0x7FF;\r\n    if (e <= 1023 + 30) {\r\n      result = <i32>x;\r\n    } else if (e <= 1023 + 30 + 53) {\r\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\r\n      v = v << e - 1023 - 52 + 32;\r\n      result = <i32>(v >> 32);\r\n      result = select<i32>(-result, result, u >> 63);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy var random_seeded = false;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var random_state0_64: u64, random_state1_64: u64;\r\n\r\n// @ts-ignore: decorator\r\n@lazy var random_state0_32: u32, random_state1_32: u32;\r\n\r\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\r\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\r\n  h *= 0xFF51AFD7ED558CCD;\r\n  h ^= h >> 33;\r\n  h *= 0xC4CEB9FE1A85EC53;\r\n  h ^= h >> 33;\r\n  return h;\r\n}\r\n\r\nfunction splitMix32(h: u32): u32 {\r\n  h += 0x6D2B79F5;\r\n  h  = (h ^ (h >> 15)) * (h | 1);\r\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\r\n  return h ^ (h >> 14);\r\n}\r\n\r\nexport namespace NativeMath {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_sin: f64 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_cos: f64 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @inline export function abs(x: f64): f64 {\r\n    return builtin_abs<f64>(x);\r\n  }\r\n\r\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\r\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3FF00000) {\r\n      let lx = <u32>reinterpret<u64>(x);\r\n      if ((ix - 0x3FF00000 | lx) == 0) {\r\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\r\n        return 0;\r\n      }\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3FE00000) {\r\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\r\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\r\n    }\r\n    var s: f64, w: f64, z: f64;\r\n    if (hx >> 31) {\r\n      // z = (1.0 + x) * 0.5;\r\n      z = 0.5 + x * 0.5;\r\n      s = builtin_sqrt<f64>(z);\r\n      w = R(z) * s - pio2_lo;\r\n      return 2 * (pio2_hi - (s + w));\r\n    }\r\n    // z = (1.0 - x) * 0.5;\r\n    z = 0.5 - x * 0.5;\r\n    s = builtin_sqrt<f64>(z);\r\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\r\n    var c = (z - df * df) / (s + df);\r\n    w = R(z) * s + c;\r\n    return 2 * (df + w);\r\n  }\r\n\r\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\r\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\r\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\r\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\r\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\r\n    return log(x) + s;\r\n  }\r\n\r\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\r\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3FF00000) {\r\n      let lx = <u32>reinterpret<u64>(x);\r\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3FE00000) {\r\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\r\n      return x + x * R(x * x);\r\n    }\r\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\r\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\r\n    var s = builtin_sqrt<f64>(z);\r\n    var r = R(z);\r\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\r\n    else {\r\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\r\n      let c = (z - f * f) / (s + f);\r\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\r\n    }\r\n    if (hx >> 31) return -x;\r\n    return x;\r\n  }\r\n\r\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\r\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\r\n    var u = reinterpret<u64>(x);\r\n    var e = u >> 52 & 0x7FF;\r\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\r\n    if (e >= 0x3FF + 26) y = log(y) + c;\r\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\r\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\r\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\r\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\r\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\r\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\r\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\r\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\r\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\r\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\r\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\r\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\r\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\r\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\r\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\r\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\r\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\r\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\r\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\r\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\r\n    var sx = x;\r\n    ix &= 0x7FFFFFFF;\r\n    var z: f64;\r\n    if (ix >= 0x44100000) {\r\n      if (isNaN(x)) return x;\r\n      z = atanhi3 + Ox1p_120f;\r\n      return builtin_copysign<f64>(z, sx);\r\n    }\r\n    var id: i32;\r\n    if (ix < 0x3FDC0000) {\r\n      if (ix < 0x3E400000) return x;\r\n      id = -1;\r\n    } else {\r\n      x = builtin_abs<f64>(x);\r\n      if (ix < 0x3FF30000) {\r\n        if (ix < 0x3FE60000) {\r\n          id = 0;\r\n          x = (2.0 * x - 1.0) / (2.0 + x);\r\n        } else {\r\n          id = 1;\r\n          x = (x - 1.0) / (x + 1.0);\r\n        }\r\n      } else {\r\n        if (ix < 0x40038000) {\r\n          id = 2;\r\n          x = (x - 1.5) / (1.0 + 1.5 * x);\r\n        } else {\r\n          id = 3;\r\n          x = -1.0 / x;\r\n        }\r\n      }\r\n    }\r\n    z = x * x;\r\n    var w = z * z;\r\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\r\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\r\n    var s3 = x * (s1 + s2);\r\n    if (id < 0) return x - s3;\r\n    switch (id) {\r\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\r\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\r\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\r\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\r\n      default: unreachable();\r\n    }\r\n    return builtin_copysign<f64>(z, sx);\r\n  }\r\n\r\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\r\n    var u = reinterpret<u64>(x);\r\n    var e = u >> 52 & 0x7FF;\r\n    var y = builtin_abs(x);\r\n    if (e < 0x3FF - 1) {\r\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\r\n    } else {\r\n      y = 0.5 * log1p(2 * (y / (1 - y)));\r\n    }\r\n    return builtin_copysign<f64>(y, x);\r\n  }\r\n\r\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\r\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\r\n    if (isNaN(x) || isNaN(y)) return x + y;\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var lx = <u32>u;\r\n    u = reinterpret<u64>(y);\r\n    var iy = <u32>(u >> 32);\r\n    var ly = <u32>u;\r\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\r\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\r\n    ix = ix & 0x7FFFFFFF;\r\n    iy = iy & 0x7FFFFFFF;\r\n    if ((iy | ly) == 0) {\r\n      switch (m) {\r\n        case 0:\r\n        case 1: return  y;\r\n        case 2: return  PI;\r\n        case 3: return -PI;\r\n      }\r\n    }\r\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\r\n    if (ix == 0x7FF00000) {\r\n      if (iy == 0x7FF00000) {\r\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\r\n        return m & 1 ? -t : t;\r\n      } else {\r\n        let t = m & 2 ? PI : 0;\r\n        return m & 1 ? -t : t;\r\n      }\r\n    }\r\n    var z: f64;\r\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\r\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\r\n    else z = atan(builtin_abs<f64>(y / x));\r\n    switch (m) {\r\n      case 0: return  z;\r\n      case 1: return -z;\r\n      case 2: return PI - (z - pi_lo);\r\n      case 3: return (z - pi_lo) - PI;\r\n    }\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      B1     = <u32>715094163,\r\n      B2     = <u32>696219795,\r\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\r\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\r\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\r\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\r\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\r\n      Ox1p54 = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\r\n    if (hx >= 0x7FF00000) return x + x;\r\n    if (hx < 0x00100000) {\r\n      u = reinterpret<u64>(x * Ox1p54);\r\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\r\n      if (hx == 0) return x;\r\n      hx = hx / 3 + B2;\r\n    } else {\r\n      hx = hx / 3 + B1;\r\n    }\r\n    u &= 1 << 63;\r\n    u |= <u64>hx << 32;\r\n    var t = reinterpret<f64>(u);\r\n    var r = (t * t) * (t / x);\r\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\r\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\r\n    var s = t * t;\r\n    r = x / s;\r\n    r = (r - t) / (2 * t + r);\r\n    t = t + t * r;\r\n    return t;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function ceil(x: f64): f64 {\r\n    return builtin_ceil<f64>(x);\r\n  }\r\n\r\n  export function clz32(x: f64): f64 {\r\n    if (!isFinite(x)) return 32;\r\n    /*\r\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\r\n     *\r\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\r\n     * our float-point arguments before actual convertion to integers.\r\n     */\r\n    return builtin_clz(dtoi32(x));\r\n  }\r\n\r\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\r\n    var u  = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var sign = ix >> 31;\r\n\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    // |x| ~< pi/4\r\n    if (ix <= 0x3FE921FB) {\r\n      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\r\n        return 1.0;\r\n      }\r\n      return cos_kern(x, 0);\r\n    }\r\n\r\n    // sin(Inf or NaN) is NaN\r\n    if (ix >= 0x7FF00000) return x - x;\r\n\r\n    // argument reduction needed\r\n    var n  = rempio2(x, u, sign);\r\n    var y0 = rempio2_y0;\r\n    var y1 = rempio2_y1;\r\n\r\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\r\n    return (n + 1) & 2 ? -x : x;\r\n  }\r\n\r\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\r\n    var u = reinterpret<u64>(x);\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    x = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    if (w < 0x3FE62E42) {\r\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\r\n      t = expm1(x);\r\n      // return 1 + t * t / (2 * (1 + t));\r\n      return 1 + t * t / (2 + 2 * t);\r\n    }\r\n    if (w < 0x40862E42) {\r\n      t = exp(x);\r\n      return 0.5 * (t + 1 / t);\r\n    }\r\n    t = expo2(x, 1);\r\n    return t;\r\n  }\r\n\r\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return exp_lut(x);\r\n    } else {\r\n      const\r\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\r\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\r\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\r\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\r\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\r\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\r\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\r\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\r\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\r\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000);\r\n      let hx = <u32>(reinterpret<u64>(x) >> 32);\r\n      let sign_ = <i32>(hx >> 31);\r\n      hx &= 0x7FFFFFFF;\r\n      if (hx >= 0x4086232B) {\r\n        if (isNaN(x)) return x;\r\n        if (x > overflow)  return x * Ox1p1023;\r\n        if (x < underflow) return 0;\r\n      }\r\n      let hi: f64, lo: f64 = 0;\r\n      let k = 0;\r\n      if (hx > 0x3FD62E42) {\r\n        if (hx >= 0x3FF0A2B2) {\r\n          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\r\n        } else {\r\n          k = 1 - (sign_ << 1);\r\n        }\r\n        hi = x - k * ln2hi;\r\n        lo = k * ln2lo;\r\n        x = hi - lo;\r\n      } else if (hx > 0x3E300000) {\r\n        hi = x;\r\n      } else return 1.0 + x;\r\n      let xs = x * x;\r\n      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\r\n      let xq = xs * xs;\r\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\r\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\r\n      return k == 0 ? y : scalbn(y, k);\r\n    }\r\n  }\r\n\r\n  export function exp2(x: f64): f64 {\r\n    return exp2_lut(x);\r\n  }\r\n\r\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\r\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\r\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\r\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\r\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\r\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\r\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\r\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\r\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\r\n    var k = 0, sign_ = <i32>(u >> 63);\r\n    if (hx >= 0x4043687A) {\r\n      if (isNaN(x)) return x;\r\n      if (sign_) return -1;\r\n      if (x > o_threshold) return x * Ox1p1023;\r\n    }\r\n    var c = 0.0, t: f64;\r\n    if (hx > 0x3FD62E42) {\r\n      k = select<i32>(\r\n        1 - (sign_ << 1),\r\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\r\n        hx < 0x3FF0A2B2\r\n      );\r\n      t = <f64>k;\r\n      let hi = x - t * ln2_hi;\r\n      let lo = t * ln2_lo;\r\n      x = hi - lo;\r\n      c = (hi - x) - lo;\r\n    } else if (hx < 0x3C900000) return x;\r\n    var hfx = 0.5 * x;\r\n    var hxs = x * hfx;\r\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\r\n    var hxq = hxs * hxs;\r\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\r\n    t = 3.0 - r1 * hfx;\r\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\r\n    if (k == 0) return x - (x * e - hxs);\r\n    e = x * (e - c) - c;\r\n    e -= hxs;\r\n    if (k == -1) return 0.5 * (x - e) - 0.5;\r\n    if (k == 1) {\r\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\r\n      return 1.0 + 2.0 * (x - e);\r\n    }\r\n    u = (0x3FF + k) << 52;\r\n    var twopk = reinterpret<f64>(u);\r\n    var y: f64;\r\n    if (k < 0 || k > 56) {\r\n      y = x - e + 1.0;\r\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\r\n      else y = y * twopk;\r\n      return y - 1.0;\r\n    }\r\n    u = (0x3FF - k) << 52;\r\n    y = reinterpret<f64>(u);\r\n    if (k < 20) y = (1 - y) - e;\r\n    else y = 1 - (e + y);\r\n    return (x + y) * twopk;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function floor(x: f64): f64 {\r\n    return builtin_floor<f64>(x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function fround(x: f64): f64 {\r\n    return <f32>x;\r\n  }\r\n\r\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\r\n    const\r\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\r\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\r\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    ux &= 0x7FFFFFFFFFFFFFFF;\r\n    uy &= 0x7FFFFFFFFFFFFFFF;\r\n    if (ux < uy) {\r\n      let ut = ux;\r\n      ux = uy;\r\n      uy = ut;\r\n    }\r\n    var ex = <i32>(ux >> 52);\r\n    var ey = <i32>(uy >> 52);\r\n    y = reinterpret<f64>(uy);\r\n    if (ey == 0x7FF) return y;\r\n    x = reinterpret<f64>(ux);\r\n    if (ex == 0x7FF || uy == 0) return x;\r\n    if (ex - ey > 64) return x + y;\r\n    var z = 1.0;\r\n    if (ex > 0x3FF + 510) {\r\n      z  = Ox1p700;\r\n      x *= Ox1p_700;\r\n      y *= Ox1p_700;\r\n    } else if (ey < 0x3FF - 450) {\r\n      z  = Ox1p_700;\r\n      x *= Ox1p700;\r\n      y *= Ox1p700;\r\n    }\r\n    var c = x * SPLIT;\r\n    var h = x - c + c;\r\n    var l = x - h;\r\n    var hx = x * x;\r\n    var lx = h * h - hx + (2 * h + l) * l;\r\n    c = y * SPLIT;\r\n    h = y - c + c;\r\n    l = y - h;\r\n    var hy = y * y;\r\n    var ly = h * h - hy + (2 * h + l) * l;\r\n    return z * builtin_sqrt(ly + lx + hy + hx);\r\n  }\r\n\r\n  export function imul(x: f64, y: f64): f64 {\r\n    /*\r\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\r\n     *\r\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\r\n     * our float-point arguments before actual convertion to integers.\r\n     */\r\n    if (!isFinite(x + y)) return 0;\r\n    return dtoi32(x) * dtoi32(y);\r\n  }\r\n\r\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return log_lut(x);\r\n    } else {\r\n      const\r\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\r\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\r\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n        Ox1p54 = reinterpret<f64>(0x4350000000000000);\r\n      let u = reinterpret<u64>(x);\r\n      let hx = <u32>(u >> 32);\r\n      let k = 0;\r\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n        if (u << 1 == 0) return -1 / (x * x);\r\n        if (hx >> 31)    return (x - x) / 0.0;\r\n        k -= 54;\r\n        x *= Ox1p54;\r\n        u = reinterpret<u64>(x);\r\n        hx = <u32>(u >> 32);\r\n      } else if (hx >= 0x7FF00000) {\r\n        return x;\r\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\r\n        return 0;\r\n      }\r\n      hx += 0x3FF00000 - 0x3FE6A09E;\r\n      k += (<i32>hx >> 20) - 0x3FF;\r\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n      x = reinterpret<f64>(u);\r\n      let f = x - 1.0;\r\n      let hfsq = 0.5 * f * f;\r\n      let s = f / (2.0 + f);\r\n      let z = s * s;\r\n      let w = z * z;\r\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n      let r = t2 + t1;\r\n      let dk = <f64>k;\r\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\r\n    }\r\n  }\r\n\r\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\r\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\r\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\r\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\r\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n      Ox1p54    = reinterpret<f64>(0x4350000000000000);\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 0;\r\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n      if (u << 1 == 0) return -1 / (x * x);\r\n      if (hx >> 31) return (x - x) / 0.0;\r\n      k -= 54;\r\n      x *= Ox1p54;\r\n      u = reinterpret<u64>(x);\r\n      hx = <u32>(u >> 32);\r\n    } else if (hx >= 0x7FF00000) {\r\n      return x;\r\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\r\n      return 0;\r\n    }\r\n    hx += 0x3FF00000 - 0x3FE6A09E;\r\n    k += <i32>(hx >> 20) - 0x3FF;\r\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n    x = reinterpret<f64>(u);\r\n    var f = x - 1.0;\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var hi = f - hfsq;\r\n    u = reinterpret<u64>(hi);\r\n    u &= 0xFFFFFFFF00000000;\r\n    hi = reinterpret<f64>(u);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var val_hi = hi * ivln10hi;\r\n    var dk = <f64>k;\r\n    var y = dk * log10_2hi;\r\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\r\n    w = y + val_hi;\r\n    val_lo += (y - w) + val_hi;\r\n    return val_lo + w;\r\n  }\r\n\r\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\r\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\r\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\r\n    var u = reinterpret<u64>(x);\r\n    var hx = <u32>(u >> 32);\r\n    var k = 1;\r\n    var c = 0.0, f = 0.0;\r\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\r\n      if (hx >= 0xBFF00000) {\r\n        if (x == -1) return x / 0.0;\r\n        return (x - x) / 0.0;\r\n      }\r\n      if (hx << 1 < 0x3CA00000 << 1) return x;\r\n      if (hx <= 0xBFD2BEC4) {\r\n        k = 0;\r\n        c = 0;\r\n        f = x;\r\n      }\r\n    } else if (hx >= 0x7FF00000) return x;\r\n    if (k) {\r\n      u = reinterpret<u64>(1 + x);\r\n      let hu = <u32>(u >> 32);\r\n      hu += 0x3FF00000 - 0x3FE6A09E;\r\n      k = <i32>(hu >> 20) - 0x3FF;\r\n      if (k < 54) {\r\n        let uf = reinterpret<f64>(u);\r\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\r\n        c /= uf;\r\n      } else c = 0;\r\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\r\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\r\n      f = reinterpret<f64>(u) - 1;\r\n    }\r\n    var hfsq = 0.5 * f * f;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n    var r = t2 + t1;\r\n    var dk = <f64>k;\r\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return log2_lut(x);\r\n    } else {\r\n      const\r\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\r\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\r\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\r\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\r\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\r\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\r\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\r\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\r\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\r\n        Ox1p54  = reinterpret<f64>(0x4350000000000000);\r\n      let u = reinterpret<u64>(x);\r\n      let hx = <u32>(u >> 32);\r\n      let k = 0;\r\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\r\n        if (u << 1 == 0) return -1 / (x * x);\r\n        if (hx >> 31) return (x - x) / 0.0;\r\n        k -= 54;\r\n        x *= Ox1p54;\r\n        u = reinterpret<u64>(x);\r\n        hx = <u32>(u >> 32);\r\n      } else if (hx >= 0x7FF00000) {\r\n        return x;\r\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\r\n        return 0;\r\n      }\r\n      hx += 0x3FF00000 - 0x3FE6A09E;\r\n      k += <i32>(hx >> 20) - 0x3FF;\r\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\r\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\r\n      x = reinterpret<f64>(u);\r\n      let f = x - 1.0;\r\n      let hfsq = 0.5 * f * f;\r\n      let s = f / (2.0 + f);\r\n      let z = s * s;\r\n      let w = z * z;\r\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\r\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\r\n      let r = t2 + t1;\r\n      let hi = f - hfsq;\r\n      u = reinterpret<u64>(hi);\r\n      u &= 0xFFFFFFFF00000000;\r\n      hi = reinterpret<f64>(u);\r\n      let lo = f - hi - hfsq + s * (hfsq + r);\r\n      let val_hi = hi * ivln2hi;\r\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\r\n      let y = <f64>k;\r\n      w = y + val_hi;\r\n      val_lo += (y - w) + val_hi;\r\n      val_hi = w;\r\n      return val_lo + val_hi;\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function max(value1: f64, value2: f64): f64 {\r\n    return builtin_max<f64>(value1, value2);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function min(value1: f64, value2: f64): f64 {\r\n    return builtin_min<f64>(value1, value2);\r\n  }\r\n\r\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\r\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\r\n    if (builtin_abs<f64>(y) <= 2) {\r\n      if (y == 2.0) return x * x;\r\n      if (y == 0.5) {\r\n        return select<f64>(\r\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\r\n          Infinity,\r\n          x != -Infinity\r\n        );\r\n      }\r\n      if (y == -1.0) return 1 / x;\r\n      if (y == 1.0) return x;\r\n      if (y == 0.0) return 1.0;\r\n    }\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return pow_lut(x, y);\r\n    } else {\r\n      const\r\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\r\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\r\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\r\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\r\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\r\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\r\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\r\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\r\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\r\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\r\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\r\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\r\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\r\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\r\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\r\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\r\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\r\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\r\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\r\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\r\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\r\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\r\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\r\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\r\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\r\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\r\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\r\n      let u_ = reinterpret<u64>(x);\r\n      let hx = <i32>(u_ >> 32);\r\n      let lx = <u32>u_;\r\n      u_ = reinterpret<u64>(y);\r\n      let hy = <i32>(u_ >> 32);\r\n      let ly = <u32>u_;\r\n      let ix = hx & 0x7FFFFFFF;\r\n      let iy = hy & 0x7FFFFFFF;\r\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\r\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\r\n      if ( // NaN if either arg is NaN\r\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\r\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\r\n      ) return x + y;\r\n      let yisint = 0, k: i32;\r\n      if (hx < 0) {\r\n        if (iy >= 0x43400000) yisint = 2;\r\n        else if (iy >= 0x3FF00000) {\r\n          k = (iy >> 20) - 0x3FF;\r\n          let offset = select<u32>(52, 20, k > 20) - k;\r\n          let Ly = select<u32>(ly, iy, k > 20);\r\n          let jj = Ly >> offset;\r\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\r\n        }\r\n      }\r\n      if (ly == 0) {\r\n        if (iy == 0x7FF00000) { // y is +-inf\r\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\r\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\r\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\r\n        }\r\n        if (iy == 0x3FF00000) {\r\n          if (hy >= 0) return x;\r\n          return 1 / x;\r\n        }\r\n        if (hy == 0x40000000) return x * x;\r\n        if (hy == 0x3FE00000) {\r\n          if (hx >= 0) return builtin_sqrt(x);\r\n        }\r\n      }\r\n      let ax = builtin_abs<f64>(x), z: f64;\r\n      if (lx == 0) {\r\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\r\n          z = ax;\r\n          if (hy < 0) z = 1.0 / z;\r\n          if (hx < 0) {\r\n            if (((ix - 0x3FF00000) | yisint) == 0) {\r\n              let d = z - z;\r\n              z = d / d;\r\n            } else if (yisint == 1) z = -z;\r\n          }\r\n          return z;\r\n        }\r\n      }\r\n      let s = 1.0;\r\n      if (hx < 0) {\r\n        if (yisint == 0) {\r\n          let d = x - x;\r\n          return d / d;\r\n        }\r\n        if (yisint == 1) s = -1.0;\r\n      }\r\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\r\n      let j: i32, n: i32;\r\n      if (iy > 0x41E00000) {\r\n        if (iy > 0x43F00000) {\r\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\r\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\r\n        }\r\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\r\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\r\n        t = ax - 1.0;\r\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\r\n        u = ivln2_h * t;\r\n        v = t * ivln2_l - w * ivln2;\r\n        t1 = u + v;\r\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\r\n        t2 = v - (t1 - u);\r\n      } else {\r\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\r\n        n = 0;\r\n        if (ix < 0x00100000) {\r\n          ax *= two53;\r\n          n -= 53;\r\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\r\n        }\r\n        n += (ix >> 20) - 0x3FF;\r\n        j = ix & 0x000FFFFF;\r\n        ix = j | 0x3FF00000;\r\n        if (j <= 0x3988E) k = 0;\r\n        else if (j < 0xBB67A) k = 1;\r\n        else {\r\n          k = 0;\r\n          n += 1;\r\n          ix -= 0x00100000;\r\n        }\r\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\r\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\r\n        u = ax - bp;\r\n        v = 1.0 / (ax + bp);\r\n        ss = u * v;\r\n        s_h = ss;\r\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\r\n        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\r\n        t_l = ax - (t_h - bp);\r\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\r\n        s2 = ss * ss;\r\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\r\n        r += s_l * (s_h + ss);\r\n        s2 = s_h * s_h;\r\n        t_h = 3.0 + s2 + r;\r\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\r\n        t_l = r - ((t_h - 3.0) - s2);\r\n        u = s_h * t_h;\r\n        v = s_l * t_h + t_l * ss;\r\n        p_h = u + v;\r\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\r\n        p_l = v - (p_h - u);\r\n        let z_h = cp_h * p_h;\r\n        let dp_l = select<f64>(dp_l1, 0.0, k);\r\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\r\n        t = <f64>n;\r\n        let dp_h = select<f64>(dp_h1, 0.0, k);\r\n        t1 = ((z_h + z_l) + dp_h) + t;\r\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\r\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\r\n      }\r\n      let y1 = y;\r\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\r\n      p_l = (y - y1) * t1 + y * t2;\r\n      p_h = y1 * t1;\r\n      z = p_l + p_h;\r\n      u_ = reinterpret<u64>(z);\r\n      j = <u32>(u_ >> 32);\r\n      let i = <i32>u_;\r\n      if (j >= 0x40900000) {\r\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\r\n        if (p_l + ovt > z - p_h) return s * huge * huge;\r\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\r\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\r\n        if (p_l <= z - p_h) return s * tiny * tiny;\r\n      }\r\n      i = j & 0x7FFFFFFF;\r\n      k = (i >> 20) - 0x3FF;\r\n      n = 0;\r\n      if (i > 0x3FE00000) {\r\n        n = j + (0x00100000 >> (k + 1));\r\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\r\n        t = 0.0;\r\n        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\r\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\r\n        if (j < 0) n = -n;\r\n        p_h -= t;\r\n      }\r\n      t = p_l + p_h;\r\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\r\n      u = t * lg2_h;\r\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\r\n      z = u + v;\r\n      w = v - (z - u);\r\n      t = z * z;\r\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\r\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\r\n      z = 1.0 - (r - z);\r\n      j = <u32>(reinterpret<u64>(z) >> 32);\r\n      j += n << 20;\r\n      if ((j >> 20) <= 0) z = scalbn(z, n);\r\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\r\n      return s * z;\r\n    }\r\n  }\r\n\r\n  export function seedRandom(value: i64): void {\r\n    random_seeded = true;\r\n    random_state0_64 = murmurHash3(value);\r\n    random_state1_64 = murmurHash3(~random_state0_64);\r\n    random_state0_32 = splitMix32(<u32>value);\r\n    random_state1_32 = splitMix32(random_state0_32);\r\n    assert(\r\n      random_state0_64 != 0 && random_state1_64 != 0 &&\r\n      random_state0_32 != 0 && random_state1_32 != 0\r\n    );\r\n  }\r\n\r\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\r\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\r\n    var s1 = random_state0_64;\r\n    var s0 = random_state1_64;\r\n    random_state0_64 = s0;\r\n    s1 ^= s1 << 23;\r\n    s1 ^= s1 >> 17;\r\n    s1 ^= s0;\r\n    s1 ^= s0 >> 26;\r\n    random_state1_64 = s1;\r\n    var r = (s0 >> 12) | 0x3FF0000000000000;\r\n    return reinterpret<f64>(r) - 1;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function round(x: f64): f64 {\r\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sign(x: f64): f64 {\r\n    if (ASC_SHRINK_LEVEL > 0) {\r\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\r\n    } else {\r\n      return x > 0 ? 1 : x < 0 ? -1 : x;\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function signbit(x: f64): bool {\r\n    return <bool>(reinterpret<u64>(x) >>> 63);\r\n  }\r\n\r\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\r\n    var u  = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var sign = ix >> 31;\r\n\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    // |x| ~< pi/4\r\n    if (ix <= 0x3FE921FB) {\r\n      if (ix < 0x3E500000) { // |x| < 2**-26\r\n        return x;\r\n      }\r\n      return sin_kern(x, 0.0, 0);\r\n    }\r\n\r\n    // sin(Inf or NaN) is NaN\r\n    if (ix >= 0x7FF00000) return x - x;\r\n\r\n    // argument reduction needed\r\n    var n  = rempio2(x, u, sign);\r\n    var y0 = rempio2_y0;\r\n    var y1 = rempio2_y1;\r\n\r\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\r\n    return n & 2 ? -x : x;\r\n  }\r\n\r\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\r\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\r\n    var absx = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var h = builtin_copysign(0.5, x);\r\n    if (w < 0x40862E42) {\r\n      let t = expm1(absx);\r\n      if (w < 0x3FF00000) {\r\n        if (w < 0x3FF00000 - (26 << 20)) return x;\r\n        return h * (2 * t - t * t / (t + 1));\r\n      }\r\n      return h * (t + t / (t + 1));\r\n    }\r\n    return expo2(absx, 2 * h);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sqrt(x: f64): f64 {\r\n    return builtin_sqrt<f64>(x);\r\n  }\r\n\r\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <i32>(u >> 32);\r\n    var sign = ix >>> 31;\r\n\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    // |x| ~< pi/4\r\n    if (ix <= 0x3FE921FB) {\r\n      if (ix < 0x3E400000) { // |x| < 2**-27\r\n        return x;\r\n      }\r\n      return tan_kern(x, 0.0, 1);\r\n    }\r\n\r\n    // tan(Inf or NaN) is NaN\r\n    if (ix >= 0x7FF00000) return x - x;\r\n\r\n    var n = rempio2(x, u, sign);\r\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\r\n  }\r\n\r\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\r\n    var u = reinterpret<u64>(x);\r\n    u &= 0x7FFFFFFFFFFFFFFF;\r\n    var y = reinterpret<f64>(u);\r\n    var w = <u32>(u >> 32);\r\n    var t: f64;\r\n    if (w > 0x3FE193EA) {\r\n      if (w > 0x40340000) {\r\n        t = 1 - 0 / y;\r\n      } else {\r\n        t = expm1(2 * y);\r\n        t = 1 - 2 / (t + 2);\r\n      }\r\n    } else if (w > 0x3FD058AE) {\r\n      t = expm1(2 * y);\r\n      t = t / (t + 2);\r\n    } else if (w >= 0x00100000) {\r\n      t = expm1(-2 * y);\r\n      t = -t / (t + 2);\r\n    } else t = y;\r\n    return builtin_copysign<f64>(t, x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function trunc(x: f64): f64 {\r\n    return builtin_trunc<f64>(x);\r\n  }\r\n\r\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\r\n    const\r\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\r\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\r\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\r\n    var y = x;\r\n    if (n > 1023) {\r\n      y *= Ox1p1023;\r\n      n -= 1023;\r\n      if (n > 1023) {\r\n        y *= Ox1p1023;\r\n        n = builtin_min<i32>(n - 1023, 1023);\r\n      }\r\n    } else if (n < -1022) {\r\n      // make sure final n < -53 to avoid double\r\n      // rounding in the subnormal range\r\n      y *= Ox1p_1022 * Ox1p53;\r\n      n += 1022 - 53;\r\n      if (n < -1022) {\r\n        y *= Ox1p_1022 * Ox1p53;\r\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\r\n      }\r\n    }\r\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\r\n  }\r\n\r\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\r\n    if (builtin_abs<f64>(y) == 1.0) {\r\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\r\n      // TODO: move this rule to compiler's optimization pass.\r\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\r\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\r\n    }\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    var ex = <i64>(ux >> 52 & 0x7FF);\r\n    var ey = <i64>(uy >> 52 & 0x7FF);\r\n    var sx = ux >> 63;\r\n    var uy1 = uy << 1;\r\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\r\n      let m = x * y;\r\n      return m / m;\r\n    }\r\n    var ux1 = ux << 1;\r\n    if (ux1 <= uy1) {\r\n      return x * f64(ux1 != uy1);\r\n    }\r\n    if (!ex) {\r\n      ex -= builtin_clz<i64>(ux << 12);\r\n      ux <<= 1 - ex;\r\n    } else {\r\n      ux &= <u64>-1 >> 12;\r\n      ux |= 1 << 52;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<i64>(uy << 12);\r\n      uy <<= 1 - ey;\r\n    } else {\r\n      uy &= <u64>-1 >> 12;\r\n      uy |= 1 << 52;\r\n    }\r\n    while (ex > ey) {\r\n      if (ux >= uy) {\r\n        if (ux == uy) return 0 * x;\r\n        ux -= uy;\r\n      }\r\n      ux <<= 1;\r\n      --ex;\r\n    }\r\n    if (ux >= uy) {\r\n      if (ux == uy) return 0 * x;\r\n      ux -= uy;\r\n    }\r\n    // for (; !(ux >> 52); ux <<= 1) --ex;\r\n    var shift = builtin_clz<i64>(ux << 11);\r\n    ex -= shift;\r\n    ux <<= shift;\r\n    if (ex > 0) {\r\n      ux -= 1 << 52;\r\n      ux |= ex << 52;\r\n    } else {\r\n      ux >>= -ex + 1;\r\n    }\r\n    return reinterpret<f64>(ux | (sx << 63));\r\n  }\r\n\r\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\r\n    var ux = reinterpret<u64>(x);\r\n    var uy = reinterpret<u64>(y);\r\n    var ex = <i64>(ux >> 52 & 0x7FF);\r\n    var ey = <i64>(uy >> 52 & 0x7FF);\r\n    var sx = <i32>(ux >> 63);\r\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\r\n      let m = x * y;\r\n      return m / m;\r\n    }\r\n    if (ux << 1 == 0) return x;\r\n    var uxi = ux;\r\n    if (!ex) {\r\n      ex -= builtin_clz<i64>(uxi << 12);\r\n      uxi <<= 1 - ex;\r\n    } else {\r\n      uxi &= <u64>-1 >> 12;\r\n      uxi |= 1 << 52;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<i64>(uy << 12);\r\n      uy <<= 1 - ey;\r\n    } else {\r\n      uy &= <u64>-1 >> 12;\r\n      uy |= 1 << 52;\r\n    }\r\n    var q: u32 = 0;\r\n    do {\r\n      if (ex < ey) {\r\n        if (ex + 1 == ey) break; // goto end\r\n        return x;\r\n      }\r\n      while (ex > ey) {\r\n        if (uxi >= uy) {\r\n          uxi -= uy;\r\n          ++q;\r\n        }\r\n        uxi <<= 1;\r\n        q <<= 1;\r\n        --ex;\r\n      }\r\n      if (uxi >= uy) {\r\n        uxi -= uy;\r\n        ++q;\r\n      }\r\n      if (uxi == 0) ex = -60;\r\n      else {\r\n        let shift = builtin_clz<i64>(uxi << 11);\r\n        ex -= shift;\r\n        uxi <<= shift;\r\n      }\r\n      break;\r\n    } while (false);\r\n    // end:\r\n    if (ex > 0) {\r\n      uxi -= 1 << 52;\r\n      uxi |= ex << 52;\r\n    } else {\r\n      uxi >>= -ex + 1;\r\n    }\r\n    x = reinterpret<f64>(uxi);\r\n    y = builtin_abs<f64>(y);\r\n    var x2 = x + x;\r\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\r\n      x -= y;\r\n      // ++q;\r\n    }\r\n    return sx ? -x : x;\r\n  }\r\n\r\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\r\n    var u = reinterpret<u64>(x);\r\n    var ix = <u32>(u >> 32);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3FE921FB) {  // |x| ~<= π/4\r\n      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\r\n        sincos_sin = x;\r\n        sincos_cos = 1;\r\n        return;\r\n      }\r\n      sincos_sin = sin_kern(x, 0, 0);\r\n      sincos_cos = cos_kern(x, 0);\r\n      return;\r\n    }\r\n    // sin(Inf or NaN) is NaN\r\n    if (ix >= 0x7F800000) {\r\n      let xx = x - x;\r\n      sincos_sin = xx;\r\n      sincos_cos = xx;\r\n      return;\r\n    }\r\n    // general argument reduction needed\r\n    var n = rempio2(x, u, sign);\r\n    var y0 = rempio2_y0;\r\n    var y1 = rempio2_y1;\r\n    var s = sin_kern(y0, y1, 1);\r\n    var c = cos_kern(y0, y1);\r\n    var sin = s, cos = c;\r\n    if (n & 1) {\r\n      sin =  c;\r\n      cos = -s;\r\n    }\r\n    if (n & 2) {\r\n      sin = -sin;\r\n      cos = -cos;\r\n    }\r\n    sincos_sin = sin;\r\n    sincos_cos = cos;\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy var rempio2f_y: f64;\r\n\r\n// @ts-ignore: decorator\r\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\r\n  0xA2F9836E4E441529,\r\n  0xFC2757D1F534DDC0,\r\n  0xDB6295993C439041,\r\n  0xFE5163ABDEBBC561\r\n]);\r\n\r\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\r\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\r\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\r\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\r\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\r\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\r\n  var p = z * (pS0 + z * (pS1 + z * pS2));\r\n  var q: f32 = 1 + z * qS1;\r\n  return p / q;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\r\n  const                                // see: musl/src/math/__expo2f.c\r\n    k    = <u32>235,\r\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\r\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\r\n  // in directed rounding correct sign before rounding or overflow is important\r\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\r\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); // π * 0x1p-65 = 8.51530395021638647334e-20\r\n\r\n  var offset = (u >> 23) - 152;\r\n  var shift  = <u64>(offset & 63);\r\n  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\r\n\r\n  var b0 = load<u64>(tblPtr, 0 << 3);\r\n  var b1 = load<u64>(tblPtr, 1 << 3);\r\n  var lo: u64;\r\n\r\n  if (shift > 32) {\r\n    let b2 = load<u64>(tblPtr, 2 << 3);\r\n    lo  = b2 >> (96 - shift);\r\n    lo |= b1 << (shift - 32);\r\n  } else {\r\n    lo = b1 >> (32 - shift);\r\n  }\r\n\r\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\r\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\r\n  var product = mantissa * hi + (mantissa * lo >> 32);\r\n  var r: i64 = product << 2;\r\n  var q = <i32>((product >> 62) + (r >>> 63));\r\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\r\n  return q;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\r\n  const pi2hi = reinterpret<f64>(0x3FF921FB50000000); // 1.57079631090164184570\r\n  const pi2lo = reinterpret<f64>(0x3E5110B4611A6263); // 1.58932547735281966916e-8\r\n  const _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\r\n\r\n  if (u < 0x4DC90FDB) { // π * 0x1p28\r\n    let q = nearest(x * _2_pi);\r\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\r\n    return <i32>q;\r\n  }\r\n\r\n  var q = pio2f_large_quot(x, u);\r\n  return select(-q, q, sign);\r\n}\r\n\r\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\r\n  const S1 = reinterpret<f64>(0xBFC5555554CBAC77); // -0x15555554cbac77.0p-55\r\n  const S2 = reinterpret<f64>(0x3F811110896EFBB2); //  0x111110896efbb2.0p-59\r\n  const S3 = reinterpret<f64>(0xBF2A00F9E2CAE774); // -0x1a00f9e2cae774.0p-65\r\n  const S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = S3 + z * S4;\r\n  var s = z * x;\r\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\r\n}\r\n\r\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\r\n  const C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81); // -0x1ffffffd0c5e81.0p-54\r\n  const C1 = reinterpret<f64>(0x3FA55553E1053A42); //  0x155553e1053a42.0p-57\r\n  const C2 = reinterpret<f64>(0xBF56C087E80F1E27); // -0x16c087e80f1e27.0p-62\r\n  const C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\r\n\r\n  var z = x * x;\r\n  var w = z * z;\r\n  var r = C2 + z * C3;\r\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\r\n}\r\n\r\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\r\n\r\n  const T0 = reinterpret<f64>(0x3FD5554D3418C99F); // 0x15554d3418c99f.0p-54\r\n  const T1 = reinterpret<f64>(0x3FC112FD38999F72); // 0x1112fd38999f72.0p-55\r\n  const T2 = reinterpret<f64>(0x3FAB54C91D865AFE); // 0x1b54c91d865afe.0p-57\r\n  const T3 = reinterpret<f64>(0x3F991DF3908C33CE); // 0x191df3908c33ce.0p-58\r\n  const T4 = reinterpret<f64>(0x3F685DADFCECF44E); // 0x185dadfcecf44e.0p-61\r\n  const T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\r\n\r\n  var z = x * x;\r\n  var r = T4 + z * T5;\r\n  var t = T2 + z * T3;\r\n  var w = z * z;\r\n  var s = z * x;\r\n  var u = T0 + z * T1;\r\n\r\n  r = (x + s * u) + (s * w) * (t + w * r);\r\n  return <f32>(odd ? -1 / r : r);\r\n}\r\n\r\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction log2f(x: f64): f64 {\r\n  const\r\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\r\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\r\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\r\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\r\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\r\n\r\n  var i = reinterpret<i64>(x);\r\n  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\r\n  x = reinterpret<f64>(i - (exponent << 52));\r\n  x = (x - 1) / (x + 1);\r\n  var xx = x * x;\r\n  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\r\n  return (2 * log2e) * y + <f64>exponent;\r\n}\r\n\r\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction exp2f(x: f64): f64 {\r\n  const\r\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\r\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\r\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\r\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\r\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\r\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\r\n\r\n  if (x < -1022) return 0;\r\n  if (x >= 1024) return Infinity;\r\n\r\n  var n = nearest(x);\r\n  x -= n;\r\n  var xx = x * x;\r\n  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\r\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\r\n}\r\n\r\nexport namespace NativeMathf {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const E       = <f32>NativeMath.E;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN2     = <f32>NativeMath.LN2;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LN10    = <f32>NativeMath.LN10;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG2E   = <f32>NativeMath.LOG2E;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const LOG10E  = <f32>NativeMath.LOG10E;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const PI      = <f32>NativeMath.PI;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export const SQRT2   = <f32>NativeMath.SQRT2;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_sin: f32 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  export var sincos_cos: f32 = 0;\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function abs(x: f32): f32 {\r\n    return builtin_abs<f32>(x);\r\n  }\r\n\r\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\r\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var hx = reinterpret<u32>(x);\r\n    var ix = hx & 0x7FFFFFFF;\r\n    if (ix >= 0x3F800000) {\r\n      if (ix == 0x3F800000) {\r\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\r\n        return 0;\r\n      }\r\n      return 0 / (x - x);\r\n    }\r\n    if (ix < 0x3F000000) {\r\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\r\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\r\n    }\r\n    var z: f32, w: f32, s: f32;\r\n    if (hx >> 31) {\r\n      // z = (1 + x) * 0.5;\r\n      z = 0.5 + x * 0.5;\r\n      s = builtin_sqrt<f32>(z);\r\n      w = Rf(z) * s - pio2_lo;\r\n      return 2 * (pio2_hi - (s + w));\r\n    }\r\n    // z = (1 - x) * 0.5;\r\n    z = 0.5 - x * 0.5;\r\n    s = builtin_sqrt<f32>(z);\r\n    hx = reinterpret<u32>(s);\r\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\r\n    var c = (z - df * df) / (s + df);\r\n    w = Rf(z) * s + c;\r\n    return 2 * (df + w);\r\n  }\r\n\r\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\r\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\r\n    var u = reinterpret<u32>(x);\r\n    var a = u & 0x7FFFFFFF;\r\n    if (a < 0x3F800000 + (1 << 23)) {\r\n      let xm1 = x - 1;\r\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\r\n    }\r\n    if (a < 0x3F800000 + (12 << 23)) return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\r\n    return log(x) + s;\r\n  }\r\n\r\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var sx = x;\r\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    if (hx >= 0x3F800000) {\r\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\r\n      return 0 / (x - x);\r\n    }\r\n    if (hx < 0x3F000000) {\r\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\r\n      return x + x * Rf(x * x);\r\n    }\r\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\r\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\r\n    var s = builtin_sqrt<f64>(z); // sic\r\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\r\n    return builtin_copysign(x, sx);\r\n  }\r\n\r\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\r\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\r\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\r\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\r\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\r\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\r\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\r\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\r\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\r\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\r\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\r\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\r\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\r\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\r\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\r\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\r\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\r\n      Ox1p_120f = reinterpret<f32>(0x03800000);\r\n    var ix = reinterpret<u32>(x);\r\n    var sx = x;\r\n    ix &= 0x7FFFFFFF;\r\n    var z: f32;\r\n    if (ix >= 0x4C800000) {\r\n      if (isNaN(x)) return x;\r\n      z = atanhi3 + Ox1p_120f;\r\n      return builtin_copysign(z, sx);\r\n    }\r\n    var id: i32;\r\n    if (ix < 0x3EE00000) {\r\n      if (ix < 0x39800000) return x;\r\n      id = -1;\r\n    } else {\r\n      x = builtin_abs<f32>(x);\r\n      if (ix < 0x3F980000) {\r\n        if (ix < 0x3F300000) {\r\n          id = 0;\r\n          x = (2.0 * x - 1.0) / (2.0 + x);\r\n        } else {\r\n          id = 1;\r\n          x = (x - 1.0) / (x + 1.0);\r\n        }\r\n      } else {\r\n        if (ix < 0x401C0000) {\r\n          id = 2;\r\n          x = (x - 1.5) / (1.0 + 1.5 * x);\r\n        } else {\r\n          id = 3;\r\n          x = -1.0 / x;\r\n        }\r\n      }\r\n    }\r\n    z = x * x;\r\n    var w = z * z;\r\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\r\n    var s2 = w * (aT1 + w * aT3);\r\n    var s3 = x * (s1 + s2);\r\n    if (id < 0) return x - s3;\r\n    switch (id) {\r\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\r\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\r\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\r\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\r\n      default: unreachable();\r\n    }\r\n    return builtin_copysign(z, sx);\r\n  }\r\n\r\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\r\n    var u = reinterpret<u32>(x);\r\n    var y = builtin_abs(x);\r\n    if (u < 0x3F800000 - (1 << 23)) {\r\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\r\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\r\n    return builtin_copysign(y, x);\r\n  }\r\n\r\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\r\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\r\n    if (isNaN(x) || isNaN(y)) return x + y;\r\n    var ix = reinterpret<u32>(x);\r\n    var iy = reinterpret<u32>(y);\r\n    if (ix == 0x3F800000) return atan(y);\r\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\r\n    ix &= 0x7FFFFFFF;\r\n    iy &= 0x7FFFFFFF;\r\n    if (iy == 0) {\r\n      switch (m) {\r\n        case 0:\r\n        case 1: return  y;\r\n        case 2: return  pi;\r\n        case 3: return -pi;\r\n      }\r\n    }\r\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\r\n    if (ix == 0x7F800000) {\r\n      if (iy == 0x7F800000) {\r\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\r\n        return m & 1 ? -t : t;\r\n      } else {\r\n        let t: f32 = m & 2 ? pi : 0.0;\r\n        return m & 1 ? -t : t;\r\n      }\r\n    }\r\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\r\n    var z: f32;\r\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\r\n    else z = atan(builtin_abs<f32>(y / x));\r\n    switch (m) {\r\n      case 0: return  z;\r\n      case 1: return -z;\r\n      case 2: return pi - (z - pi_lo);\r\n      case 3: return (z - pi_lo) - pi;\r\n    }\r\n    unreachable();\r\n    return 0;\r\n  }\r\n\r\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      B1      = <u32>709958130,\r\n      B2      = <u32>642849266,\r\n      Ox1p24f = reinterpret<f32>(0x4B800000);\r\n    var u = reinterpret<u32>(x);\r\n    var hx = u & 0x7FFFFFFF;\r\n    if (hx >= 0x7F800000) return x + x;\r\n    if (hx < 0x00800000) {\r\n      if (hx == 0) return x;\r\n      u = reinterpret<u32>(x * Ox1p24f);\r\n      hx = u & 0x7FFFFFFF;\r\n      hx = hx / 3 + B2;\r\n    } else {\r\n      hx = hx / 3 + B1;\r\n    }\r\n    u &= 0x80000000;\r\n    u |= hx;\r\n    var t = <f64>reinterpret<f32>(u);\r\n    var r = t * t * t;\r\n    t = t * (<f64>x + x + r) / (x + r + r);\r\n    r = t * t * t;\r\n    t = t * (<f64>x + x + r) / (x + r + r);\r\n    return <f32>t;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function ceil(x: f32): f32 {\r\n    return builtin_ceil<f32>(x);\r\n  }\r\n\r\n  export function clz32(x: f32): f32 {\r\n    if (!isFinite(x)) return 32;\r\n    return <f32>builtin_clz(dtoi32(x));\r\n  }\r\n\r\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\r\n    const c1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\r\n    const c2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\r\n    const c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\r\n    const c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\r\n      if (ix < 0x39800000) { // |x| < 2**-12\r\n        // raise inexact if x != 0\r\n        return 1;\r\n      }\r\n      return cos_kernf(x);\r\n    }\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {  // |x| ~<= 5π/4\r\n        if (ix > 0x4016CBE3) { // |x|  ~> 3π/4\r\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\r\n        } else {\r\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\r\n        }\r\n      }\r\n      if (ix <= 0x40E231D5) {  // |x| ~<= 9π/4\r\n        if (ix > 0x40AFEDDF) { // |x|  ~> 7π/4\r\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\r\n        } else {\r\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\r\n        }\r\n      }\r\n    }\r\n\r\n    // cos(Inf or NaN) is NaN\r\n    if (ix >= 0x7F800000) return x - x;\r\n\r\n    // general argument reduction needed\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n\r\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\r\n    return (n + 1) & 2 ? -t : t;\r\n  }\r\n\r\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    x = reinterpret<f32>(u);\r\n    if (u < 0x3F317217) {\r\n      if (u < 0x3F800000 - (12 << 23)) return 1;\r\n      let t = expm1(x);\r\n      // return 1 + t * t / (2 * (1 + t));\r\n      return 1 + t * t / (2 + 2 * t);\r\n    }\r\n    if (u < 0x42B17217) {\r\n      let t = exp(x);\r\n      // return 0.5 * (t + 1 / t);\r\n      return 0.5 * t + 0.5 / t;\r\n    }\r\n    return expo2f(x, 1);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function floor(x: f32): f32 {\r\n    return builtin_floor<f32>(x);\r\n  }\r\n\r\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return expf_lut(x);\r\n    } else {\r\n      const\r\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\r\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\r\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\r\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\r\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\r\n        Ox1p127f = reinterpret<f32>(0x7F000000);\r\n      let hx = reinterpret<u32>(x);\r\n      let sign_ = <i32>(hx >> 31);\r\n      hx &= 0x7FFFFFFF;\r\n      if (hx >= 0x42AEAC50) {\r\n        if (hx > 0x7F800000) return x; // NaN\r\n        if (hx >= 0x42B17218) {\r\n          if (!sign_) return x * Ox1p127f;\r\n          else if (hx >= 0x42CFF1B5) return 0;\r\n        }\r\n      }\r\n      let hi: f32, lo: f32;\r\n      let k: i32;\r\n      if (hx > 0x3EB17218) {\r\n        if (hx > 0x3F851592) {\r\n          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\r\n        } else {\r\n          k = 1 - (sign_ << 1);\r\n        }\r\n        hi = x - <f32>k * ln2hi;\r\n        lo = <f32>k * ln2lo;\r\n        x = hi - lo;\r\n      } else if (hx > 0x39000000) {\r\n        k = 0;\r\n        hi = x;\r\n        lo = 0;\r\n      } else {\r\n        return 1 + x;\r\n      }\r\n      let xx = x * x;\r\n      let c = x - xx * (P1 + xx * P2);\r\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\r\n      return k == 0 ? y : scalbn(y, k);\r\n    }\r\n  }\r\n\r\n  export function exp2(x: f32): f32 {\r\n    return exp2f_lut(x);\r\n  }\r\n\r\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      o_threshold = reinterpret<f32>(0x42B17180), //  8.8721679688e+01f\r\n      ln2_hi      = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\r\n      ln2_lo      = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\r\n      invln2      = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\r\n      Q1          = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\r\n      Q2          = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\r\n      Ox1p127f    = reinterpret<f32>(0x7F000000);\r\n    var u = reinterpret<u32>(x);\r\n    var hx = u & 0x7FFFFFFF;\r\n    var sign_ = <i32>(u >> 31);\r\n    if (hx >= 0x4195B844) {\r\n      if (hx > 0x7F800000) return x;\r\n      if (sign_) return -1;\r\n      if (x > o_threshold) {\r\n        x *= Ox1p127f;\r\n        return x;\r\n      }\r\n    }\r\n    var c: f32 = 0.0, t: f32, k: i32;\r\n    if (hx > 0x3EB17218) {\r\n      k = select<i32>(\r\n        1 - (sign_ << 1),\r\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\r\n        hx < 0x3F851592\r\n      );\r\n      t = <f32>k;\r\n      let hi = x - t * ln2_hi;\r\n      let lo = t * ln2_lo;\r\n      x = hi - lo;\r\n      c = (hi - x) - lo;\r\n    } else if (hx < 0x33000000) {\r\n      return x;\r\n    } else k = 0;\r\n    var hfx: f32 = 0.5 * x;\r\n    var hxs: f32 = x * hfx;\r\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\r\n    t  = 3.0 - r1 * hfx;\r\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\r\n    if (k == 0) return x - (x * e - hxs);\r\n    e  = x * (e - c) - c;\r\n    e -= hxs;\r\n    if (k == -1) return 0.5 * (x - e) - 0.5;\r\n    if (k == 1) {\r\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\r\n      return 1.0 + 2.0 * (x - e);\r\n    }\r\n    u = (0x7F + k) << 23;\r\n    var twopk = reinterpret<f32>(u);\r\n    var y: f32;\r\n    if (k < 0 || k > 56) {\r\n      y = x - e + 1.0;\r\n      if (k == 128) y = y * 2.0 * Ox1p127f;\r\n      else y = y * twopk;\r\n      return y - 1.0;\r\n    }\r\n    u = (0x7F - k) << 23;\r\n    y = reinterpret<f32>(u);\r\n    if (k < 20) y = (1 - y) - e;\r\n    else y = 1 - (e + y);\r\n    return (x + y) * twopk;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function fround(x: f32): f32 {\r\n    return x;\r\n  }\r\n\r\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\r\n    const\r\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\r\n      Ox1p_90f = reinterpret<f32>(0x12800000);\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    ux &= 0x7FFFFFFF;\r\n    uy &= 0x7FFFFFFF;\r\n    if (ux < uy) {\r\n      let ut = ux;\r\n      ux = uy;\r\n      uy = ut;\r\n    }\r\n    x = reinterpret<f32>(ux);\r\n    y = reinterpret<f32>(uy);\r\n    if (uy == 0xFF << 23) return y;\r\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\r\n    var z: f32 = 1;\r\n    if (ux >= (0x7F + 60) << 23) {\r\n      z  = Ox1p90f;\r\n      x *= Ox1p_90f;\r\n      y *= Ox1p_90f;\r\n    } else if (uy < (0x7F - 60) << 23) {\r\n      z  = Ox1p_90f;\r\n      x *= Ox1p90f;\r\n      y *= Ox1p90f;\r\n    }\r\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function imul(x: f32, y: f32): f32 {\r\n    /*\r\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\r\n     *\r\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\r\n     * our float-point arguments before actual convertion to integers.\r\n     */\r\n    if (!isFinite(x + y)) return 0;\r\n    return <f32>(dtoi32(x) * dtoi32(y));\r\n  }\r\n\r\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return logf_lut(x);\r\n    } else {\r\n      const\r\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\r\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\r\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\r\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\r\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\r\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\r\n        Ox1p25f = reinterpret<f32>(0x4C000000);\r\n      let u = reinterpret<u32>(x);\r\n      let k = 0;\r\n      if (u < 0x00800000 || <bool>(u >> 31)) {\r\n        if (u << 1 == 0) return -1 / (x * x);\r\n        if (u >> 31) return (x - x) / 0;\r\n        k -= 25;\r\n        x *= Ox1p25f;\r\n        u = reinterpret<u32>(x);\r\n      } else if (u >= 0x7F800000) {\r\n        return x;\r\n      } else if (u == 0x3F800000) {\r\n        return 0;\r\n      }\r\n      u += 0x3F800000 - 0x3F3504F3;\r\n      k += <u32>(<i32>u >> 23) - 0x7F;\r\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\r\n      x = reinterpret<f32>(u);\r\n      let f = x - 1.0;\r\n      let s = f / (2.0 + f);\r\n      let z = s * s;\r\n      let w = z * z;\r\n      let t1 = w * (Lg2 + w * Lg4);\r\n      let t2 = z * (Lg1 + w * Lg3);\r\n      let r = t2 + t1;\r\n      let hfsq = <f32>0.5 * f * f;\r\n      let dk = <f32>k;\r\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\r\n    }\r\n  }\r\n\r\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\r\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\r\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\r\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\r\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\r\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\r\n      Ox1p25f   = reinterpret<f32>(0x4C000000);\r\n    var ix = reinterpret<u32>(x);\r\n    var k = 0;\r\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\r\n      if (ix << 1 == 0) return -1 / (x * x);\r\n      if (ix >> 31) return (x - x) / 0.0;\r\n      k -= 25;\r\n      x *= Ox1p25f;\r\n      ix = reinterpret<u32>(x);\r\n    } else if (ix >= 0x7F800000) {\r\n      return x;\r\n    } else if (ix == 0x3F800000) {\r\n      return 0;\r\n    }\r\n    ix += 0x3F800000 - 0x3F3504F3;\r\n    k += <i32>(ix >> 23) - 0x7F;\r\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\r\n    x = reinterpret<f32>(ix);\r\n    var f = x - 1.0;\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var hi = f - hfsq;\r\n    ix = reinterpret<u32>(hi);\r\n    ix &= 0xFFFFF000;\r\n    hi = reinterpret<f32>(ix);\r\n    var lo = f - hi - hfsq + s * (hfsq + r);\r\n    var dk = <f32>k;\r\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\r\n  }\r\n\r\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\r\n    const\r\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\r\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\r\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\r\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\r\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\r\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\r\n    var ix = reinterpret<u32>(x);\r\n    var c: f32 = 0, f: f32 = 0;\r\n    var k: i32 = 1;\r\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\r\n      if (ix >= 0xBF800000) {\r\n        if (x == -1) return x / 0.0;\r\n        return (x - x) / 0.0;\r\n      }\r\n      if (ix << 1 < 0x33800000 << 1) return x;\r\n      if (ix <= 0xBE95F619) {\r\n        k = 0;\r\n        c = 0;\r\n        f = x;\r\n      }\r\n    } else if (ix >= 0x7F800000) return x;\r\n    if (k) {\r\n      let uf: f32 = 1 + x;\r\n      let iu = reinterpret<u32>(uf);\r\n      iu += 0x3F800000 - 0x3F3504F3;\r\n      k = <i32>(iu >> 23) - 0x7F;\r\n      if (k < 25) {\r\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\r\n        c /= uf;\r\n      } else c = 0;\r\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\r\n      f = reinterpret<f32>(iu) - 1;\r\n    }\r\n    var s = f / (2.0 + f);\r\n    var z = s * s;\r\n    var w = z * z;\r\n    var t1 = w * (Lg2 + w * Lg4);\r\n    var t2 = z * (Lg1 + w * Lg3);\r\n    var r = t2 + t1;\r\n    var hfsq: f32 = 0.5 * f * f;\r\n    var dk = <f32>k;\r\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\r\n  }\r\n\r\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      return log2f_lut(x);\r\n    } else {\r\n      const\r\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\r\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\r\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\r\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\r\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\r\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\r\n        Ox1p25f = reinterpret<f32>(0x4C000000);\r\n      let ix = reinterpret<u32>(x);\r\n      let k: i32 = 0;\r\n      if (ix < 0x00800000 || <bool>(ix >> 31)) {\r\n        if (ix << 1 == 0) return -1 / (x * x);\r\n        if (ix >> 31) return (x - x) / 0.0;\r\n        k -= 25;\r\n        x *= Ox1p25f;\r\n        ix = reinterpret<u32>(x);\r\n      } else if (ix >= 0x7F800000) {\r\n        return x;\r\n      } else if (ix == 0x3F800000) {\r\n        return 0;\r\n      }\r\n      ix += 0x3F800000 - 0x3F3504F3;\r\n      k += <i32>(ix >> 23) - 0x7F;\r\n      ix = (ix & 0x007FFFFF) + 0x3F3504F3;\r\n      x = reinterpret<f32>(ix);\r\n      let f = x - 1.0;\r\n      let s = f / (2.0 + f);\r\n      let z = s * s;\r\n      let w = z * z;\r\n      let t1 = w * (Lg2 + w * Lg4);\r\n      let t2 = z * (Lg1 + w * Lg3);\r\n      let r = t2 + t1;\r\n      let hfsq: f32 = 0.5 * f * f;\r\n      let hi = f - hfsq;\r\n      let u = reinterpret<u32>(hi);\r\n      u &= 0xFFFFF000;\r\n      hi = reinterpret<f32>(u);\r\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\r\n      let dk = <f32>k;\r\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function max(value1: f32, value2: f32): f32 {\r\n    return builtin_max<f32>(value1, value2);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function min(value1: f32, value2: f32): f32 {\r\n    return builtin_min<f32>(value1, value2);\r\n  }\r\n\r\n  export function pow(x: f32, y: f32): f32 {\r\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\r\n    if (builtin_abs<f32>(y) <= 2) {\r\n      if (y == 2.0) return x * x;\r\n      if (y == 0.5) {\r\n        return select<f32>(\r\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\r\n          Infinity,\r\n          x != -Infinity\r\n        );\r\n      }\r\n      if (y == -1.0) return 1 / x;\r\n      if (y == 1.0) return x;\r\n      if (y == 0.0) return 1.0;\r\n    }\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      // see: musl/src/math/powf.c\r\n      return powf_lut(x, y);\r\n    } else {\r\n      // based on:  jdh8/metallic/src/math/float/powf.c\r\n      if (y == 0) return 1;\r\n      // @ts-ignore: cast\r\n      if (isNaN(x) | isNaN(y)) {\r\n        return NaN;\r\n      }\r\n      let sign: u32 = 0;\r\n      let uy = reinterpret<u32>(y);\r\n      let ux = reinterpret<u32>(x);\r\n      let sx = ux >> 31;\r\n      ux &= 0x7FFFFFFF;\r\n      if (sx && nearest(y) == y) {\r\n        x = -x;\r\n        sx = 0;\r\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\r\n      }\r\n      let m: u32;\r\n      if (ux == 0x3F800000) { // x == 1\r\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\r\n      } else if (ux == 0) {\r\n        m = uy >> 31 ? 0x7F800000 : 0;\r\n      } else if (ux == 0x7F800000) {\r\n        m = uy >> 31 ? 0 : 0x7F800000;\r\n      } else if (sx) {\r\n        m = 0x7FC00000;\r\n      } else {\r\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\r\n      }\r\n      return reinterpret<f32>(m | sign);\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function seedRandom(value: i64): void {\r\n    NativeMath.seedRandom(value);\r\n  }\r\n\r\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\r\n  export function random(): f32 {\r\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\r\n\r\n    var s0 = random_state0_32;\r\n    var s1 = random_state1_32;\r\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\r\n\r\n    s1 ^= s0;\r\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\r\n    random_state1_32 = rotl<u32>(s1, 13);\r\n\r\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function round(x: f32): f32 {\r\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sign(x: f32): f32 {\r\n    if (ASC_SHRINK_LEVEL > 0) {\r\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\r\n    } else {\r\n      return x > 0 ? 1 : x < 0 ? -1 : x;\r\n    }\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function signbit(x: f32): bool {\r\n    return <bool>(reinterpret<u32>(x) >>> 31);\r\n  }\r\n\r\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\r\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // M_PI_2 * 1\r\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // M_PI_2 * 2\r\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // M_PI_2 * 3\r\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\r\n      if (ix < 0x39800000) { // |x| < 2**-12\r\n        return x;\r\n      }\r\n      return sin_kernf(x);\r\n    }\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\r\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\r\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\r\n        }\r\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\r\n      }\r\n\r\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\r\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\r\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\r\n        }\r\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\r\n      }\r\n    }\r\n\r\n    // sin(Inf or NaN) is NaN\r\n    if (ix >= 0x7F800000) return x - x;\r\n\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n\r\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\r\n    return n & 2 ? -t : t;\r\n  }\r\n\r\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\r\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\r\n    var absx = reinterpret<f32>(u);\r\n    var h = builtin_copysign<f32>(0.5, x);\r\n    if (u < 0x42B17217) {\r\n      let t = expm1(absx);\r\n      if (u < 0x3F800000) {\r\n        if (u < 0x3F800000 - (12 << 23)) return x;\r\n        return h * (2 * t - t * t / (t + 1));\r\n      }\r\n      return h * (t + t / (t + 1));\r\n    }\r\n    return expo2f(absx, 2 * h);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function sqrt(x: f32): f32 {\r\n    return builtin_sqrt<f32>(x);\r\n  }\r\n\r\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\r\n    const t1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\r\n    const t2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\r\n    const t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\r\n    const t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\r\n      if (ix < 0x39800000) { // |x| < 2**-12\r\n        return x;\r\n      }\r\n      return tan_kernf(x, 0);\r\n    }\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\r\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\r\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\r\n        } else {\r\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\r\n        }\r\n      }\r\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\r\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\r\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\r\n        } else {\r\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    // tan(Inf or NaN) is NaN\r\n    if (ix >= 0x7F800000) return x - x;\r\n\r\n    // argument reduction\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n    return tan_kernf(y, n & 1);\r\n  }\r\n\r\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\r\n    var u = reinterpret<u32>(x);\r\n    u &= 0x7FFFFFFF;\r\n    var y = reinterpret<f32>(u);\r\n    var t: f32;\r\n    if (u > 0x3F0C9F54) {\r\n      if (u > 0x41200000) t = 1 + 0 / y;\r\n      else {\r\n        t = expm1(2 * y);\r\n        t = 1 - 2 / (t + 2);\r\n      }\r\n    } else if (u > 0x3E82C578) {\r\n      t = expm1(2 * y);\r\n      t = t / (t + 2);\r\n    } else if (u >= 0x00800000) {\r\n      t = expm1(-2 * y);\r\n      t = -t / (t + 2);\r\n    } else t = y;\r\n    return builtin_copysign<f32>(t, x);\r\n  }\r\n\r\n  // @ts-ignore: decorator\r\n  @inline\r\n  export function trunc(x: f32): f32 {\r\n    return builtin_trunc<f32>(x);\r\n  }\r\n\r\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\r\n    const\r\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\r\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\r\n      Ox1p_126f = reinterpret<f32>(0x00800000);\r\n    var y = x;\r\n    if (n > 127) {\r\n      y *= Ox1p127f;\r\n      n -= 127;\r\n      if (n > 127) {\r\n        y *= Ox1p127f;\r\n        n = builtin_min<i32>(n - 127, 127);\r\n      }\r\n    } else if (n < -126) {\r\n      y *= Ox1p_126f * Ox1p24f;\r\n      n += 126 - 24;\r\n      if (n < -126) {\r\n        y *= Ox1p_126f * Ox1p24f;\r\n        n = builtin_max<i32>(n + 126 - 24, -126);\r\n      }\r\n    }\r\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\r\n  }\r\n\r\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\r\n    if (builtin_abs<f32>(y) == 1.0) {\r\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\r\n      // TODO: move this rule to compiler's optimization pass.\r\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\r\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\r\n    }\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    var ex = <i32>(ux >> 23 & 0xFF);\r\n    var ey = <i32>(uy >> 23 & 0xFF);\r\n    var sm = ux & 0x80000000;\r\n    var uy1 = uy << 1;\r\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\r\n      let m = x * y;\r\n      return m / m;\r\n    }\r\n    var ux1 = ux << 1;\r\n    if (ux1 <= uy1) {\r\n      return x * f32(ux1 != uy1);\r\n    }\r\n    if (!ex) {\r\n      ex -= builtin_clz<u32>(ux << 9);\r\n      ux <<= 1 - ex;\r\n    } else {\r\n      ux &= <u32>-1 >> 9;\r\n      ux |= 1 << 23;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<u32>(uy << 9);\r\n      uy <<= 1 - ey;\r\n    } else {\r\n      uy &= <u32>-1 >> 9;\r\n      uy |= 1 << 23;\r\n    }\r\n    while (ex > ey) {\r\n      if (ux >= uy) {\r\n        if (ux == uy) return 0 * x;\r\n        ux -= uy;\r\n      }\r\n      ux <<= 1;\r\n      --ex;\r\n    }\r\n    if (ux >= uy) {\r\n      if (ux == uy) return 0 * x;\r\n      ux -= uy;\r\n    }\r\n    // for (; !(ux >> 23); ux <<= 1) --ex;\r\n    var shift = <i32>builtin_clz<u32>(ux << 8);\r\n    ex -= shift;\r\n    ux <<= shift;\r\n    if (ex > 0) {\r\n      ux -= 1 << 23;\r\n      ux |= <u32>ex << 23;\r\n    } else {\r\n      ux >>= -ex + 1;\r\n    }\r\n    return reinterpret<f32>(ux | sm);\r\n  }\r\n\r\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\r\n    var ux = reinterpret<u32>(x);\r\n    var uy = reinterpret<u32>(y);\r\n    var ex = <i32>(ux >> 23 & 0xFF);\r\n    var ey = <i32>(uy >> 23 & 0xFF);\r\n    var sx = <i32>(ux >> 31);\r\n    var uxi = ux;\r\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\r\n    if (ux << 1 == 0) return x;\r\n    if (!ex) {\r\n      ex -= builtin_clz<u32>(uxi << 9);\r\n      uxi <<= 1 - ex;\r\n    } else {\r\n      uxi &= <u32>-1 >> 9;\r\n      uxi |= 1 << 23;\r\n    }\r\n    if (!ey) {\r\n      ey -= builtin_clz<u32>(uy << 9);\r\n      uy <<= 1 - ey;\r\n    } else {\r\n      uy &= <u32>-1 >> 9;\r\n      uy |= 1 << 23;\r\n    }\r\n    var q = 0;\r\n    do {\r\n      if (ex < ey) {\r\n        if (ex + 1 == ey) break; // goto end\r\n        return x;\r\n      }\r\n      while (ex > ey) {\r\n        if (uxi >= uy) {\r\n          uxi -= uy;\r\n          ++q;\r\n        }\r\n        uxi <<= 1;\r\n        q <<= 1;\r\n        --ex;\r\n      }\r\n      if (uxi >= uy) {\r\n        uxi -= uy;\r\n        ++q;\r\n      }\r\n      if (uxi == 0) ex = -30;\r\n      else {\r\n        let shift = builtin_clz<i32>(uxi << 8);\r\n        ex -= shift;\r\n        uxi <<= shift;\r\n      }\r\n      break;\r\n    } while (false);\r\n    // end:\r\n    if (ex > 0) {\r\n      uxi -= 1 << 23;\r\n      uxi |= <u32>ex << 23;\r\n    } else {\r\n      uxi >>= -ex + 1;\r\n    }\r\n    x = reinterpret<f32>(uxi);\r\n    y = builtin_abs<f32>(y);\r\n    var x2 = x + x;\r\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\r\n      x -= y;\r\n      // q++;\r\n    }\r\n    return sx ? -x : x;\r\n  }\r\n\r\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\r\n    const s1pio2 = reinterpret<f64>(0x3FF921FB54442D18); // 1 * M_PI_2\r\n    const s2pio2 = reinterpret<f64>(0x400921FB54442D18); // 2 * M_PI_2\r\n    const s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2); // 3 * M_PI_2\r\n    const s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\r\n\r\n    var ix = reinterpret<u32>(x);\r\n    var sign = ix >> 31;\r\n    ix &= 0x7FFFFFFF;\r\n\r\n    if (ix <= 0x3F490FDA) {  // |x| ~<= π/4\r\n      if (ix < 0x39800000) { // |x| < 2**-12\r\n        sincos_sin = x;\r\n        sincos_cos = 1;\r\n        return;\r\n      }\r\n      sincos_sin = sin_kernf(x);\r\n      sincos_cos = cos_kernf(x);\r\n      return;\r\n    }\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5π/4\r\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3π/4\r\n          if (sign) {\r\n            sincos_sin = -cos_kernf(x + s1pio2);\r\n            sincos_cos =  sin_kernf(x + s1pio2);\r\n          } else {\r\n            sincos_sin = cos_kernf(s1pio2 - x);\r\n            sincos_cos = sin_kernf(s1pio2 - x);\r\n          }\r\n          return;\r\n        }\r\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\r\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\r\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\r\n        return;\r\n      }\r\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9π/4\r\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7π/4\r\n          if (sign) {\r\n            sincos_sin =  cos_kernf(x + s3pio2);\r\n            sincos_cos = -sin_kernf(x + s3pio2);\r\n          } else {\r\n            sincos_sin = -cos_kernf(x - s3pio2);\r\n            sincos_cos =  sin_kernf(x - s3pio2);\r\n          }\r\n          return;\r\n        }\r\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\r\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\r\n        return;\r\n      }\r\n    }\r\n    // sin(Inf or NaN) is NaN\r\n    if (ix >= 0x7F800000) {\r\n      let xx = x - x;\r\n      sincos_sin = xx;\r\n      sincos_cos = xx;\r\n      return;\r\n    }\r\n    // general argument reduction needed\r\n    var n = rempio2f(x, ix, sign);\r\n    var y = rempio2f_y;\r\n    var s = sin_kernf(y);\r\n    var c = cos_kernf(y);\r\n    var sin = s, cos = c;\r\n    if (n & 1) {\r\n      sin =  c;\r\n      cos = -s;\r\n    }\r\n    if (n & 2) {\r\n      sin = -sin;\r\n      cos = -cos;\r\n    }\r\n    sincos_sin = sin;\r\n    sincos_cos = cos;\r\n  }\r\n}\r\n\r\nexport function ipow32(x: i32, e: i32): i32 {\r\n  var out = 1;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (e <= 0) {\r\n      if (x == -1) return select<i32>(-1, 1, e & 1);\r\n      return i32(e == 0) | i32(x == 1);\r\n    }\r\n    else if (e == 1) return x;\r\n    else if (e == 2) return x * x;\r\n    else if (e < 32) {\r\n      let log = 32 - clz(e);\r\n      // 32 = 2 ^ 5, so need only five cases.\r\n      // But some extra cases needs for properly overflowing\r\n      switch (log) {\r\n        case 5: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 4: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 3: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 2: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 1: {\r\n          if (e & 1) out *= x;\r\n        }\r\n      }\r\n      return out;\r\n    }\r\n  }\r\n  while (e) {\r\n    if (e & 1) out *= x;\r\n    e >>>= 1;\r\n    x *= x;\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function ipow64(x: i64, e: i64): i64 {\r\n  var out: i64 = 1;\r\n  if (ASC_SHRINK_LEVEL < 1) {\r\n    if (e <= 0) {\r\n      if (x == -1) return select<i64>(-1, 1, e & 1);\r\n      return i64(e == 0) | i64(x == 1);\r\n    }\r\n    else if (e == 1) return x;\r\n    else if (e == 2) return x * x;\r\n    else if (e < 64) {\r\n      let log = 64 - <i32>clz(e);\r\n      // 64 = 2 ^ 6, so need only six cases.\r\n      // But some extra cases needs for properly overflowing\r\n      switch (log) {\r\n        case 6: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 5: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 4: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 3: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 2: {\r\n          if (e & 1) out *= x;\r\n          e >>>= 1;\r\n          x *= x;\r\n        }\r\n        case 1: {\r\n          if (e & 1) out *= x;\r\n        }\r\n      }\r\n      return out;\r\n    }\r\n  }\r\n  while (e) {\r\n    if (e & 1) out *= x;\r\n    e >>>= 1;\r\n    x *= x;\r\n  }\r\n  return out;\r\n}\r\n\r\n/*\r\nTODO:\r\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\r\nwhich usually faster than exponentiation by squaring\r\n\r\nfor ipow32 and e < 32:\r\n\r\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\r\nswitch (e) {\r\n  case  1: return x;\r\n  case  2: return x * x;\r\n  case  3: return x * x * x;\r\n  case  4: return (b = x * x) * b;\r\n  case  5: return (b = x * x) * b * x;\r\n  case  6: return (b = x * x) * b * b;\r\n  case  7: return (b = x * x) * b * b * x;\r\n  case  8: return (d = (b = x * x) * b) * d;\r\n  case  9: return (c = x * x * x) * c * c;\r\n  case 10: return (d = (b = x * x) * b) * d * b;\r\n  case 11: return (d = (b = x * x) * b) * d * b * x;\r\n  case 12: return (d = (b = x * x) * b) * d * d;\r\n  case 13: return (d = (b = x * x) * b) * d * d * x;\r\n  case 14: return (d = (b = x * x) * b) * d * d * b;\r\n  case 15: return (k = (b = x * x) * b * x) * k * k;\r\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\r\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\r\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\r\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\r\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\r\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\r\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\r\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\r\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\r\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\r\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\r\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\r\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\r\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\r\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\r\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\r\n}\r\n\r\nfor ipow64: TODO\r\nswitch (e) {\r\n  case 32:\r\n  ...\r\n  case 63:\r\n}\r\n*/\r\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\r\nimport { strtol } from \"./util/string\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin @inline\r\nexport const NaN: f64 = 0 / 0;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @inline\r\nexport const Infinity: f64 = 1 / 0;\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare function isNaN<T extends number>(value: T): bool;\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare function isFinite<T extends number>(value: T): bool;\r\n\r\n@final @unmanaged\r\nexport abstract class I8 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i8 {\r\n    return <i8>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i8, radix: i32 = 10): String {\r\n    return itoa32(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class I16 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i16 {\r\n    return <i16>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i16, radix: i32 = 10): String {\r\n    return itoa32(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class I32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i32 {\r\n    return <i32>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: i32, radix: i32 = 10): String {\r\n    return itoa32(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class I64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): i64 {\r\n    return strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: i64, radix: i32 = 10): String {\r\n    return itoa64(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class Isize {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): isize {\r\n    return <isize>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: isize, radix: i32 = 10): String {\r\n    if (sizeof<isize>() == 4) {\r\n      return itoa32(<i32>this, radix);\r\n    } else {\r\n      return itoa64(<i64>this, radix);\r\n    }\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class U8 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u8 {\r\n    return <u8>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u8, radix: i32 = 10): String {\r\n    return utoa32(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class U16 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u16 {\r\n    return <u16>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u16, radix: i32 = 10): String {\r\n    return utoa32(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class U32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u32 {\r\n    return <u32>strtol<i32>(value, radix);\r\n  }\r\n\r\n  toString(this: u32, radix: i32 = 10): String {\r\n    return utoa32(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class U64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): u64 {\r\n    return <u64>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: u64, radix: i32 = 10): String {\r\n    return utoa64(this, radix);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class Usize {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\r\n\r\n  static parseInt(value: string, radix: i32 = 0): usize {\r\n    return <usize>strtol<i64>(value, radix);\r\n  }\r\n\r\n  toString(this: usize, radix: i32 = 10): String {\r\n    if (sizeof<usize>() == 4) {\r\n      return utoa32(<u32>this, radix);\r\n    } else {\r\n      return utoa64(<u64>this, radix);\r\n    }\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class Bool {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\r\n\r\n  toString(this: bool, radix: i32 = 0): String {\r\n    return this ? \"true\" : \"false\";\r\n  }\r\n}\r\n\r\nexport { Bool as Boolean };\r\n\r\n@final @unmanaged\r\nexport abstract class F32 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly EPSILON: f32 = f32.EPSILON;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NaN: f32 = f32.NaN;\r\n\r\n  static isNaN(value: f32): bool {\r\n    return isNaN<f32>(value);\r\n  }\r\n\r\n  static isFinite(value: f32): bool {\r\n    return isFinite<f32>(value);\r\n  }\r\n\r\n  static isSafeInteger(value: f32): bool {\r\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\r\n  }\r\n\r\n  static isInteger(value: f32): bool {\r\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\r\n  }\r\n\r\n  static parseInt(value: string, radix: i32 = 0): f32 {\r\n    return <f32>strtol<f64>(value, radix);\r\n  }\r\n\r\n  static parseFloat(value: string): f32 {\r\n    return <f32>parseFloat(value);\r\n  }\r\n\r\n  toString(this: f32, radix: i32 = 0): String {\r\n    return dtoa(this);\r\n  }\r\n}\r\n\r\n@final @unmanaged\r\nexport abstract class F64 {\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly EPSILON: f64 = f64.EPSILON;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly NaN: f64 = f64.NaN;\r\n\r\n  static isNaN(value: f64): bool {\r\n    return isNaN<f64>(value);\r\n  }\r\n\r\n  static isFinite(value: f64): bool {\r\n    return isFinite<f64>(value);\r\n  }\r\n\r\n  static isSafeInteger(value: f64): bool {\r\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\r\n  }\r\n\r\n  static isInteger(value: f64): bool {\r\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\r\n  }\r\n\r\n  static parseInt(value: string, radix: i32 = 0): f64 {\r\n    return strtol<f64>(value, radix);\r\n  }\r\n\r\n  static parseFloat(value: string): f64 {\r\n    return parseFloat(value);\r\n  }\r\n\r\n  toString(this: f64, radix: i32 = 0): String {\r\n    return dtoa(this);\r\n  }\r\n}\r\n\r\nexport { F64 as Number };\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\r\nimport { COMPARATOR, SORT } from \"./util/sort\";\r\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\r\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\r\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\r\n\r\n/** Ensures that the given array has _at least_ the specified backing size. */\r\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\r\n  // depends on the fact that Arrays mimic ArrayBufferView\r\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\r\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\r\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\r\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\r\n    let newCapacity = minSize << alignLog2;\r\n    let newData = __renew(oldData, newCapacity);\r\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\r\n    if (newData !== oldData) { // oldData has been free'd\r\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\r\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\r\n      // new buffer inherits old buffer's state, so no need to link\r\n    }\r\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\r\n  }\r\n}\r\n\r\nexport class Array<T> {\r\n  [key: number]: T;\r\n\r\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\r\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\r\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\r\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\r\n\r\n  private buffer: ArrayBuffer;\r\n  private dataStart: usize;\r\n  private byteLength: i32;\r\n\r\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\r\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\r\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\r\n\r\n  private length_: i32;\r\n\r\n  static isArray<U>(value: U): bool {\r\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\r\n  }\r\n\r\n  static create<T>(capacity: i32 = 0): Array<T> {\r\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\r\n    var array = new Array<T>(capacity);\r\n    array.length = 0;\r\n    return array;\r\n  }\r\n\r\n  constructor(length: i32 = 0) {\r\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\r\n    var bufferSize = <usize>length << alignof<T>();\r\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\r\n    memory.fill(changetype<usize>(buffer), 0, bufferSize);\r\n    this.buffer = buffer; // links\r\n    this.dataStart = changetype<usize>(buffer);\r\n    this.byteLength = <i32>bufferSize;\r\n    this.length_ = length;\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.length_;\r\n  }\r\n\r\n  set length(newLength: i32) {\r\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n    this.length_ = newLength;\r\n  }\r\n\r\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  @operator(\"[]\") private __get(index: i32): T {\r\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    var value = this.__uget(index);\r\n    if (isReference<T>()) {\r\n      if (!isNullable<T>()) {\r\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\r\n      }\r\n    }\r\n    return value;\r\n  }\r\n\r\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\r\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\r\n  }\r\n\r\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\r\n    if (<u32>index >= <u32>this.length_) {\r\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\r\n      ensureSize(changetype<usize>(this), index + 1, alignof<T>());\r\n      this.length_ = index + 1;\r\n    }\r\n    this.__uset(index, value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\r\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\r\n    if (isManaged<T>()) {\r\n      __link(changetype<usize>(this), changetype<usize>(value), true);\r\n    }\r\n  }\r\n\r\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\r\n    var dataStart = this.dataStart;\r\n    var length = this.length_;\r\n    start = start < 0 ? max(length + start, 0) : min(start, length);\r\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\r\n    if (isManaged<T>()) {\r\n      for (; start < end; ++start) {\r\n        store<usize>(dataStart + (<usize>start << alignof<T>()), changetype<usize>(value));\r\n        __link(changetype<usize>(this), changetype<usize>(value), true);\r\n      }\r\n    } else if (sizeof<T>() == 1) {\r\n      if (start < end) {\r\n        memory.fill(\r\n          dataStart + <usize>start,\r\n          u8(value),\r\n          <usize>(end - start)\r\n        );\r\n      }\r\n    } else {\r\n      for (; start < end; ++start) {\r\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  includes(value: T, fromIndex: i32 = 0): bool {\r\n    if (isFloat<T>()) {\r\n      let length = this.length_;\r\n      if (length == 0 || fromIndex >= length) return false;\r\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n      let dataStart = this.dataStart;\r\n      while (fromIndex < length) {\r\n        let elem = load<T>(dataStart + (<usize>fromIndex << alignof<T>()));\r\n        // @ts-ignore\r\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\r\n        ++fromIndex;\r\n      }\r\n      return false;\r\n    } else {\r\n      return this.indexOf(value, fromIndex) >= 0;\r\n    }\r\n  }\r\n\r\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\r\n    var length = this.length_;\r\n    if (length == 0 || fromIndex >= length) return -1;\r\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\r\n    var dataStart = this.dataStart;\r\n    while (fromIndex < length) {\r\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\r\n    var length = this.length_;\r\n    if (length == 0) return -1;\r\n    if (fromIndex < 0) fromIndex = length + fromIndex;\r\n    else if (fromIndex >= length) fromIndex = length - 1;\r\n    var dataStart = this.dataStart;\r\n    while (fromIndex >= 0) {\r\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  push(value: T): i32 {\r\n    var length = this.length_;\r\n    var newLength = length + 1;\r\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n    if (isManaged<T>()) {\r\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), changetype<usize>(value));\r\n      __link(changetype<usize>(this), changetype<usize>(value), true);\r\n    } else {\r\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\r\n    }\r\n    this.length_ = newLength;\r\n    return newLength;\r\n  }\r\n\r\n  concat(other: Array<T>): Array<T> {\r\n    var thisLen = this.length_;\r\n    var otherLen = select(0, other.length_, other === null);\r\n    var outLen = thisLen + otherLen;\r\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\r\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\r\n    var outStart = out.dataStart;\r\n    var thisSize = <usize>thisLen << alignof<T>();\r\n    if (isManaged<T>()) {\r\n      let thisStart = this.dataStart;\r\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(thisStart + offset);\r\n        store<usize>(outStart + offset, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n      outStart += thisSize;\r\n      let otherStart = other.dataStart;\r\n      let otherSize = <usize>otherLen << alignof<T>();\r\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\r\n        let ref = load<usize>(otherStart + offset);\r\n        store<usize>(outStart + offset, ref);\r\n        __link(changetype<usize>(out), ref, true);\r\n      }\r\n    } else {\r\n      memory.copy(outStart, this.dataStart, thisSize);\r\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\r\n    }\r\n    return out;\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\r\n    var dataStart = this.dataStart;\r\n    var len = this.length_;\r\n\r\n    end = min<i32>(end, len);\r\n\r\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n    var count = min(last - from, len - to);\r\n\r\n    memory.copy( // is memmove\r\n      dataStart + (<usize>to << alignof<T>()),\r\n      dataStart + (<usize>from << alignof<T>()),\r\n      <usize>count << alignof<T>()\r\n    );\r\n    return this;\r\n  }\r\n\r\n  pop(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\r\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\r\n    this.length_ = length;\r\n    return element;\r\n  }\r\n\r\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n    }\r\n  }\r\n\r\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\r\n    var length = this.length_;\r\n    var out = changetype<Array<U>>(__newArray(length, alignof<U>(), idof<Array<U>>()));\r\n    var outStart = out.dataStart;\r\n    for (let index = 0; index < min(length, this.length_); ++index) {\r\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n      store<U>(outStart + (<usize>index << alignof<U>()), result);\r\n      if (isManaged<U>()) {\r\n        __link(changetype<usize>(out), changetype<usize>(result), true);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\r\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\r\n      if (fn(value, index, this)) result.push(value);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  reduce<U>(\r\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  reduceRight<U>(\r\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\r\n    initialValue: U\r\n  ): U {\r\n    var accum = initialValue;\r\n    for (let index = this.length_ - 1; index >= 0; --index) {\r\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\r\n    }\r\n    return accum;\r\n  }\r\n\r\n  shift(): T {\r\n    var length = this.length_;\r\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\r\n    var base = this.dataStart;\r\n    var element = load<T>(base);\r\n    var lastIndex = length - 1;\r\n    memory.copy(\r\n      base,\r\n      base + sizeof<T>(),\r\n      <usize>lastIndex << alignof<T>()\r\n    );\r\n    if (isReference<T>()) {\r\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\r\n    } else {\r\n      // @ts-ignore\r\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\r\n    }\r\n    this.length_ = lastIndex;\r\n    return element;\r\n  }\r\n\r\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\r\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\r\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  unshift(value: T): i32 {\r\n    var newLength = this.length_ + 1;\r\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\r\n    var dataStart = this.dataStart;\r\n    memory.copy(\r\n      dataStart + sizeof<T>(),\r\n      dataStart,\r\n      <usize>(newLength - 1) << alignof<T>()\r\n    );\r\n    store<T>(dataStart, value);\r\n    if (isManaged<T>()) {\r\n      __link(changetype<usize>(this), changetype<usize>(value), true);\r\n    }\r\n    this.length_ = newLength;\r\n    return newLength;\r\n  }\r\n\r\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length = this.length_;\r\n    start = start < 0 ? max(start + length, 0) : min(start, length);\r\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\r\n    length = max(end - start, 0);\r\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\r\n    var sliceBase = slice.dataStart;\r\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\r\n    if (isManaged<T>()) {\r\n      let off = <usize>0;\r\n      let end = <usize>length << alignof<usize>();\r\n      while (off < end) {\r\n        let ref = load<usize>(thisBase + off);\r\n        store<usize>(sliceBase + off, ref);\r\n        __link(changetype<usize>(slice), ref, true);\r\n        off += sizeof<usize>();\r\n      }\r\n    } else {\r\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\r\n    }\r\n    return slice;\r\n  }\r\n\r\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\r\n    var length  = this.length_;\r\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\r\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\r\n    var result = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>())); \r\n    var resultStart = result.dataStart;\r\n    var thisStart = this.dataStart;\r\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\r\n    memory.copy(\r\n      resultStart,\r\n      thisBase,\r\n      <usize>deleteCount << alignof<T>()\r\n    );\r\n    var offset = start + deleteCount;\r\n    if (length != offset) {\r\n      memory.copy(\r\n        thisBase,\r\n        thisStart + (<usize>offset << alignof<T>()),\r\n        <usize>(length - offset) << alignof<T>()\r\n      );\r\n    }\r\n    this.length_ = length - deleteCount;\r\n    return result;\r\n  }\r\n\r\n  reverse(): Array<T> {\r\n    var length = this.length_;\r\n    if (length) {\r\n      let front = this.dataStart;\r\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\r\n      while (front < back) {\r\n        let temp = load<T>(front);\r\n        store<T>(front, load<T>(back));\r\n        store<T>(back, temp);\r\n        front += sizeof<T>();\r\n        back -= sizeof<T>();\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\r\n    var length = this.length_;\r\n    if (length <= 1) return this;\r\n    var base = this.dataStart;\r\n    if (length == 2) {\r\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\r\n      let b: T = load<T>(base); // b = arr[0]\r\n      if (comparator(a, b) < 0) {\r\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\r\n        store<T>(base, a); // arr[0] = a;\r\n      }\r\n      return this;\r\n    }\r\n    SORT<T>(base, length, comparator);\r\n    return this;\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    var dataStart = this.dataStart;\r\n    var length = this.length_;\r\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\r\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\r\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\r\n\r\n    if (ASC_SHRINK_LEVEL < 1) {\r\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\r\n    }\r\n    // For rest objects and arrays use general join routine\r\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\r\n    ERROR(\"unspported element type\");\r\n    return <string>unreachable();\r\n  }\r\n\r\n  flat(): T {\r\n    if (!isArray<T>()) {\r\n      throw new TypeError(E_ILLEGALGENTYPE);\r\n    }\r\n    // Get the length and data start values\r\n    var length = this.length_;\r\n    var selfDataStart = this.dataStart;\r\n\r\n    // calculate the end size with an initial pass\r\n    var size = 0;\r\n    for (let i = 0; i < length; i++) {\r\n      let child = load<usize>(selfDataStart + (i << alignof<T>()));\r\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\r\n    }\r\n\r\n    // calculate the byteLength of the resulting backing ArrayBuffer\r\n    var byteLength = <usize>size << usize(alignof<valueof<T>>());\r\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\r\n\r\n    // create the return value and initialize it\r\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\r\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\r\n\r\n    // byteLength, dataStart, and buffer are all readonly\r\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\r\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\r\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\r\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\r\n\r\n    // set the elements\r\n    var resultOffset: usize = 0;\r\n    for (let i = 0; i < length; i++) { // for each child\r\n      let child = load<usize>(selfDataStart + (<usize>i << alignof<T>()));\r\n\r\n      // ignore null arrays\r\n      if (child == 0) continue;\r\n\r\n      // copy the underlying buffer data to the result buffer\r\n      let childDataLength = load<i32>(child, offsetof<T>(\"byteLength\"));\r\n      memory.copy(\r\n        changetype<usize>(outBuffer) + resultOffset,\r\n        load<usize>(child, offsetof<T>(\"dataStart\")),\r\n        <usize>childDataLength\r\n      );\r\n\r\n      // advance the result length\r\n      resultOffset += childDataLength;\r\n    }\r\n\r\n    // if the `valueof<T>` type is managed, we must link each reference\r\n    if (isManaged<valueof<T>>()) {\r\n      for (let i = 0; i < size; i++) {\r\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\r\n        __link(changetype<usize>(outBuffer), ref, true);\r\n      }\r\n    }\r\n\r\n    return outArray;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  // RT integration\r\n\r\n  @unsafe private __visit(cookie: u32): void {\r\n    if (isManaged<T>()) {\r\n      let cur = this.dataStart;\r\n      let end = cur + (<usize>this.length_ << alignof<T>());\r\n      while (cur < end) {\r\n        let val = load<usize>(cur);\r\n        if (val) __visit(val, cookie);\r\n        cur += sizeof<usize>();\r\n      }\r\n    }\r\n    __visit(changetype<usize>(this.buffer), cookie);\r\n  }\r\n}\r\n","import { performance, commonRandomJS } from './common'\r\n\r\n// classes\r\nclass Polar {\r\n  constructor(public r: f64, public i: f64) {}\r\n}\r\n\r\nclass PolarArray {\r\n  constructor(public r: StaticArray<f64>, public i: StaticArray<f64>) {}\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction complexPolar(r: f64, t: f64): Polar {\r\n  NativeMath.sincos(t)\r\n  return new Polar(r * NativeMath.sincos_cos, r * NativeMath.sincos_sin)\r\n}\r\n\r\nfunction fftSimple(r: StaticArray<f64>, i: StaticArray<f64>): PolarArray {\r\n  const N = r.length\r\n  const R = new StaticArray<f64>(N)\r\n  const I = new StaticArray<f64>(N)\r\n\r\n  if (N === 1) {\r\n    unchecked((R[0] = r[0]))\r\n    unchecked((I[0] = i[0]))\r\n    return new PolarArray(R, I)\r\n  }\r\n\r\n  const len = N / 2\r\n  const er = new StaticArray<f64>(len)\r\n  const ei = new StaticArray<f64>(len)\r\n  const dr = new StaticArray<f64>(len)\r\n  const di = new StaticArray<f64>(len)\r\n\r\n  for (let k = 0; k < len; ++k) {\r\n    unchecked((er[k] = r[2 * k]))\r\n    unchecked((ei[k] = i[2 * k]))\r\n    unchecked((dr[k] = r[2 * k + 1]))\r\n    unchecked((di[k] = i[2 * k + 1]))\r\n  }\r\n\r\n  const E = fftSimple(er, ei)\r\n  const D = fftSimple(dr, di)\r\n  const ER = E.r\r\n  const EI = E.i\r\n  const DR = D.r\r\n  const DI = D.i\r\n\r\n  for (let k = 0; k < len; ++k) {\r\n    const c = complexPolar(1, (-2.0 * Math.PI * k) / N)\r\n    const r = unchecked(DR[k])\r\n    const i = unchecked(DI[k])\r\n    unchecked((DR[k] = r * c.r - i * c.i))\r\n    unchecked((DI[k] = r * c.i + i * c.r))\r\n  }\r\n\r\n  for (let k = 0; k < len; ++k) {\r\n    const er = unchecked(ER[k])\r\n    const dr = unchecked(DR[k])\r\n    const ei = unchecked(EI[k])\r\n    const di = unchecked(DI[k])\r\n    unchecked((R[k] = er + dr))\r\n    unchecked((I[k] = ei + di))\r\n\r\n    unchecked((R[k + len] = er - dr))\r\n    unchecked((I[k + len] = ei - di))\r\n  }\r\n\r\n  return new PolarArray(R, I)\r\n}\r\n\r\nfunction transpose(m: StaticArray<PolarArray>): void {\r\n  let tempr: f64, tempi: f64\r\n  const N = m.length\r\n\r\n  for (let i = 0; i < N; ++i) {\r\n    const mi = unchecked(m[i])\r\n    const miR = mi.r\r\n    const miI = mi.i\r\n\r\n    for (let j = 0; j < i; ++j) {\r\n      const mj = unchecked(m[j])\r\n      const mjR = mj.r\r\n      const mjI = mj.i\r\n\r\n      tempr = unchecked(miR[j])\r\n      tempi = unchecked(miI[j])\r\n\r\n      unchecked((miR[j] = mjR[i]))\r\n      unchecked((miI[j] = mjI[i]))\r\n\r\n      unchecked((mjR[i] = tempr))\r\n      unchecked((mjI[i] = tempi))\r\n    }\r\n  }\r\n}\r\n\r\nfunction fft2D(m: StaticArray<PolarArray>): StaticArray<PolarArray> {\r\n  const len = m.length\r\n  const M = new StaticArray<PolarArray>(len)\r\n\r\n  for (let i = 0; i < len; ++i) {\r\n    const mi = unchecked(m[i])\r\n    unchecked((M[i] = fftSimple(mi.r, mi.i)))\r\n  }\r\n  transpose(M)\r\n\r\n  for (let i = 0; i < len; ++i) {\r\n    const Mi = unchecked(M[i])\r\n    unchecked((M[i] = fftSimple(Mi.r, Mi.i)))\r\n  }\r\n  transpose(M)\r\n\r\n  return M\r\n}\r\n\r\nfunction randomComplexArray(n: i32): PolarArray {\r\n  const R = new StaticArray<f64>(n)\r\n  const I = new StaticArray<f64>(n)\r\n\r\n  for (let i = 0; i < n; ++i) {\r\n    unchecked((R[i] = commonRandomJS() * 2 - 1))\r\n    unchecked((I[i] = commonRandomJS() * 2 - 1))\r\n  }\r\n\r\n  return new PolarArray(R, I)\r\n}\r\n\r\nfunction randomComplexMatrix(n: i32): StaticArray<PolarArray> {\r\n  const M = new StaticArray<PolarArray>(n)\r\n  for (let i = 0; i < n; ++i) {\r\n    unchecked((M[i] = randomComplexArray(n)))\r\n  }\r\n  return M\r\n}\r\n\r\nexport function fft(): f64 {\r\n  const twoExp: i32 = 8\r\n  const n = 1 << twoExp\r\n  const data2D = randomComplexMatrix(n)\r\n\r\n  const t1 = performance.now()\r\n  fft2D(data2D)\r\n  __collect()\r\n  const t2 = performance.now()\r\n  return t2 - t1\r\n}\r\n","import { performance, commonRandomJS } from './common'\r\n\r\nfunction randomMatrix(matrix: StaticArray<f64>): void {\r\n  const size = Math.sqrt(matrix.length)\r\n  const l = new StaticArray<f64>(matrix.length)\r\n  const u = new StaticArray<f64>(matrix.length)\r\n\r\n  for (let i = 0; i < size; ++i) {\r\n    for (let j = 0; j < size; ++j) {\r\n      if (i > j) {\r\n        unchecked((l[(i * size + j) as i32] = commonRandomJS()))\r\n      } else if (i == j) {\r\n        unchecked((l[(i * size + j) as i32] = 1))\r\n      } else {\r\n        unchecked((l[(i * size + j) as i32] = 0))\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let j = 0; j < size; ++j) {\r\n    for (let i = 0; i < size; ++i) {\r\n      if (i > j) {\r\n        unchecked((u[(j * size + i) as i32] = 0))\r\n      } else {\r\n        unchecked((u[(j * size + i) as i32] = commonRandomJS()))\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < size; ++i) {\r\n    for (let j = 0; j < size; ++j) {\r\n      let sum: f64 = 0\r\n      for (let k = 0; k < size; k++) {\r\n        sum += unchecked(l[(i * size + k) as i32]) * unchecked(u[(j * size + k) as i32])\r\n      }\r\n      unchecked((matrix[(i * size + j) as i32] = sum))\r\n    }\r\n  }\r\n}\r\n\r\nfunction performLud(matrix: StaticArray<f64>, size: i32): void {\r\n  let k: i32, sum: f64\r\n\r\n  for (let i = 0; i < size; ++i) {\r\n    for (let j = i; j < size; ++j) {\r\n      unchecked((sum = matrix[i * size + j]))\r\n      for (k = 0; k < i; ++k) {\r\n        unchecked((sum -= matrix[i * size + k] * matrix[k * size + j]))\r\n      }\r\n\r\n      unchecked((matrix[i * size + j] = sum))\r\n    }\r\n\r\n    for (let j = i + 1; j < size; j++) {\r\n      unchecked((sum = matrix[j * size + i]))\r\n      for (k = 0; k < i; ++k) {\r\n        unchecked((sum -= matrix[j * size + k] * matrix[k * size + i]))\r\n      }\r\n      unchecked((matrix[j * size + i] = sum / matrix[i * size + i]))\r\n    }\r\n  }\r\n}\r\n\r\nexport function lud(): f64 {\r\n  const size: i32 = 512\r\n  const matrix = new StaticArray<f64>(size * size)\r\n  randomMatrix(matrix)\r\n\r\n  const t1 = performance.now()\r\n  performLud(matrix, size)\r\n  __collect()\r\n  const t2 = performance.now()\r\n  return t2 - t1\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\r\nimport { idof } from \"./builtins\";\r\nimport { E_INVALIDLENGTH } from \"./util/error\";\r\n\r\nexport abstract class ArrayBufferView {\r\n\r\n  readonly buffer: ArrayBuffer;\r\n  @unsafe readonly dataStart: usize;\r\n  readonly byteLength: i32;\r\n\r\n  get byteOffset(): i32 {\r\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\r\n  }\r\n\r\n  protected constructor(length: i32, alignLog2: i32) {\r\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\r\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\r\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\r\n    this.buffer = buffer; // links\r\n    this.dataStart = changetype<usize>(buffer);\r\n    this.byteLength = length;\r\n  }\r\n}\r\n\r\n@final export class ArrayBuffer {\r\n\r\n  static isView<T>(value: T): bool {\r\n    if (isNullable<T>()) {\r\n      if (value === null) return false;\r\n    }\r\n    if (value instanceof Int8Array) return true;\r\n    if (value instanceof Uint8Array) return true;\r\n    if (value instanceof Uint8ClampedArray) return true;\r\n    if (value instanceof Int16Array) return true;\r\n    if (value instanceof Uint16Array) return true;\r\n    if (value instanceof Int32Array) return true;\r\n    if (value instanceof Uint32Array) return true;\r\n    if (value instanceof Int64Array) return true;\r\n    if (value instanceof Uint64Array) return true;\r\n    if (value instanceof Float32Array) return true;\r\n    if (value instanceof Float64Array) return true;\r\n    if (value instanceof DataView) return true;\r\n    return false;\r\n  }\r\n\r\n  constructor(length: i32) {\r\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\r\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\r\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\r\n    return buffer;\r\n  }\r\n\r\n  get byteLength(): i32 {\r\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\r\n    var length = this.byteLength;\r\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\r\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\r\n    var outSize = <usize>max(end - begin, 0);\r\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\r\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\r\n    return out;\r\n  }\r\n\r\n  toString(): string {\r\n    return \"[object ArrayBuffer]\";\r\n  }\r\n}\r\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\r\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\r\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\r\nimport { idof } from \"./builtins\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\n\r\nexport class Int8Array extends ArrayBufferView {\r\n  [key: number]: i8;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i8>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i8 {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i8 {\r\n    return load<i8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<i8>): void {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<i8>): void {\r\n    store<i8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return FILL<Int8Array, i8>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\r\n    return SORT<Int8Array, i8>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return SLICE<Int8Array, i8>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\r\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\r\n    return MAP<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\r\n    return FILTER<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\r\n    return FIND_INDEX<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\r\n    return SOME<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\r\n    return EVERY<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\r\n    FOREACH<Int8Array, i8>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i8>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\r\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint8Array extends ArrayBufferView {\r\n  [key: number]: u8;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u8>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u8 {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u8 {\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<u8>): void {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<u8>): void {\r\n    store<u8>(this.dataStart + <usize>index, value);\r\n  }\r\n\r\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return FILL<Uint8Array, u8>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\r\n    return SORT<Uint8Array, u8>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return SLICE<Uint8Array, u8>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\r\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\r\n    return MAP<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\r\n    return FILTER<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\r\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\r\n    return SOME<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\r\n    return EVERY<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\r\n    FOREACH<Uint8Array, u8>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u8>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\r\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint8ClampedArray extends ArrayBufferView {\r\n  [key: number]: u8;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u8>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength;\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u8 {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u8 {\r\n    return load<u8>(this.dataStart + <usize>index);\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<u8>): void {\r\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<u8>): void {\r\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\r\n  }\r\n\r\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\r\n  }\r\n\r\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\r\n    return SORT<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\r\n  }\r\n\r\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\r\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\r\n    return MAP<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\r\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\r\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\r\n    return SOME<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\r\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\r\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u8>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\r\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Int16Array extends ArrayBufferView {\r\n  [key: number]: i16;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i16>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<i16>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i16 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i16 {\r\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<i16>): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<i16>): void {\r\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\r\n  }\r\n\r\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return FILL<Int16Array, i16>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\r\n    return SORT<Int16Array, i16>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return SLICE<Int16Array, i16>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\r\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\r\n    return MAP<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\r\n    return FILTER<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\r\n    return FIND_INDEX<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\r\n    return SOME<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\r\n    return EVERY<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\r\n    FOREACH<Int16Array, i16>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i16>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\r\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint16Array extends ArrayBufferView {\r\n  [key: number]: u16;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u16>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<u16>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u16 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u16 {\r\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: native<u16>): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: native<u16>): void {\r\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\r\n  }\r\n\r\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return FILL<Uint16Array, u16>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\r\n    return SORT<Uint16Array, u16>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return SLICE<Uint16Array, u16>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\r\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\r\n    return MAP<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\r\n    return FILTER<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\r\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\r\n    return SOME<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\r\n    return EVERY<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\r\n    FOREACH<Uint16Array, u16>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u16>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\r\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Int32Array extends ArrayBufferView {\r\n  [key: number]: i32;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i32>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<i32>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i32 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i32 {\r\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: i32): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: i32): void {\r\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\r\n  }\r\n\r\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return FILL<Int32Array, i32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\r\n    return SORT<Int32Array, i32>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return SLICE<Int32Array, i32>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\r\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\r\n    return MAP<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\r\n    return FILTER<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\r\n    return FIND_INDEX<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\r\n    return SOME<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\r\n    return EVERY<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\r\n    FOREACH<Int32Array, i32>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i32>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\r\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint32Array extends ArrayBufferView {\r\n  [key: number]: u32;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u32>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<u32>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u32 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u32 {\r\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: u32): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: u32): void {\r\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\r\n  }\r\n\r\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return FILL<Uint32Array, u32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\r\n    return SORT<Uint32Array, u32>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return SLICE<Uint32Array, u32>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\r\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\r\n    return MAP<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\r\n    return FILTER<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\r\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\r\n    return SOME<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\r\n    return EVERY<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\r\n    FOREACH<Uint32Array, u32>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u32>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\r\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Int64Array extends ArrayBufferView {\r\n  [key: number]: i64;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<i64>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<i64>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): i64 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): i64 {\r\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: i64): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: i64): void {\r\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\r\n  }\r\n\r\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return FILL<Int64Array, i64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\r\n    return SORT<Int64Array, i64>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return SLICE<Int64Array, i64>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\r\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\r\n    return MAP<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\r\n    return FILTER<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\r\n    return FIND_INDEX<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\r\n    return SOME<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\r\n    return EVERY<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\r\n    FOREACH<Int64Array, i64>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, i64>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\r\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Uint64Array extends ArrayBufferView {\r\n  [key: number]: u64;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<u64>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<u64>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): u64 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): u64 {\r\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: u64): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: u64): void {\r\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\r\n  }\r\n\r\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return FILL<Uint64Array, u64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\r\n    return SORT<Uint64Array, u64>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return SLICE<Uint64Array, u64>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\r\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\r\n    return MAP<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\r\n    return FILTER<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\r\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\r\n    return SOME<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\r\n    return EVERY<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\r\n    FOREACH<Uint64Array, u64>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, u64>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\r\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Float32Array extends ArrayBufferView {\r\n  [key: number]: f32;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<f32>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<f32>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): f32 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): f32 {\r\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: f32): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: f32): void {\r\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\r\n  }\r\n\r\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return FILL<Float32Array, f32>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\r\n    return SORT<Float32Array, f32>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return SLICE<Float32Array, f32>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\r\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\r\n    return MAP<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\r\n    return FILTER<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\r\n    return FIND_INDEX<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\r\n    return SOME<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\r\n    return EVERY<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\r\n    FOREACH<Float32Array, f32>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, f32>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\r\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\nexport class Float64Array extends ArrayBufferView {\r\n  [key: number]: f64;\r\n\r\n  // @ts-ignore: decorator\r\n  @lazy\r\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\r\n\r\n  constructor(length: i32) {\r\n    super(length, alignof<f64>());\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.byteLength >>> alignof<f64>();\r\n  }\r\n\r\n  @operator(\"[]\")\r\n  private __get(index: i32): f64 {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\r\n  }\r\n\r\n  @unsafe @operator(\"{}\")\r\n  private __uget(index: i32): f64 {\r\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\r\n  }\r\n\r\n  @operator(\"[]=\")\r\n  private __set(index: i32, value: f64): void {\r\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\r\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\r\n  }\r\n\r\n  @unsafe @operator(\"{}=\")\r\n  private __uset(index: i32, value: f64): void {\r\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\r\n  }\r\n\r\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\r\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\r\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\r\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\r\n  }\r\n\r\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return FILL<Float64Array, f64>(this, value, start, end);\r\n  }\r\n\r\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\r\n    return SORT<Float64Array, f64>(this, comparator);\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return SLICE<Float64Array, f64>(this, begin, end);\r\n  }\r\n\r\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\r\n  }\r\n\r\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\r\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\r\n  }\r\n\r\n  reduce<T>(\r\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  reduceRight<T>(\r\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\r\n    initialValue: T,\r\n  ): T {\r\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\r\n  }\r\n\r\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\r\n    return MAP<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\r\n    return FILTER<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\r\n    return FIND_INDEX<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\r\n    return SOME<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\r\n    return EVERY<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\r\n    FOREACH<Float64Array, f64>(this, fn);\r\n  }\r\n\r\n  reverse(): this {\r\n    return REVERSE<this, f64>(this);\r\n  }\r\n\r\n  join(separator: string = \",\"): string {\r\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\r\n  }\r\n\r\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\r\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.join();\r\n  }\r\n\r\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\r\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\r\n  array: TArray,\r\n  value: native<T>,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var dataStart = array.dataStart;\r\n  var len = array.length;\r\n  start = start < 0 ? max(len + start, 0) : min(start, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  if (sizeof<T>() == 1) {\r\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\r\n  } else {\r\n    for (; start < end; ++start) {\r\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SORT<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  comparator: (a: T, b: T) => i32\r\n): TArray {\r\n  var len = array.length;\r\n  if (len <= 1) return array;\r\n  var base = array.dataStart;\r\n  if (len == 2) {\r\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\r\n    let b: T = load<T>(base); // b = arr[0]\r\n    if (comparator(a, b) < 0) {\r\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\r\n      store<T>(base, a); // arr[0] = a\r\n    }\r\n    return array;\r\n  }\r\n  SORT_IMPL<T>(base, len, comparator);\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SLICE<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var len = array.length;\r\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\r\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\r\n  len = max(end - start, 0);\r\n  var slice = instantiate<TArray>(len);\r\n  memory.copy(\r\n    slice.dataStart,\r\n    array.dataStart + (<usize>start << alignof<T>()),\r\n    <usize>len << alignof<T>()\r\n  );\r\n  return slice;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  begin: i32,\r\n  end: i32\r\n): TArray {\r\n  var len = array.length;\r\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\r\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\r\n  end   = max(end, begin);\r\n\r\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\r\n  var buf = changetype<usize>(array.buffer);\r\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\r\n  __link(changetype<usize>(out), buf, false);\r\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\r\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\r\n  return out;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  target: i32,\r\n  start: i32,\r\n  end: i32\r\n): TArray {\r\n  var len = array.length;\r\n  var dataStart = array.dataStart;\r\n\r\n  end   = min<i32>(end, len);\r\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\r\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\r\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\r\n  var count = min(last - from, len - to);\r\n\r\n  memory.copy(\r\n    dataStart + (<usize>to << alignof<T>()),\r\n    dataStart + (<usize>from << alignof<T>()),\r\n    <usize>count << alignof<T>()\r\n  );\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\r\n  array: TArray,\r\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\r\n  array: TArray,\r\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\r\n  initialValue: TRet\r\n): TRet {\r\n  var dataStart = array.dataStart;\r\n  for (let i = array.length - 1; i >= 0; i--) {\r\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\r\n  }\r\n  return initialValue;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction MAP<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, self: TArray) => T,\r\n): TArray {\r\n  var len = array.length;\r\n  var dataStart = array.dataStart;\r\n\r\n  var byteLength = len << alignof<T>();\r\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\r\n  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\r\n  for (let i = 0; i < len; i++) {\r\n    store<T>(\r\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\r\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\r\n    );\r\n  }\r\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\r\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\r\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\r\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\r\n  return out;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FILTER<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, self: TArray) => bool,\r\n): TArray {\r\n  var len = array.length;\r\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\r\n  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\r\n  var dataStart  = array.dataStart;\r\n  var j: usize = 0;\r\n  for (let i = 0; i < len; i++) {\r\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\r\n    if (fn(value, i, array)) {\r\n      store<T>(\r\n        changetype<usize>(buf) + (j++ << alignof<T>()),\r\n        value\r\n      );\r\n    }\r\n  }\r\n  // shrink output buffer\r\n  var byteLength = j << alignof<T>();\r\n  var data = __renew(changetype<usize>(buf), byteLength);\r\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\r\n  __link(changetype<usize>(out), data, false);\r\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\r\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\r\n  return out;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => bool,\r\n): i32 {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  searchElement: T,\r\n  fromIndex: i32,\r\n): bool {\r\n  if (isFloat<T>()) {\r\n    let index: isize = fromIndex;\r\n    let length: isize = array.length;\r\n    if (length == 0 || index >= length) return false;\r\n    if (index < 0) index = max(length + index, 0);\r\n    let dataStart = array.dataStart;\r\n    while (index < length) {\r\n      let elem = load<T>(dataStart + (index << alignof<T>()));\r\n      // @ts-ignore\r\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\r\n      ++index;\r\n    }\r\n    return false;\r\n  } else {\r\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  searchElement: T,\r\n  fromIndex: i32,\r\n): i32 {\r\n  var index: isize = fromIndex;\r\n  var length: isize = array.length;\r\n  if (length == 0 || index >= length) return -1;\r\n  if (index < 0) index = max(length + index, 0);\r\n  var dataStart = array.dataStart;\r\n  while (index < length) {\r\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\r\n    ++index;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  searchElement: T,\r\n  fromIndex: i32,\r\n): i32 {\r\n  var index: isize = fromIndex;\r\n  var length: isize = array.length;\r\n  if (length == 0) return -1;\r\n  if (index < 0) index = length + index; // no need to clamp\r\n  else if (index >= length) index = length - 1;\r\n  var dataStart = array.dataStart;\r\n  while (index >= 0) {\r\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\r\n    --index;\r\n  }\r\n  return -1;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SOME<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction EVERY<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => bool,\r\n): bool {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction FOREACH<TArray extends ArrayBufferView, T>(\r\n  array: TArray,\r\n  fn: (value: T, index: i32, array: TArray) => void,\r\n): void {\r\n  var dataStart = array.dataStart;\r\n  for (let i = 0, k = array.length; i < k; i++) {\r\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\r\n  var dataStart = array.dataStart;\r\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\r\n    let frontPtr = dataStart + (front << alignof<T>());\r\n    let backPtr = dataStart + (back << alignof<T>());\r\n    let temp = load<T>(frontPtr);\r\n    store<T>(frontPtr, load<T>(backPtr));\r\n    store<T>(backPtr, temp);\r\n  }\r\n  return array;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction WRAP<TArray extends ArrayBufferView, T>(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): TArray {\r\n  var byteLength: i32;\r\n  var bufferByteLength = buffer.byteLength;\r\n  const mask: u32 = sizeof<T>() - 1;\r\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\r\n    throw new RangeError(E_INDEXOUTOFRANGE);\r\n  }\r\n  if (length < 0) {\r\n    if (length == -1) {\r\n      if (bufferByteLength & mask) {\r\n        throw new RangeError(E_INVALIDLENGTH);\r\n      }\r\n      byteLength = bufferByteLength - byteOffset;\r\n    } else {\r\n      throw new RangeError(E_INVALIDLENGTH);\r\n    }\r\n  } else {\r\n    byteLength = length << alignof<T>();\r\n    if (byteOffset + byteLength > bufferByteLength) {\r\n      throw new RangeError(E_INVALIDLENGTH);\r\n    }\r\n  }\r\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\r\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\r\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\r\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\r\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\r\n  return out;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(target: TArray, source: UArray, offset: i32 = 0): void {\r\n  // need to assert at compile time that U is not a reference or a function\r\n  if (isReference<U>()) {\r\n    ERROR(E_NOTIMPLEMENTED);\r\n  }\r\n\r\n  // Uncaught RangeError: offset is out of bounds\r\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\r\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\r\n\r\n  // if the types align and match, use memory.copy() instead of manual loop\r\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\r\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\r\n    memory.copy(\r\n      target.dataStart + (<usize>offset << alignof<T>()),\r\n      source.dataStart,\r\n      source.byteLength\r\n    );\r\n  } else {\r\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\r\n    let sourceDataStart = source.dataStart;\r\n    let count = source.length;\r\n    for (let i = 0; i < count; i++) {\r\n      // if TArray is Uint8ClampedArray, then values must be clamped\r\n      if (target instanceof Uint8ClampedArray) {\r\n        if (isFloat<U>()) {\r\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\r\n          store<T>(\r\n            targetDataStart + (<usize>i << alignof<T>()),\r\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : 0\r\n          );\r\n        } else {\r\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\r\n          if (!isSigned<U>()) {\r\n            store<T>(\r\n              targetDataStart + (<usize>i << alignof<T>()),\r\n              // @ts-ignore: cast to T is valid for numeric types here\r\n              min<U>(255, value)\r\n            );\r\n          } else if (sizeof<T>() <= 4) {\r\n            store<T>(\r\n              targetDataStart + (<usize>i << alignof<T>()),\r\n              // @ts-ignore: cast to T is valid for numeric types here\r\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\r\n            );\r\n          } else {\r\n            store<T>(\r\n              targetDataStart + (<usize>i << alignof<T>()),\r\n              // @ts-ignore: cast to T is valid for numeric types here\r\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\r\n            );\r\n          }\r\n        }\r\n        // if U is a float, then casting float to int must include a finite check\r\n      } else if (isFloat<U>() && !isFloat<T>()) {\r\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\r\n        // @ts-ignore: cast to T is valid for numeric types here\r\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\r\n      } else if (isFloat<T>() && !isFloat<U>()) {\r\n        // @ts-ignore: In this case the <T> conversion is required\r\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\r\n      } else {\r\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\r\n      }\r\n    }\r\n  }\r\n}\r\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\r\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\r\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\r\nimport { ArrayBufferView } from \"./arraybuffer\";\r\n\r\n// @ts-ignore: decorator\r\n@builtin\r\nexport declare const __rtti_base: usize;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_globals(cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@builtin @unsafe\r\nexport declare function __visit_members(ref: usize, cookie: u32): void;\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __typeinfo(id: u32): TypeinfoFlags {\r\n  var ptr = __rtti_base;\r\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\r\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\r\n  var id = changetype<OBJECT>(ref - TOTAL_OVERHEAD).rtId;\r\n  var ptr = __rtti_base;\r\n  if (id <= load<u32>(ptr)) {\r\n    do if (id == superId) return true;\r\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\r\n  }\r\n  return false;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\r\n  var buffer = __new(size, id);\r\n  if (data) memory.copy(buffer, data, size);\r\n  return buffer;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@unsafe\r\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\r\n  var array = __new(offsetof<i32[]>(), id);\r\n  var bufferSize = <usize>length << alignLog2;\r\n  var buffer = __newBuffer(bufferSize, idof<ArrayBuffer>(), data);\r\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"buffer\"));\r\n  __link(array, buffer, false);\r\n  store<usize>(array, buffer, offsetof<ArrayBufferView>(\"dataStart\"));\r\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\r\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\r\n  return array;\r\n}\r\n\r\n// These are provided by the respective implementation, included as another entry file by asc:\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __alloc(size: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __realloc(ptr: usize, size: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __free(ptr: usize): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __new(size: usize, id: u32): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __renew(ptr: usize, size: usize): usize;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __collect(incremental: bool = false): void;\r\n\r\n// // @ts-ignore: decorator\r\n// @builtin @unsafe\r\n// export declare function __visit(ptr: usize, cookie: u32): void;\r\n","import { compareImpl } from \"./string\";\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function COMPARATOR<T>(): (a: T, b: T) => i32 {\r\n  if (isInteger<T>()) {\r\n    if (isSigned<T>() && sizeof<T>() <= 4) {\r\n      return (a: T, b: T): i32 => (i32(a) - i32(b));\r\n    } else {\r\n      return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\r\n    }\r\n  } else if (isFloat<T>()) {\r\n    if (sizeof<T>() == 4) {\r\n      return (a: T, b: T): i32 => {\r\n        var ia = reinterpret<i32>(f32(a));\r\n        var ib = reinterpret<i32>(f32(b));\r\n        ia ^= (ia >> 31) >>> 1;\r\n        ib ^= (ib >> 31) >>> 1;\r\n        return i32(ia > ib) - i32(ia < ib);\r\n      };\r\n    } else {\r\n      return (a: T, b: T): i32 => {\r\n        var ia = reinterpret<i64>(f64(a));\r\n        var ib = reinterpret<i64>(f64(b));\r\n        ia ^= (ia >> 63) >>> 1;\r\n        ib ^= (ib >> 63) >>> 1;\r\n        return i32(ia > ib) - i32(ia < ib);\r\n      };\r\n    }\r\n  } else if (isString<T>()) {\r\n    return (a: T, b: T): i32 => {\r\n      if (a === b || a === null || b === null) return 0;\r\n      var alen = changetype<string>(a).length;\r\n      var blen = changetype<string>(b).length;\r\n      if (!(alen | blen)) return 0;\r\n      if (!alen) return -1;\r\n      if (!blen) return  1;\r\n      let res = compareImpl(changetype<string>(a), 0, changetype<string>(b), 0, <usize>min(alen, blen));\r\n      return res ? res : alen - blen;\r\n    };\r\n  } else {\r\n    return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline\r\nexport function SORT<T>(\r\n  dataStart: usize,\r\n  length: i32,\r\n  comparator: (a: T, b: T) => i32\r\n): void {\r\n  if (isReference<T>()) {\r\n    // TODO replace this to faster stable sort (TimSort) when it implemented\r\n    insertionSort<T>(dataStart, length, comparator);\r\n  } else {\r\n    if (length < 256) {\r\n      insertionSort<T>(dataStart, length, comparator);\r\n    } else {\r\n      weakHeapSort<T>(dataStart, length, comparator);\r\n    }\r\n  }\r\n}\r\n\r\nfunction insertionSort<T>(\r\n  dataStart: usize,\r\n  length: i32,\r\n  comparator: (a: T, b: T) => i32\r\n): void {\r\n  for (let i = 0; i < length; i++) {\r\n    let a: T = load<T>(dataStart + (<usize>i << alignof<T>())); // a = arr[i]\r\n    let j = i - 1;\r\n    while (j >= 0) {\r\n      let b: T = load<T>(dataStart + (<usize>j << alignof<T>())); // b = arr[j]\r\n      if (comparator(a, b) < 0) {\r\n        store<T>(dataStart + (<usize>(j-- + 1) << alignof<T>()), b); // arr[j + 1] = b\r\n      } else break;\r\n    }\r\n    store<T>(dataStart + (<usize>(j + 1) << alignof<T>()), a); // arr[j + 1] = a\r\n  }\r\n}\r\n\r\nfunction weakHeapSort<T>(\r\n  dataStart: usize,\r\n  length: i32,\r\n  comparator: (a: T, b: T) => i32\r\n): void {\r\n  const shift32 = alignof<u32>();\r\n\r\n  var bitsetSize = (<usize>length + 31) >> 5 << shift32;\r\n  var bitset = __alloc(bitsetSize); // indexed in 32-bit chunks below\r\n  memory.fill(bitset, 0, bitsetSize);\r\n\r\n  // see: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.1863&rep=rep1&type=pdf\r\n\r\n  for (let i = length - 1; i > 0; i--) {\r\n    let j = i;\r\n    while ((j & 1) == (load<u32>(bitset + (<usize>j >> 6 << shift32)) >> (j >> 1 & 31) & 1)) j >>= 1;\r\n\r\n    let p = j >> 1;\r\n    let a: T = load<T>(dataStart + (<usize>p << alignof<T>())); // a = arr[p]\r\n    let b: T = load<T>(dataStart + (<usize>i << alignof<T>())); // b = arr[i]\r\n    if (comparator(a, b) < 0) {\r\n      store<u32>(\r\n        bitset + (<usize>i >> 5 << shift32),\r\n        load<u32>(bitset + (<usize>i >> 5 << shift32)) ^ (1 << (i & 31))\r\n      );\r\n      store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\r\n      store<T>(dataStart + (<usize>p << alignof<T>()), b); // arr[p] = b\r\n    }\r\n  }\r\n\r\n  for (let i = length - 1; i >= 2; i--) {\r\n    let a: T = load<T>(dataStart); // a = arr[0]\r\n    store<T>(dataStart, load<T>(dataStart + (<usize>i << alignof<T>()))); // arr[0] = arr[i]\r\n    store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\r\n\r\n    let x = 1, y: i32;\r\n    while ((y = (x << 1) + ((load<u32>(bitset + (<usize>x >> 5 << shift32)) >> (x & 31)) & 1)) < i) x = y;\r\n\r\n    while (x > 0) {\r\n      a = load<T>(dataStart); // a = arr[0]\r\n      let b: T = load<T>(dataStart + (<usize>x << alignof<T>())); // b = arr[x]\r\n\r\n      if (comparator(a, b) < 0) {\r\n        store<u32>(\r\n          bitset + (<usize>x >> 5 << shift32),\r\n          load<u32>(bitset + (<usize>x >> 5 << shift32)) ^ (1 << (x & 31))\r\n        );\r\n        store<T>(dataStart + (<usize>x << alignof<T>()), a); // arr[x] = a\r\n        store<T>(dataStart, b); // arr[0] = b\r\n      }\r\n      x >>= 1;\r\n    }\r\n  }\r\n\r\n  __free(bitset);\r\n\r\n  var t: T = load<T>(dataStart, sizeof<T>()); // t = arr[1]\r\n  store<T>(dataStart, load<T>(dataStart), sizeof<T>()); // arr[1] = arr[0]\r\n  store<T>(dataStart, t); // arr[0] = t\r\n}\r\n","type auto = i32;\r\n\r\n@final export abstract class Function<T> {\r\n  private _index: u32;\r\n  private _env: usize;\r\n\r\n  // @ts-ignore: this on getter\r\n  get index(this: T): u32 {\r\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\r\n  }\r\n\r\n  // @ts-ignore: this on getter\r\n  get name(this: T): string {\r\n    return \"\";\r\n  }\r\n\r\n  // @ts-ignore: this on getter\r\n  get length(this: T): i32 {\r\n    // @ts-ignore: T is function\r\n    return lengthof<T>();\r\n  }\r\n\r\n  // @ts-ignore: T is function\r\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\r\n    return unreachable();\r\n  }\r\n\r\n  toString(this: T): string {\r\n    return \"function() { [native code] }\";\r\n  }\r\n\r\n  // RT integration\r\n\r\n  @unsafe private __visit(cookie: u32): void {\r\n    // Env is either `null` (nop) or compiler-generated\r\n    __visit(this._env, cookie);\r\n  }\r\n}\r\n"]}